
# template file: 050.single_header.yaml

name: "JH Stable Build Artifacts and Images"

on:
  
  workflow_call:
    inputs:
      ref:                      # commit id
        required: false
        type: string
      extraParamsAllBuilds:     # addional build parameter
        required: false
        type: string
  workflow_dispatch:
    inputs:
      ref:
        description: 'Branch, tag, or SHA to build'
        required: true
        default: 'main-jethub'
      skipImages:
        description: 'Skip building images? no = build images, yes = skip images'
        required: true
        options: [ 'yes', 'no' ]
        type: choice
        default: 'no'
      checkOci:
        description: 'Check OCI for existing artifacts? yes = check OCI, no = always build everything'
        required: true
        options: [ 'yes', 'no' ]
        type: choice
        default: 'yes'
      extraParamsAllBuilds:
        description: 'Extra params for all builds/jobs (prepare/artifact/image) (eg: DEBUG=yes)'
        required: false
        default: ''
        type: string
      board:
        type: choice
        description: 'Board'
        options:
        # boards
        - all
        - jethubj100
        - jethubj80
        - jethubj200
        default: 'all'
      nightlybuild:
        description: 'yes = nighlty, no = stable'
        required: false
        options: [ 'yes', 'no' ]
        type: choice
        default: 'no'
      uploadtoserver:
        description: 'CDN upload  github = releases, jethome = fw.jethome.ru'
        required: false
        options: [ 'github', 'jethome', 'both' ]
        type: choice
        default: 'github'
      versionOverride:
        description: 'Version override'
        required: false
        default: ''
      skip_version_bump:
        description: 'Skip version bump? true = skip, false = bump'
        required: false
        options: [ 'true', 'false' ]
        type: choice
        default: 'false'

env:

  # For easier reuse across the multiple chunks ('armbian/build' repo)
  BUILD_REPOSITORY: "jethome-iot/armbian-build"
  BUILD_REF: "${{ inputs.ref || inputs.branch || 'main-jethub' }}" # branch or tag or sha1

  # For easier reuse across the multiple chunks ('armbian/os' repo)
  USERPATCHES_REPOSITORY: "jethome-iot/armbian-os"
  USERPATCHES_REF: "main" # branch or tag or sha1
  USERPATCHES_DIR: "userpatches-jethub" # folder inside USERPATCHES_REPOSITORY

  # Github repository for releases. Normally its the one where we executing script
  RELEASE_REPOSITORY: "armbian-os"

  # Armbian envs. Adjust to your needs.
  # This makes builds faster, but only if the Docker images are up-to-date with all dependencies, Python, tools, etc. Otherwise it makes it... slower.
  DOCKER_SKIP_UPDATE: "yes" # Do not apt update/install/requirements/etc during Dockerfile build, trust that Docker images are up-to-date.

  # Added to every build, even the prepare job.
  EXTRA_PARAMS_ALL_BUILDS: "${{ inputs.extraParamsAllBuilds || 'UPLOAD_TO_OCI_ONLY=yes' }}"

  VERSION_OVERRIDE: "${{ github.event.inputs.versionOverride }}"

  # To use GitHub CLI in a GitHub Actions workflow
  GH_TOKEN: "${{ secrets.GITHUB_TOKEN }}"

  # Added to every image build arguments.
  EXTRA_PARAMS_IMAGE: "SHOW_DEBIAN=yes SHARE_LOG=yes "

  #OCI_TARGET_BASE: "ghcr.io/jethome-iot/armbian-os/"
  DOCKER_ARMBIAN_BASE_IMAGE: "ubuntu:noble"
  DOCKERFILE_USE_ARMBIAN_IMAGE_AS_BASE: "no"
  DOCKER_ARMBIAN_BASE_COORDINATE_PREFIX: "cr.jethome.work/armbian/docker-armbian-build:"
  OCI_TARGET_BASE: "cr.jethome.work/armbian/"

concurrency:
  group: ${{ github.run_id }}-pipeline-stable
  cancel-in-progress: false

jobs:

  version_prep:
    name: "Bump version"
    runs-on: [ "ubuntu-latest" ]
    steps:

      # Clone the userpatches repo (`armbian/os`)
      - name: "Checkout userpatches repo: ${{env.USERPATCHES_REPOSITORY}}#${{env.USERPATCHES_REF}}"
        uses: actions/checkout@v4
        if: ${{ ( env.USERPATCHES_REPOSITORY != '' ) && ( env.USERPATCHES_REF != '' ) }}
        with:
          repository: ${{ env.USERPATCHES_REPOSITORY }}
          ref: ${{ env.USERPATCHES_REF }}
          fetch-depth: 0
          clean: false # true is default.

      - name: Determine version
        id: versionfile
        run: |
          if [ "${{ github.event.inputs.nightlybuild || 'no' }}" == "no" ]; then
              echo "file=stable" >> $GITHUB_OUTPUT
              echo "skip_tag=true" >> $GITHUB_OUTPUT
              echo "pre_release=false" >> $GITHUB_OUTPUT
              # TODO: fix repoupload to master 'armbian'
              echo "repoupload=armbian-test" >> $GITHUB_OUTPUT
              echo "TARGETS_FILENAME=targets-stable.yaml" >> $GITHUB_ENV
              echo "targets_filename=targets-stable.yaml" >> $GITHUB_OUTPUT
          else
            echo "file=nightly" >> $GITHUB_OUTPUT
            echo "pre_release=true" >> $GITHUB_OUTPUT
            echo "repoupload=armbian-beta" >> $GITHUB_OUTPUT
            echo "targets_filename=targets-full.yaml" >> $GITHUB_OUTPUT
            echo "TARGETS_FILENAME=targets-full.yaml" >> $GITHUB_ENV
          fi

      - name: Bump jethome subversion
        id: bumpjhver
        if: ${{ github.event.inputs.skip_version_bump != 'true' }}
        uses: jethome-iot/actions/armbian-jethome-version@master
        with:
          file: ${{ steps.versionfile.outputs.file }}-jethome.json

      - name: commit & push version bump
        if: ${{ github.event.inputs.skip_version_bump != 'true' }}
        run: |
          git add ${{ steps.versionfile.outputs.file }}-jethome.json
          git config --local user.email "dev@jethome.ru"
          git config --local user.name "JetHome Dev Bot"
          git commit --allow-empty -m "Bump JetHome subversion within action" -a

      - name: Push changes
        if: ${{ github.event.inputs.skip_version_bump != 'true' }}
        uses: ad-m/github-push-action@master
        with:
          github_token: ${{ env.GH_TOKEN }}
          repository: ${{ github.repository }}
          branch: ${{ github.ref }}

      - name: Read version from file if nor overriden
        if: ${{ ! github.event.inputs.versionOverride || env.VERSION_BUMP == 'false' }}
        run: |
          mkdir -p downloads
          SUBVER=$(cat "${{ steps.versionfile.outputs.file }}-jethome.json" | jq -r '.version')
          VER=$(cat "${{ steps.versionfile.outputs.file }}.json" | jq -r '.version')
          echo "VERSION_OVERRIDE=${VER}.jh.${SUBVER}"
          echo "VERSION_OVERRIDE=${VER}.jh.${SUBVER}" >> $GITHUB_ENV
          echo ${VER}.jh.${SUBVER} > downloads/version

      - name: 'Upload Artifact'
        uses: actions/upload-artifact@v4
        with:
          name: assets-for-download-v24.11
          path: downloads
          retention-days: 5

      - name: Get version tag
        id: changelog
        run: |
          echo "tag=${{ env.VERSION_OVERRIDE }}"
          echo "tag=${{ env.VERSION_OVERRIDE }}">> $GITHUB_OUTPUT

      - name: "Generate body file"
        if: ${{ (github.event.inputs.skipImages || 'no') != 'yes' }}
        run: |
            echo "
              <h1 align=center>JetHome Rolling releases</h1>
              <p align=center>
              <img alt='Armbian Linux stable' src='https://img.shields.io/badge/dynamic/json?label=Armbian%20Linux%20current&query=CURRENT&color=f71000&cacheSeconds=600&style=for-the-badge&url=https%3A%2F%2Fgithub.com%2Farmbian%2Fscripts%2Freleases%2Fdownload%2Fstatus%2Frunners_capacity.json'>
              <img alt='Armbian Linux rolling' src='https://img.shields.io/badge/dynamic/json?label=Armbian%20Linux%20edge&query=EDGE&color=34be5b&cacheSeconds=600&style=for-the-badge&url=https%3A%2F%2Fgithub.com%2Farmbian%2Fscripts%2Freleases%2Fdownload%2Fstatus%2Frunners_capacity.json'>
              </p>
              <br>
              <br>
              &nbsp;
              </p>" > body.html

      - uses: ncipollo/release-action@v1
        if: ${{ (github.event.inputs.nightlybuild || 'no') == 'yes' && (github.event.inputs.skipImages || 'no') != 'yes' }}
        with:
          repo: "${{ env.RELEASE_REPOSITORY }}"
          tag: "${{ env.VERSION_OVERRIDE }}"
          name: "${{ env.VERSION_OVERRIDE }}"
          bodyFile: "body.html"
          prerelease: "true"
          allowUpdates: true
          removeArtifacts: true
          token: ${{ env.GH_TOKEN }}

      - name: Save
        id: releases
        run: |
          echo "Version=${{ env.VERSION_OVERRIDE }}"
          echo "version=${{ env.VERSION_OVERRIDE }}" >> $GITHUB_OUTPUT

    outputs:

      # not related to matrix
      version: ${{ steps.releases.outputs.version }}
      repoupload: ${{ steps.versionfile.outputs.repoupload }}
      targets_filename: ${{ steps.versionfile.outputs.targets_filename }}

  matrix_prep:
    name: "JSON matrix: 17/16 :: 17 artifact chunks, 16 image chunks"
    if: ${{ github.repository_owner == 'jethome-iot' }}
    needs: [ version_prep ]
    runs-on: [ "self-hosted", "Linux", "vm" ]
    steps:

      # Cleaning self hosted runners
      #- name: Runner clean
      #  uses: armbian/actions/runner-clean@main

      # clone the build system repo (`armbian/build`)
      - name: Checkout build repo
        uses: actions/checkout@v4
        with:
          repository: ${{ env.BUILD_REPOSITORY }}
          ref: ${{ env.BUILD_REF }}
          fetch-depth: 1
          clean: false # true is default. it *will* delete the hosts /dev if mounted inside.
          path: build

      # clone the userpatches repo (`armbian/os`)
      - name: "Checkout userpatches repo: ${{env.USERPATCHES_REPOSITORY}}#${{env.USERPATCHES_REF}}"
        uses: actions/checkout@v4
        if: ${{ ( env.USERPATCHES_REPOSITORY != '' ) && ( env.USERPATCHES_REF != '' ) }}
        with:
          repository: ${{ env.USERPATCHES_REPOSITORY }}
          ref: ${{ env.USERPATCHES_REF }}
          fetch-depth: 0
          clean: false # true is default.
          path: userpatches

      - name: "grab the sha1 of the latest commit of the build repo ${{ env.BUILD_REPOSITORY }}#${{ env.BUILD_REF }}"
        id: latest-commit
        run: |
          cd build
          echo "sha1=$(git rev-parse HEAD)" >> $GITHUB_OUTPUT
          cd ..

      - name: "Put userpatches in place, and remove userpatches repo"
        if: ${{ ( env.USERPATCHES_REPOSITORY != '' ) && ( env.USERPATCHES_REF != '' ) }}
        run: |

          mkdir -pv build/userpatches
          rsync -av userpatches/${{env.USERPATCHES_DIR}}/. build/userpatches/
          echo ${{ needs.version_prep.outputs.version }} > build/userpatches/VERSION

      - name: GitHub cache
        id: cache-restore
        uses: actions/cache@v4
        with:
          path: |
            cache/memoize
            cache/oci/positive
          key: ${{ runner.os }}-matrix-cache-${{ github.sha }}-${{ steps.latest-commit.outputs.sha1 }}"
          restore-keys: |
            ${{ runner.os }}-matrix-cache-

      # Login to ghcr.io, we're gonna do a lot of OCI lookups.
      - name: Docker Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: "${{ github.repository_owner }}" # GitHub username or org
          password: ${{ secrets.GITHUB_TOKEN }}  # GitHub actions builtin token. repo has to have pkg access.

      - name: Prepare Info JSON and Matrices
        id: prepare-matrix
        run: |

          FILTERS="${{ github.event.inputs.targetsFilterInclude }}"

          if [ -z "${FILTERS}" ] && [ "${{ github.event.inputs.board }}" != "all" ] && [ -n "${{ github.event.inputs.board }}" ]; then
              FILTERS='"BOARD:${{ github.event.inputs.board }}"'
          fi

          # this sets outputs "artifact-matrix" #and "image-matrix"
          cd build
          # was TARGETS_FILENAME=${{ needs.version_prep.outputs.targets_filename }}
          bash ./compile.sh gha-matrix jethome-images \
          REVISION="${{ needs.version_prep.outputs.version }}" \
          TARGETS_FILTER_INCLUDE="${FILTERS}" \
          BETA=${{ github.event.inputs.nightlybuild || 'no' }} \
          CLEAN_INFO=yes \
          CLEAN_MATRIX=yes \
          MATRIX_ARTIFACT_CHUNKS=17 \
          MATRIX_IMAGE_CHUNKS=16 \
          CHECK_OCI=${{ github.event.inputs.checkOci || 'no' }} \
          TARGETS_FILENAME="targets-stable.yaml" \
          SKIP_IMAGES=${{ github.event.inputs.skipImages || 'no'}} \
          ${{env.EXTRA_PARAMS_ALL_BUILDS}} SHARE_LOG=yes # IMAGES_ONLY_OUTDATED_ARTIFACTS=yes

      - name: "Logs: ${{ steps.prepare-matrix.outputs.logs_url }}"
        if: always()
        run: |
          echo "Logs: ${{ steps.prepare-matrix.outputs.logs_url }}"

      # Store output/info folder in a GitHub Actions artifact
      - uses: actions/upload-artifact@v4
        name: Upload output/info as GitHub Artifact
        with:
          name: build-info-json
          path: build/output/info

      - name: chown cache memoize/oci back to normal user
        run: sudo chown -R $USER:$USER build/cache/memoize build/cache/oci/positive

    outputs:

      # not related to matrix
      build-sha1: ${{ steps.latest-commit.outputs.sha1 }}
      version: ${{ needs.version_prep.outputs.version }}

# template file: 150.per-chunk-artifacts_prep-outputs.yaml

      # artifacts-1 of 17
      artifacts-chunk-json-1: ${{ steps.prepare-matrix.outputs.artifacts-chunk-json-1 }}
      artifacts-chunk-not-empty-1: ${{ steps.prepare-matrix.outputs.artifacts-chunk-not-empty-1 }}
      artifacts-chunk-size-1: ${{ steps.prepare-matrix.outputs.artifacts-chunk-size-1 }}
      # artifacts-2 of 17
      artifacts-chunk-json-2: ${{ steps.prepare-matrix.outputs.artifacts-chunk-json-2 }}
      artifacts-chunk-not-empty-2: ${{ steps.prepare-matrix.outputs.artifacts-chunk-not-empty-2 }}
      artifacts-chunk-size-2: ${{ steps.prepare-matrix.outputs.artifacts-chunk-size-2 }}
      # artifacts-3 of 17
      artifacts-chunk-json-3: ${{ steps.prepare-matrix.outputs.artifacts-chunk-json-3 }}
      artifacts-chunk-not-empty-3: ${{ steps.prepare-matrix.outputs.artifacts-chunk-not-empty-3 }}
      artifacts-chunk-size-3: ${{ steps.prepare-matrix.outputs.artifacts-chunk-size-3 }}
      # artifacts-4 of 17
      artifacts-chunk-json-4: ${{ steps.prepare-matrix.outputs.artifacts-chunk-json-4 }}
      artifacts-chunk-not-empty-4: ${{ steps.prepare-matrix.outputs.artifacts-chunk-not-empty-4 }}
      artifacts-chunk-size-4: ${{ steps.prepare-matrix.outputs.artifacts-chunk-size-4 }}
      # artifacts-5 of 17
      artifacts-chunk-json-5: ${{ steps.prepare-matrix.outputs.artifacts-chunk-json-5 }}
      artifacts-chunk-not-empty-5: ${{ steps.prepare-matrix.outputs.artifacts-chunk-not-empty-5 }}
      artifacts-chunk-size-5: ${{ steps.prepare-matrix.outputs.artifacts-chunk-size-5 }}
      # artifacts-6 of 17
      artifacts-chunk-json-6: ${{ steps.prepare-matrix.outputs.artifacts-chunk-json-6 }}
      artifacts-chunk-not-empty-6: ${{ steps.prepare-matrix.outputs.artifacts-chunk-not-empty-6 }}
      artifacts-chunk-size-6: ${{ steps.prepare-matrix.outputs.artifacts-chunk-size-6 }}
      # artifacts-7 of 17
      artifacts-chunk-json-7: ${{ steps.prepare-matrix.outputs.artifacts-chunk-json-7 }}
      artifacts-chunk-not-empty-7: ${{ steps.prepare-matrix.outputs.artifacts-chunk-not-empty-7 }}
      artifacts-chunk-size-7: ${{ steps.prepare-matrix.outputs.artifacts-chunk-size-7 }}
      # artifacts-8 of 17
      artifacts-chunk-json-8: ${{ steps.prepare-matrix.outputs.artifacts-chunk-json-8 }}
      artifacts-chunk-not-empty-8: ${{ steps.prepare-matrix.outputs.artifacts-chunk-not-empty-8 }}
      artifacts-chunk-size-8: ${{ steps.prepare-matrix.outputs.artifacts-chunk-size-8 }}
      # artifacts-9 of 17
      artifacts-chunk-json-9: ${{ steps.prepare-matrix.outputs.artifacts-chunk-json-9 }}
      artifacts-chunk-not-empty-9: ${{ steps.prepare-matrix.outputs.artifacts-chunk-not-empty-9 }}
      artifacts-chunk-size-9: ${{ steps.prepare-matrix.outputs.artifacts-chunk-size-9 }}
      # artifacts-10 of 17
      artifacts-chunk-json-10: ${{ steps.prepare-matrix.outputs.artifacts-chunk-json-10 }}
      artifacts-chunk-not-empty-10: ${{ steps.prepare-matrix.outputs.artifacts-chunk-not-empty-10 }}
      artifacts-chunk-size-10: ${{ steps.prepare-matrix.outputs.artifacts-chunk-size-10 }}
      # artifacts-11 of 17
      artifacts-chunk-json-11: ${{ steps.prepare-matrix.outputs.artifacts-chunk-json-11 }}
      artifacts-chunk-not-empty-11: ${{ steps.prepare-matrix.outputs.artifacts-chunk-not-empty-11 }}
      artifacts-chunk-size-11: ${{ steps.prepare-matrix.outputs.artifacts-chunk-size-11 }}
      # artifacts-12 of 17
      artifacts-chunk-json-12: ${{ steps.prepare-matrix.outputs.artifacts-chunk-json-12 }}
      artifacts-chunk-not-empty-12: ${{ steps.prepare-matrix.outputs.artifacts-chunk-not-empty-12 }}
      artifacts-chunk-size-12: ${{ steps.prepare-matrix.outputs.artifacts-chunk-size-12 }}
      # artifacts-13 of 17
      artifacts-chunk-json-13: ${{ steps.prepare-matrix.outputs.artifacts-chunk-json-13 }}
      artifacts-chunk-not-empty-13: ${{ steps.prepare-matrix.outputs.artifacts-chunk-not-empty-13 }}
      artifacts-chunk-size-13: ${{ steps.prepare-matrix.outputs.artifacts-chunk-size-13 }}
      # artifacts-14 of 17
      artifacts-chunk-json-14: ${{ steps.prepare-matrix.outputs.artifacts-chunk-json-14 }}
      artifacts-chunk-not-empty-14: ${{ steps.prepare-matrix.outputs.artifacts-chunk-not-empty-14 }}
      artifacts-chunk-size-14: ${{ steps.prepare-matrix.outputs.artifacts-chunk-size-14 }}
      # artifacts-15 of 17
      artifacts-chunk-json-15: ${{ steps.prepare-matrix.outputs.artifacts-chunk-json-15 }}
      artifacts-chunk-not-empty-15: ${{ steps.prepare-matrix.outputs.artifacts-chunk-not-empty-15 }}
      artifacts-chunk-size-15: ${{ steps.prepare-matrix.outputs.artifacts-chunk-size-15 }}
      # artifacts-16 of 17
      artifacts-chunk-json-16: ${{ steps.prepare-matrix.outputs.artifacts-chunk-json-16 }}
      artifacts-chunk-not-empty-16: ${{ steps.prepare-matrix.outputs.artifacts-chunk-not-empty-16 }}
      artifacts-chunk-size-16: ${{ steps.prepare-matrix.outputs.artifacts-chunk-size-16 }}
      # artifacts-17 of 17
      artifacts-chunk-json-17: ${{ steps.prepare-matrix.outputs.artifacts-chunk-json-17 }}
      artifacts-chunk-not-empty-17: ${{ steps.prepare-matrix.outputs.artifacts-chunk-not-empty-17 }}
      artifacts-chunk-size-17: ${{ steps.prepare-matrix.outputs.artifacts-chunk-size-17 }}

# template file: 151.per-chunk-images_prep-outputs.yaml

      # artifacts-1 of 16
      images-chunk-json-1: ${{ steps.prepare-matrix.outputs.images-chunk-json-1 }}
      images-chunk-not-empty-1: ${{ steps.prepare-matrix.outputs.images-chunk-not-empty-1 }}
      images-chunk-size-1: ${{ steps.prepare-matrix.outputs.images-chunk-size-1 }}
      # artifacts-2 of 16
      images-chunk-json-2: ${{ steps.prepare-matrix.outputs.images-chunk-json-2 }}
      images-chunk-not-empty-2: ${{ steps.prepare-matrix.outputs.images-chunk-not-empty-2 }}
      images-chunk-size-2: ${{ steps.prepare-matrix.outputs.images-chunk-size-2 }}
      # artifacts-3 of 16
      images-chunk-json-3: ${{ steps.prepare-matrix.outputs.images-chunk-json-3 }}
      images-chunk-not-empty-3: ${{ steps.prepare-matrix.outputs.images-chunk-not-empty-3 }}
      images-chunk-size-3: ${{ steps.prepare-matrix.outputs.images-chunk-size-3 }}
      # artifacts-4 of 16
      images-chunk-json-4: ${{ steps.prepare-matrix.outputs.images-chunk-json-4 }}
      images-chunk-not-empty-4: ${{ steps.prepare-matrix.outputs.images-chunk-not-empty-4 }}
      images-chunk-size-4: ${{ steps.prepare-matrix.outputs.images-chunk-size-4 }}
      # artifacts-5 of 16
      images-chunk-json-5: ${{ steps.prepare-matrix.outputs.images-chunk-json-5 }}
      images-chunk-not-empty-5: ${{ steps.prepare-matrix.outputs.images-chunk-not-empty-5 }}
      images-chunk-size-5: ${{ steps.prepare-matrix.outputs.images-chunk-size-5 }}
      # artifacts-6 of 16
      images-chunk-json-6: ${{ steps.prepare-matrix.outputs.images-chunk-json-6 }}
      images-chunk-not-empty-6: ${{ steps.prepare-matrix.outputs.images-chunk-not-empty-6 }}
      images-chunk-size-6: ${{ steps.prepare-matrix.outputs.images-chunk-size-6 }}
      # artifacts-7 of 16
      images-chunk-json-7: ${{ steps.prepare-matrix.outputs.images-chunk-json-7 }}
      images-chunk-not-empty-7: ${{ steps.prepare-matrix.outputs.images-chunk-not-empty-7 }}
      images-chunk-size-7: ${{ steps.prepare-matrix.outputs.images-chunk-size-7 }}
      # artifacts-8 of 16
      images-chunk-json-8: ${{ steps.prepare-matrix.outputs.images-chunk-json-8 }}
      images-chunk-not-empty-8: ${{ steps.prepare-matrix.outputs.images-chunk-not-empty-8 }}
      images-chunk-size-8: ${{ steps.prepare-matrix.outputs.images-chunk-size-8 }}
      # artifacts-9 of 16
      images-chunk-json-9: ${{ steps.prepare-matrix.outputs.images-chunk-json-9 }}
      images-chunk-not-empty-9: ${{ steps.prepare-matrix.outputs.images-chunk-not-empty-9 }}
      images-chunk-size-9: ${{ steps.prepare-matrix.outputs.images-chunk-size-9 }}
      # artifacts-10 of 16
      images-chunk-json-10: ${{ steps.prepare-matrix.outputs.images-chunk-json-10 }}
      images-chunk-not-empty-10: ${{ steps.prepare-matrix.outputs.images-chunk-not-empty-10 }}
      images-chunk-size-10: ${{ steps.prepare-matrix.outputs.images-chunk-size-10 }}
      # artifacts-11 of 16
      images-chunk-json-11: ${{ steps.prepare-matrix.outputs.images-chunk-json-11 }}
      images-chunk-not-empty-11: ${{ steps.prepare-matrix.outputs.images-chunk-not-empty-11 }}
      images-chunk-size-11: ${{ steps.prepare-matrix.outputs.images-chunk-size-11 }}
      # artifacts-12 of 16
      images-chunk-json-12: ${{ steps.prepare-matrix.outputs.images-chunk-json-12 }}
      images-chunk-not-empty-12: ${{ steps.prepare-matrix.outputs.images-chunk-not-empty-12 }}
      images-chunk-size-12: ${{ steps.prepare-matrix.outputs.images-chunk-size-12 }}
      # artifacts-13 of 16
      images-chunk-json-13: ${{ steps.prepare-matrix.outputs.images-chunk-json-13 }}
      images-chunk-not-empty-13: ${{ steps.prepare-matrix.outputs.images-chunk-not-empty-13 }}
      images-chunk-size-13: ${{ steps.prepare-matrix.outputs.images-chunk-size-13 }}
      # artifacts-14 of 16
      images-chunk-json-14: ${{ steps.prepare-matrix.outputs.images-chunk-json-14 }}
      images-chunk-not-empty-14: ${{ steps.prepare-matrix.outputs.images-chunk-not-empty-14 }}
      images-chunk-size-14: ${{ steps.prepare-matrix.outputs.images-chunk-size-14 }}
      # artifacts-15 of 16
      images-chunk-json-15: ${{ steps.prepare-matrix.outputs.images-chunk-json-15 }}
      images-chunk-not-empty-15: ${{ steps.prepare-matrix.outputs.images-chunk-not-empty-15 }}
      images-chunk-size-15: ${{ steps.prepare-matrix.outputs.images-chunk-size-15 }}
      # artifacts-16 of 16
      images-chunk-json-16: ${{ steps.prepare-matrix.outputs.images-chunk-json-16 }}
      images-chunk-not-empty-16: ${{ steps.prepare-matrix.outputs.images-chunk-not-empty-16 }}
      images-chunk-size-16: ${{ steps.prepare-matrix.outputs.images-chunk-size-16 }}

# template file: 250.single_aggr-jobs.yaml

  # ------ aggregate all artifact chunks into a single dependency -------

  all-artifacts-ready:
    name: "17 artifacts chunks ready"
    runs-on: ubuntu-latest # not going to run, anyway, but is required.
    if: ${{ !cancelled() && ( 1 == 2 ) }} # eg: never run.
    needs: [ "matrix_prep", "build-artifacts-chunk-1","build-artifacts-chunk-2","build-artifacts-chunk-3","build-artifacts-chunk-4","build-artifacts-chunk-5","build-artifacts-chunk-6","build-artifacts-chunk-7","build-artifacts-chunk-8","build-artifacts-chunk-9","build-artifacts-chunk-10","build-artifacts-chunk-11","build-artifacts-chunk-12","build-artifacts-chunk-13","build-artifacts-chunk-14","build-artifacts-chunk-15","build-artifacts-chunk-16","build-artifacts-chunk-17" ] # <-- HERE: all artifact chunk numbers.
    steps:
      - name: fake step
        run: uptime

  all-images-ready:
    name: "16 image chunks ready"
    runs-on: ubuntu-latest # not going to run, anyway, but is required.
    if: ${{ !cancelled() && ( 1 == 2 ) }} # eg: never run.
    needs: [ "matrix_prep", "build-images-chunk-1","build-images-chunk-2","build-images-chunk-3","build-images-chunk-4","build-images-chunk-5","build-images-chunk-6","build-images-chunk-7","build-images-chunk-8","build-images-chunk-9","build-images-chunk-10","build-images-chunk-11","build-images-chunk-12","build-images-chunk-13","build-images-chunk-14","build-images-chunk-15","build-images-chunk-16" ] # <-- HERE: all image chunk numbers.
    steps:
      - name: fake step
        run: uptime

  all-artifacts-and-images-ready:
    name: "17 artifacts and 16 image chunks ready"
    runs-on: ubuntu-latest # not going to run, anyway, but is required.
    if: ${{ !cancelled() && ( 1 == 2 ) }} # eg: never run.
    needs: [ "matrix_prep", "all-artifacts-ready", "all-images-ready" ]
    steps:
      - name: fake step
        run: uptime

# template file: 550.per-chunk-artifacts_job.yaml

  "build-artifacts-chunk-1": # templated "build-artifacts-chunk-1"
    if: ${{ github.repository_owner == 'jethome-iot' && needs.matrix_prep.outputs.artifacts-chunk-not-empty-1 == 'yes' }}  # <-- HERE: Chunk number.
    needs: [ "matrix_prep" ]
    strategy:
      fail-fast: false # let other jobs try to complete if one fails
      matrix: ${{ fromJSON(needs.matrix_prep.outputs.artifacts-chunk-json-1) }} # <-- HERE: Chunk number.
    name: ${{ matrix.desc || 'Empty A1' }} # <-- HERE: Chunk number.
    runs-on: ${{ matrix.runs_on }}
    steps:

      #- name: "Runner clean ${{ needs.matrix_prep.outputs.version }}"
      #  uses: armbian/actions/runner-clean@main

      # Login to ghcr.io, for later uploading rootfs to ghcr.io
      - name: Docker Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: "${{ github.repository_owner }}" # GitHub username or org
          password: "${{ secrets.GITHUB_TOKEN }}"    # GitHub actions builtin token. repo has to have pkg access.

      - name: Docker Login to CR
        env:
          CR_REGISTRY: ${{ secrets.CR_REGISTRY }}
        if: env.CR_REGISTRY != null
        uses: docker/login-action@v3
        with:
          registry: ${{ secrets.CR_REGISTRY }}
          username: ${{ secrets.CR_USERNAME }}
          password: ${{ secrets.CR_PAT }}

      # cleanup the place where we will clone the userpatches repo, to avoid git going insane and cleaning everything later
      - name: Cleanup userpatches repo
        if: ${{ ( env.USERPATCHES_REPOSITORY != '' ) && ( env.USERPATCHES_REF != '' ) }}
        run: sudo rm -rf userpatches.repo

      - name: Checkout build repo
        uses: actions/checkout@v4 # We don't need to clone git, really. A wget would suffice for GH-hosted runners. But using clone is better for Igor-hosted runners.
        with:
          repository: ${{ env.BUILD_REPOSITORY }}
          ref: ${{ needs.matrix_prep.outputs.build-sha1 }}
          fetch-depth: ${{ matrix.fdepth }}
          clean: false # true is default. it *will* delete the hosts /dev if mounted inside.

      # clone the userpatches repo (`armbian/os`)
      - name: "Checkout userpatches repo: ${{env.USERPATCHES_REPOSITORY}}#${{env.USERPATCHES_REF}}"
        uses: actions/checkout@v4
        if: ${{ ( env.USERPATCHES_REPOSITORY != '' ) && ( env.USERPATCHES_REF != '' ) }}
        with:
          repository: ${{ env.USERPATCHES_REPOSITORY }}
          ref: ${{ env.USERPATCHES_REF }}
          fetch-depth: ${{ matrix.fdepth }}
          clean: false # true is default.
          path: userpatches.repo

      - name: "Put userpatches in place, and remove userpatches repo"
        if: ${{ ( env.USERPATCHES_REPOSITORY != '' ) && ( env.USERPATCHES_REF != '' ) }}
        run: |
          mkdir -pv userpatches
          rsync -av userpatches.repo/${{env.USERPATCHES_DIR}}/. userpatches/
          sudo rm -rf userpatches.repo
          echo ${{ needs.matrix_prep.outputs.version }} > userpatches/VERSION


      - name: Build  ${{matrix.desc}}
        timeout-minutes: 300
        id: build
        run: |
          bash ./compile.sh ${{ matrix.invocation }} REVISION="${{ needs.matrix_prep.outputs.version }}" SHOW_DEBUG=yes SHARE_LOG=yes ${{env.EXTRA_PARAMS_ALL_BUILDS}}

      - name: "Logs: ${{ steps.build.outputs.logs_url }}"
        if: always()
        run: |
          echo "Logs: ${{ steps.build.outputs.logs_url }}"
  "build-artifacts-chunk-2": # templated "build-artifacts-chunk-2"
    if: ${{ github.repository_owner == 'jethome-iot' && needs.matrix_prep.outputs.artifacts-chunk-not-empty-2 == 'yes' }}  # <-- HERE: Chunk number.
    needs: [ "matrix_prep" ]
    strategy:
      fail-fast: false # let other jobs try to complete if one fails
      matrix: ${{ fromJSON(needs.matrix_prep.outputs.artifacts-chunk-json-2) }} # <-- HERE: Chunk number.
    name: ${{ matrix.desc || 'Empty A2' }} # <-- HERE: Chunk number.
    runs-on: ${{ matrix.runs_on }}
    steps:

      #- name: "Runner clean ${{ needs.matrix_prep.outputs.version }}"
      #  uses: armbian/actions/runner-clean@main

      # Login to ghcr.io, for later uploading rootfs to ghcr.io
      - name: Docker Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: "${{ github.repository_owner }}" # GitHub username or org
          password: "${{ secrets.GITHUB_TOKEN }}"    # GitHub actions builtin token. repo has to have pkg access.

      - name: Docker Login to CR
        env:
          CR_REGISTRY: ${{ secrets.CR_REGISTRY }}
        if: env.CR_REGISTRY != null
        uses: docker/login-action@v3
        with:
          registry: ${{ secrets.CR_REGISTRY }}
          username: ${{ secrets.CR_USERNAME }}
          password: ${{ secrets.CR_PAT }}

      # cleanup the place where we will clone the userpatches repo, to avoid git going insane and cleaning everything later
      - name: Cleanup userpatches repo
        if: ${{ ( env.USERPATCHES_REPOSITORY != '' ) && ( env.USERPATCHES_REF != '' ) }}
        run: sudo rm -rf userpatches.repo

      - name: Checkout build repo
        uses: actions/checkout@v4 # We don't need to clone git, really. A wget would suffice for GH-hosted runners. But using clone is better for Igor-hosted runners.
        with:
          repository: ${{ env.BUILD_REPOSITORY }}
          ref: ${{ needs.matrix_prep.outputs.build-sha1 }}
          fetch-depth: ${{ matrix.fdepth }}
          clean: false # true is default. it *will* delete the hosts /dev if mounted inside.

      # clone the userpatches repo (`armbian/os`)
      - name: "Checkout userpatches repo: ${{env.USERPATCHES_REPOSITORY}}#${{env.USERPATCHES_REF}}"
        uses: actions/checkout@v4
        if: ${{ ( env.USERPATCHES_REPOSITORY != '' ) && ( env.USERPATCHES_REF != '' ) }}
        with:
          repository: ${{ env.USERPATCHES_REPOSITORY }}
          ref: ${{ env.USERPATCHES_REF }}
          fetch-depth: ${{ matrix.fdepth }}
          clean: false # true is default.
          path: userpatches.repo

      - name: "Put userpatches in place, and remove userpatches repo"
        if: ${{ ( env.USERPATCHES_REPOSITORY != '' ) && ( env.USERPATCHES_REF != '' ) }}
        run: |
          mkdir -pv userpatches
          rsync -av userpatches.repo/${{env.USERPATCHES_DIR}}/. userpatches/
          sudo rm -rf userpatches.repo
          echo ${{ needs.matrix_prep.outputs.version }} > userpatches/VERSION


      - name: Build  ${{matrix.desc}}
        timeout-minutes: 300
        id: build
        run: |
          bash ./compile.sh ${{ matrix.invocation }} REVISION="${{ needs.matrix_prep.outputs.version }}" SHOW_DEBUG=yes SHARE_LOG=yes ${{env.EXTRA_PARAMS_ALL_BUILDS}}

      - name: "Logs: ${{ steps.build.outputs.logs_url }}"
        if: always()
        run: |
          echo "Logs: ${{ steps.build.outputs.logs_url }}"
  "build-artifacts-chunk-3": # templated "build-artifacts-chunk-3"
    if: ${{ github.repository_owner == 'jethome-iot' && needs.matrix_prep.outputs.artifacts-chunk-not-empty-3 == 'yes' }}  # <-- HERE: Chunk number.
    needs: [ "matrix_prep" ]
    strategy:
      fail-fast: false # let other jobs try to complete if one fails
      matrix: ${{ fromJSON(needs.matrix_prep.outputs.artifacts-chunk-json-3) }} # <-- HERE: Chunk number.
    name: ${{ matrix.desc || 'Empty A3' }} # <-- HERE: Chunk number.
    runs-on: ${{ matrix.runs_on }}
    steps:

      #- name: "Runner clean ${{ needs.matrix_prep.outputs.version }}"
      #  uses: armbian/actions/runner-clean@main

      # Login to ghcr.io, for later uploading rootfs to ghcr.io
      - name: Docker Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: "${{ github.repository_owner }}" # GitHub username or org
          password: "${{ secrets.GITHUB_TOKEN }}"    # GitHub actions builtin token. repo has to have pkg access.

      - name: Docker Login to CR
        env:
          CR_REGISTRY: ${{ secrets.CR_REGISTRY }}
        if: env.CR_REGISTRY != null
        uses: docker/login-action@v3
        with:
          registry: ${{ secrets.CR_REGISTRY }}
          username: ${{ secrets.CR_USERNAME }}
          password: ${{ secrets.CR_PAT }}

      # cleanup the place where we will clone the userpatches repo, to avoid git going insane and cleaning everything later
      - name: Cleanup userpatches repo
        if: ${{ ( env.USERPATCHES_REPOSITORY != '' ) && ( env.USERPATCHES_REF != '' ) }}
        run: sudo rm -rf userpatches.repo

      - name: Checkout build repo
        uses: actions/checkout@v4 # We don't need to clone git, really. A wget would suffice for GH-hosted runners. But using clone is better for Igor-hosted runners.
        with:
          repository: ${{ env.BUILD_REPOSITORY }}
          ref: ${{ needs.matrix_prep.outputs.build-sha1 }}
          fetch-depth: ${{ matrix.fdepth }}
          clean: false # true is default. it *will* delete the hosts /dev if mounted inside.

      # clone the userpatches repo (`armbian/os`)
      - name: "Checkout userpatches repo: ${{env.USERPATCHES_REPOSITORY}}#${{env.USERPATCHES_REF}}"
        uses: actions/checkout@v4
        if: ${{ ( env.USERPATCHES_REPOSITORY != '' ) && ( env.USERPATCHES_REF != '' ) }}
        with:
          repository: ${{ env.USERPATCHES_REPOSITORY }}
          ref: ${{ env.USERPATCHES_REF }}
          fetch-depth: ${{ matrix.fdepth }}
          clean: false # true is default.
          path: userpatches.repo

      - name: "Put userpatches in place, and remove userpatches repo"
        if: ${{ ( env.USERPATCHES_REPOSITORY != '' ) && ( env.USERPATCHES_REF != '' ) }}
        run: |
          mkdir -pv userpatches
          rsync -av userpatches.repo/${{env.USERPATCHES_DIR}}/. userpatches/
          sudo rm -rf userpatches.repo
          echo ${{ needs.matrix_prep.outputs.version }} > userpatches/VERSION


      - name: Build  ${{matrix.desc}}
        timeout-minutes: 300
        id: build
        run: |
          bash ./compile.sh ${{ matrix.invocation }} REVISION="${{ needs.matrix_prep.outputs.version }}" SHOW_DEBUG=yes SHARE_LOG=yes ${{env.EXTRA_PARAMS_ALL_BUILDS}}

      - name: "Logs: ${{ steps.build.outputs.logs_url }}"
        if: always()
        run: |
          echo "Logs: ${{ steps.build.outputs.logs_url }}"
  "build-artifacts-chunk-4": # templated "build-artifacts-chunk-4"
    if: ${{ github.repository_owner == 'jethome-iot' && needs.matrix_prep.outputs.artifacts-chunk-not-empty-4 == 'yes' }}  # <-- HERE: Chunk number.
    needs: [ "matrix_prep" ]
    strategy:
      fail-fast: false # let other jobs try to complete if one fails
      matrix: ${{ fromJSON(needs.matrix_prep.outputs.artifacts-chunk-json-4) }} # <-- HERE: Chunk number.
    name: ${{ matrix.desc || 'Empty A4' }} # <-- HERE: Chunk number.
    runs-on: ${{ matrix.runs_on }}
    steps:

      #- name: "Runner clean ${{ needs.matrix_prep.outputs.version }}"
      #  uses: armbian/actions/runner-clean@main

      # Login to ghcr.io, for later uploading rootfs to ghcr.io
      - name: Docker Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: "${{ github.repository_owner }}" # GitHub username or org
          password: "${{ secrets.GITHUB_TOKEN }}"    # GitHub actions builtin token. repo has to have pkg access.

      - name: Docker Login to CR
        env:
          CR_REGISTRY: ${{ secrets.CR_REGISTRY }}
        if: env.CR_REGISTRY != null
        uses: docker/login-action@v3
        with:
          registry: ${{ secrets.CR_REGISTRY }}
          username: ${{ secrets.CR_USERNAME }}
          password: ${{ secrets.CR_PAT }}

      # cleanup the place where we will clone the userpatches repo, to avoid git going insane and cleaning everything later
      - name: Cleanup userpatches repo
        if: ${{ ( env.USERPATCHES_REPOSITORY != '' ) && ( env.USERPATCHES_REF != '' ) }}
        run: sudo rm -rf userpatches.repo

      - name: Checkout build repo
        uses: actions/checkout@v4 # We don't need to clone git, really. A wget would suffice for GH-hosted runners. But using clone is better for Igor-hosted runners.
        with:
          repository: ${{ env.BUILD_REPOSITORY }}
          ref: ${{ needs.matrix_prep.outputs.build-sha1 }}
          fetch-depth: ${{ matrix.fdepth }}
          clean: false # true is default. it *will* delete the hosts /dev if mounted inside.

      # clone the userpatches repo (`armbian/os`)
      - name: "Checkout userpatches repo: ${{env.USERPATCHES_REPOSITORY}}#${{env.USERPATCHES_REF}}"
        uses: actions/checkout@v4
        if: ${{ ( env.USERPATCHES_REPOSITORY != '' ) && ( env.USERPATCHES_REF != '' ) }}
        with:
          repository: ${{ env.USERPATCHES_REPOSITORY }}
          ref: ${{ env.USERPATCHES_REF }}
          fetch-depth: ${{ matrix.fdepth }}
          clean: false # true is default.
          path: userpatches.repo

      - name: "Put userpatches in place, and remove userpatches repo"
        if: ${{ ( env.USERPATCHES_REPOSITORY != '' ) && ( env.USERPATCHES_REF != '' ) }}
        run: |
          mkdir -pv userpatches
          rsync -av userpatches.repo/${{env.USERPATCHES_DIR}}/. userpatches/
          sudo rm -rf userpatches.repo
          echo ${{ needs.matrix_prep.outputs.version }} > userpatches/VERSION


      - name: Build  ${{matrix.desc}}
        timeout-minutes: 300
        id: build
        run: |
          bash ./compile.sh ${{ matrix.invocation }} REVISION="${{ needs.matrix_prep.outputs.version }}" SHOW_DEBUG=yes SHARE_LOG=yes ${{env.EXTRA_PARAMS_ALL_BUILDS}}

      - name: "Logs: ${{ steps.build.outputs.logs_url }}"
        if: always()
        run: |
          echo "Logs: ${{ steps.build.outputs.logs_url }}"
  "build-artifacts-chunk-5": # templated "build-artifacts-chunk-5"
    if: ${{ github.repository_owner == 'jethome-iot' && needs.matrix_prep.outputs.artifacts-chunk-not-empty-5 == 'yes' }}  # <-- HERE: Chunk number.
    needs: [ "matrix_prep" ]
    strategy:
      fail-fast: false # let other jobs try to complete if one fails
      matrix: ${{ fromJSON(needs.matrix_prep.outputs.artifacts-chunk-json-5) }} # <-- HERE: Chunk number.
    name: ${{ matrix.desc || 'Empty A5' }} # <-- HERE: Chunk number.
    runs-on: ${{ matrix.runs_on }}
    steps:

      #- name: "Runner clean ${{ needs.matrix_prep.outputs.version }}"
      #  uses: armbian/actions/runner-clean@main

      # Login to ghcr.io, for later uploading rootfs to ghcr.io
      - name: Docker Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: "${{ github.repository_owner }}" # GitHub username or org
          password: "${{ secrets.GITHUB_TOKEN }}"    # GitHub actions builtin token. repo has to have pkg access.

      - name: Docker Login to CR
        env:
          CR_REGISTRY: ${{ secrets.CR_REGISTRY }}
        if: env.CR_REGISTRY != null
        uses: docker/login-action@v3
        with:
          registry: ${{ secrets.CR_REGISTRY }}
          username: ${{ secrets.CR_USERNAME }}
          password: ${{ secrets.CR_PAT }}

      # cleanup the place where we will clone the userpatches repo, to avoid git going insane and cleaning everything later
      - name: Cleanup userpatches repo
        if: ${{ ( env.USERPATCHES_REPOSITORY != '' ) && ( env.USERPATCHES_REF != '' ) }}
        run: sudo rm -rf userpatches.repo

      - name: Checkout build repo
        uses: actions/checkout@v4 # We don't need to clone git, really. A wget would suffice for GH-hosted runners. But using clone is better for Igor-hosted runners.
        with:
          repository: ${{ env.BUILD_REPOSITORY }}
          ref: ${{ needs.matrix_prep.outputs.build-sha1 }}
          fetch-depth: ${{ matrix.fdepth }}
          clean: false # true is default. it *will* delete the hosts /dev if mounted inside.

      # clone the userpatches repo (`armbian/os`)
      - name: "Checkout userpatches repo: ${{env.USERPATCHES_REPOSITORY}}#${{env.USERPATCHES_REF}}"
        uses: actions/checkout@v4
        if: ${{ ( env.USERPATCHES_REPOSITORY != '' ) && ( env.USERPATCHES_REF != '' ) }}
        with:
          repository: ${{ env.USERPATCHES_REPOSITORY }}
          ref: ${{ env.USERPATCHES_REF }}
          fetch-depth: ${{ matrix.fdepth }}
          clean: false # true is default.
          path: userpatches.repo

      - name: "Put userpatches in place, and remove userpatches repo"
        if: ${{ ( env.USERPATCHES_REPOSITORY != '' ) && ( env.USERPATCHES_REF != '' ) }}
        run: |
          mkdir -pv userpatches
          rsync -av userpatches.repo/${{env.USERPATCHES_DIR}}/. userpatches/
          sudo rm -rf userpatches.repo
          echo ${{ needs.matrix_prep.outputs.version }} > userpatches/VERSION


      - name: Build  ${{matrix.desc}}
        timeout-minutes: 300
        id: build
        run: |
          bash ./compile.sh ${{ matrix.invocation }} REVISION="${{ needs.matrix_prep.outputs.version }}" SHOW_DEBUG=yes SHARE_LOG=yes ${{env.EXTRA_PARAMS_ALL_BUILDS}}

      - name: "Logs: ${{ steps.build.outputs.logs_url }}"
        if: always()
        run: |
          echo "Logs: ${{ steps.build.outputs.logs_url }}"
  "build-artifacts-chunk-6": # templated "build-artifacts-chunk-6"
    if: ${{ github.repository_owner == 'jethome-iot' && needs.matrix_prep.outputs.artifacts-chunk-not-empty-6 == 'yes' }}  # <-- HERE: Chunk number.
    needs: [ "matrix_prep" ]
    strategy:
      fail-fast: false # let other jobs try to complete if one fails
      matrix: ${{ fromJSON(needs.matrix_prep.outputs.artifacts-chunk-json-6) }} # <-- HERE: Chunk number.
    name: ${{ matrix.desc || 'Empty A6' }} # <-- HERE: Chunk number.
    runs-on: ${{ matrix.runs_on }}
    steps:

      #- name: "Runner clean ${{ needs.matrix_prep.outputs.version }}"
      #  uses: armbian/actions/runner-clean@main

      # Login to ghcr.io, for later uploading rootfs to ghcr.io
      - name: Docker Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: "${{ github.repository_owner }}" # GitHub username or org
          password: "${{ secrets.GITHUB_TOKEN }}"    # GitHub actions builtin token. repo has to have pkg access.

      - name: Docker Login to CR
        env:
          CR_REGISTRY: ${{ secrets.CR_REGISTRY }}
        if: env.CR_REGISTRY != null
        uses: docker/login-action@v3
        with:
          registry: ${{ secrets.CR_REGISTRY }}
          username: ${{ secrets.CR_USERNAME }}
          password: ${{ secrets.CR_PAT }}

      # cleanup the place where we will clone the userpatches repo, to avoid git going insane and cleaning everything later
      - name: Cleanup userpatches repo
        if: ${{ ( env.USERPATCHES_REPOSITORY != '' ) && ( env.USERPATCHES_REF != '' ) }}
        run: sudo rm -rf userpatches.repo

      - name: Checkout build repo
        uses: actions/checkout@v4 # We don't need to clone git, really. A wget would suffice for GH-hosted runners. But using clone is better for Igor-hosted runners.
        with:
          repository: ${{ env.BUILD_REPOSITORY }}
          ref: ${{ needs.matrix_prep.outputs.build-sha1 }}
          fetch-depth: ${{ matrix.fdepth }}
          clean: false # true is default. it *will* delete the hosts /dev if mounted inside.

      # clone the userpatches repo (`armbian/os`)
      - name: "Checkout userpatches repo: ${{env.USERPATCHES_REPOSITORY}}#${{env.USERPATCHES_REF}}"
        uses: actions/checkout@v4
        if: ${{ ( env.USERPATCHES_REPOSITORY != '' ) && ( env.USERPATCHES_REF != '' ) }}
        with:
          repository: ${{ env.USERPATCHES_REPOSITORY }}
          ref: ${{ env.USERPATCHES_REF }}
          fetch-depth: ${{ matrix.fdepth }}
          clean: false # true is default.
          path: userpatches.repo

      - name: "Put userpatches in place, and remove userpatches repo"
        if: ${{ ( env.USERPATCHES_REPOSITORY != '' ) && ( env.USERPATCHES_REF != '' ) }}
        run: |
          mkdir -pv userpatches
          rsync -av userpatches.repo/${{env.USERPATCHES_DIR}}/. userpatches/
          sudo rm -rf userpatches.repo
          echo ${{ needs.matrix_prep.outputs.version }} > userpatches/VERSION


      - name: Build  ${{matrix.desc}}
        timeout-minutes: 300
        id: build
        run: |
          bash ./compile.sh ${{ matrix.invocation }} REVISION="${{ needs.matrix_prep.outputs.version }}" SHOW_DEBUG=yes SHARE_LOG=yes ${{env.EXTRA_PARAMS_ALL_BUILDS}}

      - name: "Logs: ${{ steps.build.outputs.logs_url }}"
        if: always()
        run: |
          echo "Logs: ${{ steps.build.outputs.logs_url }}"
  "build-artifacts-chunk-7": # templated "build-artifacts-chunk-7"
    if: ${{ github.repository_owner == 'jethome-iot' && needs.matrix_prep.outputs.artifacts-chunk-not-empty-7 == 'yes' }}  # <-- HERE: Chunk number.
    needs: [ "matrix_prep" ]
    strategy:
      fail-fast: false # let other jobs try to complete if one fails
      matrix: ${{ fromJSON(needs.matrix_prep.outputs.artifacts-chunk-json-7) }} # <-- HERE: Chunk number.
    name: ${{ matrix.desc || 'Empty A7' }} # <-- HERE: Chunk number.
    runs-on: ${{ matrix.runs_on }}
    steps:

      #- name: "Runner clean ${{ needs.matrix_prep.outputs.version }}"
      #  uses: armbian/actions/runner-clean@main

      # Login to ghcr.io, for later uploading rootfs to ghcr.io
      - name: Docker Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: "${{ github.repository_owner }}" # GitHub username or org
          password: "${{ secrets.GITHUB_TOKEN }}"    # GitHub actions builtin token. repo has to have pkg access.

      - name: Docker Login to CR
        env:
          CR_REGISTRY: ${{ secrets.CR_REGISTRY }}
        if: env.CR_REGISTRY != null
        uses: docker/login-action@v3
        with:
          registry: ${{ secrets.CR_REGISTRY }}
          username: ${{ secrets.CR_USERNAME }}
          password: ${{ secrets.CR_PAT }}

      # cleanup the place where we will clone the userpatches repo, to avoid git going insane and cleaning everything later
      - name: Cleanup userpatches repo
        if: ${{ ( env.USERPATCHES_REPOSITORY != '' ) && ( env.USERPATCHES_REF != '' ) }}
        run: sudo rm -rf userpatches.repo

      - name: Checkout build repo
        uses: actions/checkout@v4 # We don't need to clone git, really. A wget would suffice for GH-hosted runners. But using clone is better for Igor-hosted runners.
        with:
          repository: ${{ env.BUILD_REPOSITORY }}
          ref: ${{ needs.matrix_prep.outputs.build-sha1 }}
          fetch-depth: ${{ matrix.fdepth }}
          clean: false # true is default. it *will* delete the hosts /dev if mounted inside.

      # clone the userpatches repo (`armbian/os`)
      - name: "Checkout userpatches repo: ${{env.USERPATCHES_REPOSITORY}}#${{env.USERPATCHES_REF}}"
        uses: actions/checkout@v4
        if: ${{ ( env.USERPATCHES_REPOSITORY != '' ) && ( env.USERPATCHES_REF != '' ) }}
        with:
          repository: ${{ env.USERPATCHES_REPOSITORY }}
          ref: ${{ env.USERPATCHES_REF }}
          fetch-depth: ${{ matrix.fdepth }}
          clean: false # true is default.
          path: userpatches.repo

      - name: "Put userpatches in place, and remove userpatches repo"
        if: ${{ ( env.USERPATCHES_REPOSITORY != '' ) && ( env.USERPATCHES_REF != '' ) }}
        run: |
          mkdir -pv userpatches
          rsync -av userpatches.repo/${{env.USERPATCHES_DIR}}/. userpatches/
          sudo rm -rf userpatches.repo
          echo ${{ needs.matrix_prep.outputs.version }} > userpatches/VERSION


      - name: Build  ${{matrix.desc}}
        timeout-minutes: 300
        id: build
        run: |
          bash ./compile.sh ${{ matrix.invocation }} REVISION="${{ needs.matrix_prep.outputs.version }}" SHOW_DEBUG=yes SHARE_LOG=yes ${{env.EXTRA_PARAMS_ALL_BUILDS}}

      - name: "Logs: ${{ steps.build.outputs.logs_url }}"
        if: always()
        run: |
          echo "Logs: ${{ steps.build.outputs.logs_url }}"
  "build-artifacts-chunk-8": # templated "build-artifacts-chunk-8"
    if: ${{ github.repository_owner == 'jethome-iot' && needs.matrix_prep.outputs.artifacts-chunk-not-empty-8 == 'yes' }}  # <-- HERE: Chunk number.
    needs: [ "matrix_prep" ]
    strategy:
      fail-fast: false # let other jobs try to complete if one fails
      matrix: ${{ fromJSON(needs.matrix_prep.outputs.artifacts-chunk-json-8) }} # <-- HERE: Chunk number.
    name: ${{ matrix.desc || 'Empty A8' }} # <-- HERE: Chunk number.
    runs-on: ${{ matrix.runs_on }}
    steps:

      #- name: "Runner clean ${{ needs.matrix_prep.outputs.version }}"
      #  uses: armbian/actions/runner-clean@main

      # Login to ghcr.io, for later uploading rootfs to ghcr.io
      - name: Docker Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: "${{ github.repository_owner }}" # GitHub username or org
          password: "${{ secrets.GITHUB_TOKEN }}"    # GitHub actions builtin token. repo has to have pkg access.

      - name: Docker Login to CR
        env:
          CR_REGISTRY: ${{ secrets.CR_REGISTRY }}
        if: env.CR_REGISTRY != null
        uses: docker/login-action@v3
        with:
          registry: ${{ secrets.CR_REGISTRY }}
          username: ${{ secrets.CR_USERNAME }}
          password: ${{ secrets.CR_PAT }}

      # cleanup the place where we will clone the userpatches repo, to avoid git going insane and cleaning everything later
      - name: Cleanup userpatches repo
        if: ${{ ( env.USERPATCHES_REPOSITORY != '' ) && ( env.USERPATCHES_REF != '' ) }}
        run: sudo rm -rf userpatches.repo

      - name: Checkout build repo
        uses: actions/checkout@v4 # We don't need to clone git, really. A wget would suffice for GH-hosted runners. But using clone is better for Igor-hosted runners.
        with:
          repository: ${{ env.BUILD_REPOSITORY }}
          ref: ${{ needs.matrix_prep.outputs.build-sha1 }}
          fetch-depth: ${{ matrix.fdepth }}
          clean: false # true is default. it *will* delete the hosts /dev if mounted inside.

      # clone the userpatches repo (`armbian/os`)
      - name: "Checkout userpatches repo: ${{env.USERPATCHES_REPOSITORY}}#${{env.USERPATCHES_REF}}"
        uses: actions/checkout@v4
        if: ${{ ( env.USERPATCHES_REPOSITORY != '' ) && ( env.USERPATCHES_REF != '' ) }}
        with:
          repository: ${{ env.USERPATCHES_REPOSITORY }}
          ref: ${{ env.USERPATCHES_REF }}
          fetch-depth: ${{ matrix.fdepth }}
          clean: false # true is default.
          path: userpatches.repo

      - name: "Put userpatches in place, and remove userpatches repo"
        if: ${{ ( env.USERPATCHES_REPOSITORY != '' ) && ( env.USERPATCHES_REF != '' ) }}
        run: |
          mkdir -pv userpatches
          rsync -av userpatches.repo/${{env.USERPATCHES_DIR}}/. userpatches/
          sudo rm -rf userpatches.repo
          echo ${{ needs.matrix_prep.outputs.version }} > userpatches/VERSION


      - name: Build  ${{matrix.desc}}
        timeout-minutes: 300
        id: build
        run: |
          bash ./compile.sh ${{ matrix.invocation }} REVISION="${{ needs.matrix_prep.outputs.version }}" SHOW_DEBUG=yes SHARE_LOG=yes ${{env.EXTRA_PARAMS_ALL_BUILDS}}

      - name: "Logs: ${{ steps.build.outputs.logs_url }}"
        if: always()
        run: |
          echo "Logs: ${{ steps.build.outputs.logs_url }}"
  "build-artifacts-chunk-9": # templated "build-artifacts-chunk-9"
    if: ${{ github.repository_owner == 'jethome-iot' && needs.matrix_prep.outputs.artifacts-chunk-not-empty-9 == 'yes' }}  # <-- HERE: Chunk number.
    needs: [ "matrix_prep" ]
    strategy:
      fail-fast: false # let other jobs try to complete if one fails
      matrix: ${{ fromJSON(needs.matrix_prep.outputs.artifacts-chunk-json-9) }} # <-- HERE: Chunk number.
    name: ${{ matrix.desc || 'Empty A9' }} # <-- HERE: Chunk number.
    runs-on: ${{ matrix.runs_on }}
    steps:

      #- name: "Runner clean ${{ needs.matrix_prep.outputs.version }}"
      #  uses: armbian/actions/runner-clean@main

      # Login to ghcr.io, for later uploading rootfs to ghcr.io
      - name: Docker Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: "${{ github.repository_owner }}" # GitHub username or org
          password: "${{ secrets.GITHUB_TOKEN }}"    # GitHub actions builtin token. repo has to have pkg access.

      - name: Docker Login to CR
        env:
          CR_REGISTRY: ${{ secrets.CR_REGISTRY }}
        if: env.CR_REGISTRY != null
        uses: docker/login-action@v3
        with:
          registry: ${{ secrets.CR_REGISTRY }}
          username: ${{ secrets.CR_USERNAME }}
          password: ${{ secrets.CR_PAT }}

      # cleanup the place where we will clone the userpatches repo, to avoid git going insane and cleaning everything later
      - name: Cleanup userpatches repo
        if: ${{ ( env.USERPATCHES_REPOSITORY != '' ) && ( env.USERPATCHES_REF != '' ) }}
        run: sudo rm -rf userpatches.repo

      - name: Checkout build repo
        uses: actions/checkout@v4 # We don't need to clone git, really. A wget would suffice for GH-hosted runners. But using clone is better for Igor-hosted runners.
        with:
          repository: ${{ env.BUILD_REPOSITORY }}
          ref: ${{ needs.matrix_prep.outputs.build-sha1 }}
          fetch-depth: ${{ matrix.fdepth }}
          clean: false # true is default. it *will* delete the hosts /dev if mounted inside.

      # clone the userpatches repo (`armbian/os`)
      - name: "Checkout userpatches repo: ${{env.USERPATCHES_REPOSITORY}}#${{env.USERPATCHES_REF}}"
        uses: actions/checkout@v4
        if: ${{ ( env.USERPATCHES_REPOSITORY != '' ) && ( env.USERPATCHES_REF != '' ) }}
        with:
          repository: ${{ env.USERPATCHES_REPOSITORY }}
          ref: ${{ env.USERPATCHES_REF }}
          fetch-depth: ${{ matrix.fdepth }}
          clean: false # true is default.
          path: userpatches.repo

      - name: "Put userpatches in place, and remove userpatches repo"
        if: ${{ ( env.USERPATCHES_REPOSITORY != '' ) && ( env.USERPATCHES_REF != '' ) }}
        run: |
          mkdir -pv userpatches
          rsync -av userpatches.repo/${{env.USERPATCHES_DIR}}/. userpatches/
          sudo rm -rf userpatches.repo
          echo ${{ needs.matrix_prep.outputs.version }} > userpatches/VERSION


      - name: Build  ${{matrix.desc}}
        timeout-minutes: 300
        id: build
        run: |
          bash ./compile.sh ${{ matrix.invocation }} REVISION="${{ needs.matrix_prep.outputs.version }}" SHOW_DEBUG=yes SHARE_LOG=yes ${{env.EXTRA_PARAMS_ALL_BUILDS}}

      - name: "Logs: ${{ steps.build.outputs.logs_url }}"
        if: always()
        run: |
          echo "Logs: ${{ steps.build.outputs.logs_url }}"
  "build-artifacts-chunk-10": # templated "build-artifacts-chunk-10"
    if: ${{ github.repository_owner == 'jethome-iot' && needs.matrix_prep.outputs.artifacts-chunk-not-empty-10 == 'yes' }}  # <-- HERE: Chunk number.
    needs: [ "matrix_prep" ]
    strategy:
      fail-fast: false # let other jobs try to complete if one fails
      matrix: ${{ fromJSON(needs.matrix_prep.outputs.artifacts-chunk-json-10) }} # <-- HERE: Chunk number.
    name: ${{ matrix.desc || 'Empty A10' }} # <-- HERE: Chunk number.
    runs-on: ${{ matrix.runs_on }}
    steps:

      #- name: "Runner clean ${{ needs.matrix_prep.outputs.version }}"
      #  uses: armbian/actions/runner-clean@main

      # Login to ghcr.io, for later uploading rootfs to ghcr.io
      - name: Docker Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: "${{ github.repository_owner }}" # GitHub username or org
          password: "${{ secrets.GITHUB_TOKEN }}"    # GitHub actions builtin token. repo has to have pkg access.

      - name: Docker Login to CR
        env:
          CR_REGISTRY: ${{ secrets.CR_REGISTRY }}
        if: env.CR_REGISTRY != null
        uses: docker/login-action@v3
        with:
          registry: ${{ secrets.CR_REGISTRY }}
          username: ${{ secrets.CR_USERNAME }}
          password: ${{ secrets.CR_PAT }}

      # cleanup the place where we will clone the userpatches repo, to avoid git going insane and cleaning everything later
      - name: Cleanup userpatches repo
        if: ${{ ( env.USERPATCHES_REPOSITORY != '' ) && ( env.USERPATCHES_REF != '' ) }}
        run: sudo rm -rf userpatches.repo

      - name: Checkout build repo
        uses: actions/checkout@v4 # We don't need to clone git, really. A wget would suffice for GH-hosted runners. But using clone is better for Igor-hosted runners.
        with:
          repository: ${{ env.BUILD_REPOSITORY }}
          ref: ${{ needs.matrix_prep.outputs.build-sha1 }}
          fetch-depth: ${{ matrix.fdepth }}
          clean: false # true is default. it *will* delete the hosts /dev if mounted inside.

      # clone the userpatches repo (`armbian/os`)
      - name: "Checkout userpatches repo: ${{env.USERPATCHES_REPOSITORY}}#${{env.USERPATCHES_REF}}"
        uses: actions/checkout@v4
        if: ${{ ( env.USERPATCHES_REPOSITORY != '' ) && ( env.USERPATCHES_REF != '' ) }}
        with:
          repository: ${{ env.USERPATCHES_REPOSITORY }}
          ref: ${{ env.USERPATCHES_REF }}
          fetch-depth: ${{ matrix.fdepth }}
          clean: false # true is default.
          path: userpatches.repo

      - name: "Put userpatches in place, and remove userpatches repo"
        if: ${{ ( env.USERPATCHES_REPOSITORY != '' ) && ( env.USERPATCHES_REF != '' ) }}
        run: |
          mkdir -pv userpatches
          rsync -av userpatches.repo/${{env.USERPATCHES_DIR}}/. userpatches/
          sudo rm -rf userpatches.repo
          echo ${{ needs.matrix_prep.outputs.version }} > userpatches/VERSION


      - name: Build  ${{matrix.desc}}
        timeout-minutes: 300
        id: build
        run: |
          bash ./compile.sh ${{ matrix.invocation }} REVISION="${{ needs.matrix_prep.outputs.version }}" SHOW_DEBUG=yes SHARE_LOG=yes ${{env.EXTRA_PARAMS_ALL_BUILDS}}

      - name: "Logs: ${{ steps.build.outputs.logs_url }}"
        if: always()
        run: |
          echo "Logs: ${{ steps.build.outputs.logs_url }}"
  "build-artifacts-chunk-11": # templated "build-artifacts-chunk-11"
    if: ${{ github.repository_owner == 'jethome-iot' && needs.matrix_prep.outputs.artifacts-chunk-not-empty-11 == 'yes' }}  # <-- HERE: Chunk number.
    needs: [ "matrix_prep" ]
    strategy:
      fail-fast: false # let other jobs try to complete if one fails
      matrix: ${{ fromJSON(needs.matrix_prep.outputs.artifacts-chunk-json-11) }} # <-- HERE: Chunk number.
    name: ${{ matrix.desc || 'Empty A11' }} # <-- HERE: Chunk number.
    runs-on: ${{ matrix.runs_on }}
    steps:

      #- name: "Runner clean ${{ needs.matrix_prep.outputs.version }}"
      #  uses: armbian/actions/runner-clean@main

      # Login to ghcr.io, for later uploading rootfs to ghcr.io
      - name: Docker Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: "${{ github.repository_owner }}" # GitHub username or org
          password: "${{ secrets.GITHUB_TOKEN }}"    # GitHub actions builtin token. repo has to have pkg access.

      - name: Docker Login to CR
        env:
          CR_REGISTRY: ${{ secrets.CR_REGISTRY }}
        if: env.CR_REGISTRY != null
        uses: docker/login-action@v3
        with:
          registry: ${{ secrets.CR_REGISTRY }}
          username: ${{ secrets.CR_USERNAME }}
          password: ${{ secrets.CR_PAT }}

      # cleanup the place where we will clone the userpatches repo, to avoid git going insane and cleaning everything later
      - name: Cleanup userpatches repo
        if: ${{ ( env.USERPATCHES_REPOSITORY != '' ) && ( env.USERPATCHES_REF != '' ) }}
        run: sudo rm -rf userpatches.repo

      - name: Checkout build repo
        uses: actions/checkout@v4 # We don't need to clone git, really. A wget would suffice for GH-hosted runners. But using clone is better for Igor-hosted runners.
        with:
          repository: ${{ env.BUILD_REPOSITORY }}
          ref: ${{ needs.matrix_prep.outputs.build-sha1 }}
          fetch-depth: ${{ matrix.fdepth }}
          clean: false # true is default. it *will* delete the hosts /dev if mounted inside.

      # clone the userpatches repo (`armbian/os`)
      - name: "Checkout userpatches repo: ${{env.USERPATCHES_REPOSITORY}}#${{env.USERPATCHES_REF}}"
        uses: actions/checkout@v4
        if: ${{ ( env.USERPATCHES_REPOSITORY != '' ) && ( env.USERPATCHES_REF != '' ) }}
        with:
          repository: ${{ env.USERPATCHES_REPOSITORY }}
          ref: ${{ env.USERPATCHES_REF }}
          fetch-depth: ${{ matrix.fdepth }}
          clean: false # true is default.
          path: userpatches.repo

      - name: "Put userpatches in place, and remove userpatches repo"
        if: ${{ ( env.USERPATCHES_REPOSITORY != '' ) && ( env.USERPATCHES_REF != '' ) }}
        run: |
          mkdir -pv userpatches
          rsync -av userpatches.repo/${{env.USERPATCHES_DIR}}/. userpatches/
          sudo rm -rf userpatches.repo
          echo ${{ needs.matrix_prep.outputs.version }} > userpatches/VERSION


      - name: Build  ${{matrix.desc}}
        timeout-minutes: 300
        id: build
        run: |
          bash ./compile.sh ${{ matrix.invocation }} REVISION="${{ needs.matrix_prep.outputs.version }}" SHOW_DEBUG=yes SHARE_LOG=yes ${{env.EXTRA_PARAMS_ALL_BUILDS}}

      - name: "Logs: ${{ steps.build.outputs.logs_url }}"
        if: always()
        run: |
          echo "Logs: ${{ steps.build.outputs.logs_url }}"
  "build-artifacts-chunk-12": # templated "build-artifacts-chunk-12"
    if: ${{ github.repository_owner == 'jethome-iot' && needs.matrix_prep.outputs.artifacts-chunk-not-empty-12 == 'yes' }}  # <-- HERE: Chunk number.
    needs: [ "matrix_prep" ]
    strategy:
      fail-fast: false # let other jobs try to complete if one fails
      matrix: ${{ fromJSON(needs.matrix_prep.outputs.artifacts-chunk-json-12) }} # <-- HERE: Chunk number.
    name: ${{ matrix.desc || 'Empty A12' }} # <-- HERE: Chunk number.
    runs-on: ${{ matrix.runs_on }}
    steps:

      #- name: "Runner clean ${{ needs.matrix_prep.outputs.version }}"
      #  uses: armbian/actions/runner-clean@main

      # Login to ghcr.io, for later uploading rootfs to ghcr.io
      - name: Docker Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: "${{ github.repository_owner }}" # GitHub username or org
          password: "${{ secrets.GITHUB_TOKEN }}"    # GitHub actions builtin token. repo has to have pkg access.

      - name: Docker Login to CR
        env:
          CR_REGISTRY: ${{ secrets.CR_REGISTRY }}
        if: env.CR_REGISTRY != null
        uses: docker/login-action@v3
        with:
          registry: ${{ secrets.CR_REGISTRY }}
          username: ${{ secrets.CR_USERNAME }}
          password: ${{ secrets.CR_PAT }}

      # cleanup the place where we will clone the userpatches repo, to avoid git going insane and cleaning everything later
      - name: Cleanup userpatches repo
        if: ${{ ( env.USERPATCHES_REPOSITORY != '' ) && ( env.USERPATCHES_REF != '' ) }}
        run: sudo rm -rf userpatches.repo

      - name: Checkout build repo
        uses: actions/checkout@v4 # We don't need to clone git, really. A wget would suffice for GH-hosted runners. But using clone is better for Igor-hosted runners.
        with:
          repository: ${{ env.BUILD_REPOSITORY }}
          ref: ${{ needs.matrix_prep.outputs.build-sha1 }}
          fetch-depth: ${{ matrix.fdepth }}
          clean: false # true is default. it *will* delete the hosts /dev if mounted inside.

      # clone the userpatches repo (`armbian/os`)
      - name: "Checkout userpatches repo: ${{env.USERPATCHES_REPOSITORY}}#${{env.USERPATCHES_REF}}"
        uses: actions/checkout@v4
        if: ${{ ( env.USERPATCHES_REPOSITORY != '' ) && ( env.USERPATCHES_REF != '' ) }}
        with:
          repository: ${{ env.USERPATCHES_REPOSITORY }}
          ref: ${{ env.USERPATCHES_REF }}
          fetch-depth: ${{ matrix.fdepth }}
          clean: false # true is default.
          path: userpatches.repo

      - name: "Put userpatches in place, and remove userpatches repo"
        if: ${{ ( env.USERPATCHES_REPOSITORY != '' ) && ( env.USERPATCHES_REF != '' ) }}
        run: |
          mkdir -pv userpatches
          rsync -av userpatches.repo/${{env.USERPATCHES_DIR}}/. userpatches/
          sudo rm -rf userpatches.repo
          echo ${{ needs.matrix_prep.outputs.version }} > userpatches/VERSION


      - name: Build  ${{matrix.desc}}
        timeout-minutes: 300
        id: build
        run: |
          bash ./compile.sh ${{ matrix.invocation }} REVISION="${{ needs.matrix_prep.outputs.version }}" SHOW_DEBUG=yes SHARE_LOG=yes ${{env.EXTRA_PARAMS_ALL_BUILDS}}

      - name: "Logs: ${{ steps.build.outputs.logs_url }}"
        if: always()
        run: |
          echo "Logs: ${{ steps.build.outputs.logs_url }}"
  "build-artifacts-chunk-13": # templated "build-artifacts-chunk-13"
    if: ${{ github.repository_owner == 'jethome-iot' && needs.matrix_prep.outputs.artifacts-chunk-not-empty-13 == 'yes' }}  # <-- HERE: Chunk number.
    needs: [ "matrix_prep" ]
    strategy:
      fail-fast: false # let other jobs try to complete if one fails
      matrix: ${{ fromJSON(needs.matrix_prep.outputs.artifacts-chunk-json-13) }} # <-- HERE: Chunk number.
    name: ${{ matrix.desc || 'Empty A13' }} # <-- HERE: Chunk number.
    runs-on: ${{ matrix.runs_on }}
    steps:

      #- name: "Runner clean ${{ needs.matrix_prep.outputs.version }}"
      #  uses: armbian/actions/runner-clean@main

      # Login to ghcr.io, for later uploading rootfs to ghcr.io
      - name: Docker Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: "${{ github.repository_owner }}" # GitHub username or org
          password: "${{ secrets.GITHUB_TOKEN }}"    # GitHub actions builtin token. repo has to have pkg access.

      - name: Docker Login to CR
        env:
          CR_REGISTRY: ${{ secrets.CR_REGISTRY }}
        if: env.CR_REGISTRY != null
        uses: docker/login-action@v3
        with:
          registry: ${{ secrets.CR_REGISTRY }}
          username: ${{ secrets.CR_USERNAME }}
          password: ${{ secrets.CR_PAT }}

      # cleanup the place where we will clone the userpatches repo, to avoid git going insane and cleaning everything later
      - name: Cleanup userpatches repo
        if: ${{ ( env.USERPATCHES_REPOSITORY != '' ) && ( env.USERPATCHES_REF != '' ) }}
        run: sudo rm -rf userpatches.repo

      - name: Checkout build repo
        uses: actions/checkout@v4 # We don't need to clone git, really. A wget would suffice for GH-hosted runners. But using clone is better for Igor-hosted runners.
        with:
          repository: ${{ env.BUILD_REPOSITORY }}
          ref: ${{ needs.matrix_prep.outputs.build-sha1 }}
          fetch-depth: ${{ matrix.fdepth }}
          clean: false # true is default. it *will* delete the hosts /dev if mounted inside.

      # clone the userpatches repo (`armbian/os`)
      - name: "Checkout userpatches repo: ${{env.USERPATCHES_REPOSITORY}}#${{env.USERPATCHES_REF}}"
        uses: actions/checkout@v4
        if: ${{ ( env.USERPATCHES_REPOSITORY != '' ) && ( env.USERPATCHES_REF != '' ) }}
        with:
          repository: ${{ env.USERPATCHES_REPOSITORY }}
          ref: ${{ env.USERPATCHES_REF }}
          fetch-depth: ${{ matrix.fdepth }}
          clean: false # true is default.
          path: userpatches.repo

      - name: "Put userpatches in place, and remove userpatches repo"
        if: ${{ ( env.USERPATCHES_REPOSITORY != '' ) && ( env.USERPATCHES_REF != '' ) }}
        run: |
          mkdir -pv userpatches
          rsync -av userpatches.repo/${{env.USERPATCHES_DIR}}/. userpatches/
          sudo rm -rf userpatches.repo
          echo ${{ needs.matrix_prep.outputs.version }} > userpatches/VERSION


      - name: Build  ${{matrix.desc}}
        timeout-minutes: 300
        id: build
        run: |
          bash ./compile.sh ${{ matrix.invocation }} REVISION="${{ needs.matrix_prep.outputs.version }}" SHOW_DEBUG=yes SHARE_LOG=yes ${{env.EXTRA_PARAMS_ALL_BUILDS}}

      - name: "Logs: ${{ steps.build.outputs.logs_url }}"
        if: always()
        run: |
          echo "Logs: ${{ steps.build.outputs.logs_url }}"
  "build-artifacts-chunk-14": # templated "build-artifacts-chunk-14"
    if: ${{ github.repository_owner == 'jethome-iot' && needs.matrix_prep.outputs.artifacts-chunk-not-empty-14 == 'yes' }}  # <-- HERE: Chunk number.
    needs: [ "matrix_prep" ]
    strategy:
      fail-fast: false # let other jobs try to complete if one fails
      matrix: ${{ fromJSON(needs.matrix_prep.outputs.artifacts-chunk-json-14) }} # <-- HERE: Chunk number.
    name: ${{ matrix.desc || 'Empty A14' }} # <-- HERE: Chunk number.
    runs-on: ${{ matrix.runs_on }}
    steps:

      #- name: "Runner clean ${{ needs.matrix_prep.outputs.version }}"
      #  uses: armbian/actions/runner-clean@main

      # Login to ghcr.io, for later uploading rootfs to ghcr.io
      - name: Docker Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: "${{ github.repository_owner }}" # GitHub username or org
          password: "${{ secrets.GITHUB_TOKEN }}"    # GitHub actions builtin token. repo has to have pkg access.

      - name: Docker Login to CR
        env:
          CR_REGISTRY: ${{ secrets.CR_REGISTRY }}
        if: env.CR_REGISTRY != null
        uses: docker/login-action@v3
        with:
          registry: ${{ secrets.CR_REGISTRY }}
          username: ${{ secrets.CR_USERNAME }}
          password: ${{ secrets.CR_PAT }}

      # cleanup the place where we will clone the userpatches repo, to avoid git going insane and cleaning everything later
      - name: Cleanup userpatches repo
        if: ${{ ( env.USERPATCHES_REPOSITORY != '' ) && ( env.USERPATCHES_REF != '' ) }}
        run: sudo rm -rf userpatches.repo

      - name: Checkout build repo
        uses: actions/checkout@v4 # We don't need to clone git, really. A wget would suffice for GH-hosted runners. But using clone is better for Igor-hosted runners.
        with:
          repository: ${{ env.BUILD_REPOSITORY }}
          ref: ${{ needs.matrix_prep.outputs.build-sha1 }}
          fetch-depth: ${{ matrix.fdepth }}
          clean: false # true is default. it *will* delete the hosts /dev if mounted inside.

      # clone the userpatches repo (`armbian/os`)
      - name: "Checkout userpatches repo: ${{env.USERPATCHES_REPOSITORY}}#${{env.USERPATCHES_REF}}"
        uses: actions/checkout@v4
        if: ${{ ( env.USERPATCHES_REPOSITORY != '' ) && ( env.USERPATCHES_REF != '' ) }}
        with:
          repository: ${{ env.USERPATCHES_REPOSITORY }}
          ref: ${{ env.USERPATCHES_REF }}
          fetch-depth: ${{ matrix.fdepth }}
          clean: false # true is default.
          path: userpatches.repo

      - name: "Put userpatches in place, and remove userpatches repo"
        if: ${{ ( env.USERPATCHES_REPOSITORY != '' ) && ( env.USERPATCHES_REF != '' ) }}
        run: |
          mkdir -pv userpatches
          rsync -av userpatches.repo/${{env.USERPATCHES_DIR}}/. userpatches/
          sudo rm -rf userpatches.repo
          echo ${{ needs.matrix_prep.outputs.version }} > userpatches/VERSION


      - name: Build  ${{matrix.desc}}
        timeout-minutes: 300
        id: build
        run: |
          bash ./compile.sh ${{ matrix.invocation }} REVISION="${{ needs.matrix_prep.outputs.version }}" SHOW_DEBUG=yes SHARE_LOG=yes ${{env.EXTRA_PARAMS_ALL_BUILDS}}

      - name: "Logs: ${{ steps.build.outputs.logs_url }}"
        if: always()
        run: |
          echo "Logs: ${{ steps.build.outputs.logs_url }}"
  "build-artifacts-chunk-15": # templated "build-artifacts-chunk-15"
    if: ${{ github.repository_owner == 'jethome-iot' && needs.matrix_prep.outputs.artifacts-chunk-not-empty-15 == 'yes' }}  # <-- HERE: Chunk number.
    needs: [ "matrix_prep" ]
    strategy:
      fail-fast: false # let other jobs try to complete if one fails
      matrix: ${{ fromJSON(needs.matrix_prep.outputs.artifacts-chunk-json-15) }} # <-- HERE: Chunk number.
    name: ${{ matrix.desc || 'Empty A15' }} # <-- HERE: Chunk number.
    runs-on: ${{ matrix.runs_on }}
    steps:

      #- name: "Runner clean ${{ needs.matrix_prep.outputs.version }}"
      #  uses: armbian/actions/runner-clean@main

      # Login to ghcr.io, for later uploading rootfs to ghcr.io
      - name: Docker Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: "${{ github.repository_owner }}" # GitHub username or org
          password: "${{ secrets.GITHUB_TOKEN }}"    # GitHub actions builtin token. repo has to have pkg access.

      - name: Docker Login to CR
        env:
          CR_REGISTRY: ${{ secrets.CR_REGISTRY }}
        if: env.CR_REGISTRY != null
        uses: docker/login-action@v3
        with:
          registry: ${{ secrets.CR_REGISTRY }}
          username: ${{ secrets.CR_USERNAME }}
          password: ${{ secrets.CR_PAT }}

      # cleanup the place where we will clone the userpatches repo, to avoid git going insane and cleaning everything later
      - name: Cleanup userpatches repo
        if: ${{ ( env.USERPATCHES_REPOSITORY != '' ) && ( env.USERPATCHES_REF != '' ) }}
        run: sudo rm -rf userpatches.repo

      - name: Checkout build repo
        uses: actions/checkout@v4 # We don't need to clone git, really. A wget would suffice for GH-hosted runners. But using clone is better for Igor-hosted runners.
        with:
          repository: ${{ env.BUILD_REPOSITORY }}
          ref: ${{ needs.matrix_prep.outputs.build-sha1 }}
          fetch-depth: ${{ matrix.fdepth }}
          clean: false # true is default. it *will* delete the hosts /dev if mounted inside.

      # clone the userpatches repo (`armbian/os`)
      - name: "Checkout userpatches repo: ${{env.USERPATCHES_REPOSITORY}}#${{env.USERPATCHES_REF}}"
        uses: actions/checkout@v4
        if: ${{ ( env.USERPATCHES_REPOSITORY != '' ) && ( env.USERPATCHES_REF != '' ) }}
        with:
          repository: ${{ env.USERPATCHES_REPOSITORY }}
          ref: ${{ env.USERPATCHES_REF }}
          fetch-depth: ${{ matrix.fdepth }}
          clean: false # true is default.
          path: userpatches.repo

      - name: "Put userpatches in place, and remove userpatches repo"
        if: ${{ ( env.USERPATCHES_REPOSITORY != '' ) && ( env.USERPATCHES_REF != '' ) }}
        run: |
          mkdir -pv userpatches
          rsync -av userpatches.repo/${{env.USERPATCHES_DIR}}/. userpatches/
          sudo rm -rf userpatches.repo
          echo ${{ needs.matrix_prep.outputs.version }} > userpatches/VERSION


      - name: Build  ${{matrix.desc}}
        timeout-minutes: 300
        id: build
        run: |
          bash ./compile.sh ${{ matrix.invocation }} REVISION="${{ needs.matrix_prep.outputs.version }}" SHOW_DEBUG=yes SHARE_LOG=yes ${{env.EXTRA_PARAMS_ALL_BUILDS}}

      - name: "Logs: ${{ steps.build.outputs.logs_url }}"
        if: always()
        run: |
          echo "Logs: ${{ steps.build.outputs.logs_url }}"
  "build-artifacts-chunk-16": # templated "build-artifacts-chunk-16"
    if: ${{ github.repository_owner == 'jethome-iot' && needs.matrix_prep.outputs.artifacts-chunk-not-empty-16 == 'yes' }}  # <-- HERE: Chunk number.
    needs: [ "matrix_prep" ]
    strategy:
      fail-fast: false # let other jobs try to complete if one fails
      matrix: ${{ fromJSON(needs.matrix_prep.outputs.artifacts-chunk-json-16) }} # <-- HERE: Chunk number.
    name: ${{ matrix.desc || 'Empty A16' }} # <-- HERE: Chunk number.
    runs-on: ${{ matrix.runs_on }}
    steps:

      #- name: "Runner clean ${{ needs.matrix_prep.outputs.version }}"
      #  uses: armbian/actions/runner-clean@main

      # Login to ghcr.io, for later uploading rootfs to ghcr.io
      - name: Docker Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: "${{ github.repository_owner }}" # GitHub username or org
          password: "${{ secrets.GITHUB_TOKEN }}"    # GitHub actions builtin token. repo has to have pkg access.

      - name: Docker Login to CR
        env:
          CR_REGISTRY: ${{ secrets.CR_REGISTRY }}
        if: env.CR_REGISTRY != null
        uses: docker/login-action@v3
        with:
          registry: ${{ secrets.CR_REGISTRY }}
          username: ${{ secrets.CR_USERNAME }}
          password: ${{ secrets.CR_PAT }}

      # cleanup the place where we will clone the userpatches repo, to avoid git going insane and cleaning everything later
      - name: Cleanup userpatches repo
        if: ${{ ( env.USERPATCHES_REPOSITORY != '' ) && ( env.USERPATCHES_REF != '' ) }}
        run: sudo rm -rf userpatches.repo

      - name: Checkout build repo
        uses: actions/checkout@v4 # We don't need to clone git, really. A wget would suffice for GH-hosted runners. But using clone is better for Igor-hosted runners.
        with:
          repository: ${{ env.BUILD_REPOSITORY }}
          ref: ${{ needs.matrix_prep.outputs.build-sha1 }}
          fetch-depth: ${{ matrix.fdepth }}
          clean: false # true is default. it *will* delete the hosts /dev if mounted inside.

      # clone the userpatches repo (`armbian/os`)
      - name: "Checkout userpatches repo: ${{env.USERPATCHES_REPOSITORY}}#${{env.USERPATCHES_REF}}"
        uses: actions/checkout@v4
        if: ${{ ( env.USERPATCHES_REPOSITORY != '' ) && ( env.USERPATCHES_REF != '' ) }}
        with:
          repository: ${{ env.USERPATCHES_REPOSITORY }}
          ref: ${{ env.USERPATCHES_REF }}
          fetch-depth: ${{ matrix.fdepth }}
          clean: false # true is default.
          path: userpatches.repo

      - name: "Put userpatches in place, and remove userpatches repo"
        if: ${{ ( env.USERPATCHES_REPOSITORY != '' ) && ( env.USERPATCHES_REF != '' ) }}
        run: |
          mkdir -pv userpatches
          rsync -av userpatches.repo/${{env.USERPATCHES_DIR}}/. userpatches/
          sudo rm -rf userpatches.repo
          echo ${{ needs.matrix_prep.outputs.version }} > userpatches/VERSION


      - name: Build  ${{matrix.desc}}
        timeout-minutes: 300
        id: build
        run: |
          bash ./compile.sh ${{ matrix.invocation }} REVISION="${{ needs.matrix_prep.outputs.version }}" SHOW_DEBUG=yes SHARE_LOG=yes ${{env.EXTRA_PARAMS_ALL_BUILDS}}

      - name: "Logs: ${{ steps.build.outputs.logs_url }}"
        if: always()
        run: |
          echo "Logs: ${{ steps.build.outputs.logs_url }}"
  "build-artifacts-chunk-17": # templated "build-artifacts-chunk-17"
    if: ${{ github.repository_owner == 'jethome-iot' && needs.matrix_prep.outputs.artifacts-chunk-not-empty-17 == 'yes' }}  # <-- HERE: Chunk number.
    needs: [ "matrix_prep" ]
    strategy:
      fail-fast: false # let other jobs try to complete if one fails
      matrix: ${{ fromJSON(needs.matrix_prep.outputs.artifacts-chunk-json-17) }} # <-- HERE: Chunk number.
    name: ${{ matrix.desc || 'Empty A17' }} # <-- HERE: Chunk number.
    runs-on: ${{ matrix.runs_on }}
    steps:

      #- name: "Runner clean ${{ needs.matrix_prep.outputs.version }}"
      #  uses: armbian/actions/runner-clean@main

      # Login to ghcr.io, for later uploading rootfs to ghcr.io
      - name: Docker Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: "${{ github.repository_owner }}" # GitHub username or org
          password: "${{ secrets.GITHUB_TOKEN }}"    # GitHub actions builtin token. repo has to have pkg access.

      - name: Docker Login to CR
        env:
          CR_REGISTRY: ${{ secrets.CR_REGISTRY }}
        if: env.CR_REGISTRY != null
        uses: docker/login-action@v3
        with:
          registry: ${{ secrets.CR_REGISTRY }}
          username: ${{ secrets.CR_USERNAME }}
          password: ${{ secrets.CR_PAT }}

      # cleanup the place where we will clone the userpatches repo, to avoid git going insane and cleaning everything later
      - name: Cleanup userpatches repo
        if: ${{ ( env.USERPATCHES_REPOSITORY != '' ) && ( env.USERPATCHES_REF != '' ) }}
        run: sudo rm -rf userpatches.repo

      - name: Checkout build repo
        uses: actions/checkout@v4 # We don't need to clone git, really. A wget would suffice for GH-hosted runners. But using clone is better for Igor-hosted runners.
        with:
          repository: ${{ env.BUILD_REPOSITORY }}
          ref: ${{ needs.matrix_prep.outputs.build-sha1 }}
          fetch-depth: ${{ matrix.fdepth }}
          clean: false # true is default. it *will* delete the hosts /dev if mounted inside.

      # clone the userpatches repo (`armbian/os`)
      - name: "Checkout userpatches repo: ${{env.USERPATCHES_REPOSITORY}}#${{env.USERPATCHES_REF}}"
        uses: actions/checkout@v4
        if: ${{ ( env.USERPATCHES_REPOSITORY != '' ) && ( env.USERPATCHES_REF != '' ) }}
        with:
          repository: ${{ env.USERPATCHES_REPOSITORY }}
          ref: ${{ env.USERPATCHES_REF }}
          fetch-depth: ${{ matrix.fdepth }}
          clean: false # true is default.
          path: userpatches.repo

      - name: "Put userpatches in place, and remove userpatches repo"
        if: ${{ ( env.USERPATCHES_REPOSITORY != '' ) && ( env.USERPATCHES_REF != '' ) }}
        run: |
          mkdir -pv userpatches
          rsync -av userpatches.repo/${{env.USERPATCHES_DIR}}/. userpatches/
          sudo rm -rf userpatches.repo
          echo ${{ needs.matrix_prep.outputs.version }} > userpatches/VERSION


      - name: Build  ${{matrix.desc}}
        timeout-minutes: 300
        id: build
        run: |
          bash ./compile.sh ${{ matrix.invocation }} REVISION="${{ needs.matrix_prep.outputs.version }}" SHOW_DEBUG=yes SHARE_LOG=yes ${{env.EXTRA_PARAMS_ALL_BUILDS}}

      - name: "Logs: ${{ steps.build.outputs.logs_url }}"
        if: always()
        run: |
          echo "Logs: ${{ steps.build.outputs.logs_url }}"

# template file: 650.per-chunk-images_job.yaml

  "build-images-chunk-1": # templated "build-images-chunk-1"
    needs: [ "matrix_prep", "all-artifacts-ready" ]
    timeout-minutes: 240
    if: ${{ !failure() && !cancelled() && ( github.repository_owner == 'jethome-iot' ) && ( needs.matrix_prep.outputs.images-chunk-not-empty-1 == 'yes' ) }} # <-- HERE: Chunk number.
    strategy:
      fail-fast: false # let other jobs try to complete if one fails
      matrix: ${{ fromJSON(needs.matrix_prep.outputs.images-chunk-json-1) }} # <-- HERE: Chunk number.
    name: ${{ matrix.desc || 'Empty I1' }} # <-- HERE: Chunk number.
    runs-on: ${{ matrix.runs_on }}
    steps:

      # cleaning self hosted runners
      #- name: "Runner clean ${{ needs.matrix_prep.outputs.version }}"
      #  uses: armbian/actions/runner-clean@main

      # cleanup the place where we will clone the userpatches repo, to avoid git going insane and cleaning everything later
      - name: Cleanup userpatches repo
        if: ${{ ( env.USERPATCHES_REPOSITORY != '' ) && ( env.USERPATCHES_REF != '' ) }}
        run: sudo rm -rf userpatches.repo

      - name: Checkout build repo
        uses: actions/checkout@v4
        with:
          repository: ${{ env.BUILD_REPOSITORY }}
          ref: ${{ needs.matrix_prep.outputs.build-sha1 }}
          fetch-depth: ${{ matrix.fdepth }}
          clean: false # true is default. it *will* delete the hosts /dev if mounted inside.

      # clone the userpatches repo (`armbian/os`)
      - name: "Checkout userpatches repo: ${{env.USERPATCHES_REPOSITORY}}#${{env.USERPATCHES_REF}}"
        uses: actions/checkout@v4
        if: ${{ ( env.USERPATCHES_REPOSITORY != '' ) && ( env.USERPATCHES_REF != '' ) }}
        with:
          repository: ${{ env.USERPATCHES_REPOSITORY }}
          ref: ${{ env.USERPATCHES_REF }}
          fetch-depth: ${{ matrix.fdepth }}
          clean: false # true is default.
          path: userpatches.repo

      - name: Checkout jethome-tools repository
        uses: actions/checkout@v4
        with:
          repository: jethome-ru/jethome-tools
          path: tools
          ref: convert_jhos

      - name: "Put userpatches in place, and remove userpatches repo"
        if: ${{ ( env.USERPATCHES_REPOSITORY != '' ) && ( env.USERPATCHES_REF != '' ) }}
        run: |
          mkdir -pv userpatches
          rsync -av userpatches.repo/${{env.USERPATCHES_DIR}}/. userpatches/
          rm -rf userpatches.repo
          echo ${{ needs.matrix_prep.outputs.version }} > userpatches/VERSION

      - name: "Cleanup leftover output"
        run: |
          sudo rm -f userpatches/VERSION

      - name: ${{matrix.desc}}
        id: build-one-image
        timeout-minutes: 300
        run: |
          # calculate loop from runner name
          if [ -z "${ImageOS}" ]; then
            USE_FIXED_LOOP_DEVICE=$(echo ${RUNNER_NAME} | rev | cut -d"-" -f1  | rev | sed 's/^0*//' | sed -e 's/^/\/dev\/loop/')
          fi
          bash ./compile.sh ${{ matrix.invocation }} REVISION="${{ needs.matrix_prep.outputs.version }}" USE_FIXED_LOOP_DEVICE="$USE_FIXED_LOOP_DEVICE" SHARE_LOG=yes MAKE_FOLDERS="archive" IMAGE_VERSION=${{ needs.matrix_prep.outputs.version }} ${{env.EXTRA_PARAMS_IMAGE}} ${{env.EXTRA_PARAMS_ALL_BUILDS}}

      - name: "Logs: ${{ steps.build-one-image.outputs.logs_url }}"
        if: always()
        run: |
          echo "Logs: ${{ steps.build-one-image.outputs.logs_url }}"
          find output

      - name: Install SSH key for storage
        env:
          KEY_ARMBIAN_UPLOAD: ${{ secrets.KEY_ARMBIAN_UPLOAD }}
        if: env.KEY_ARMBIAN_UPLOAD != null
        uses: shimataro/ssh-key-action@v2
        with:
          key: ${{ secrets.KEY_ARMBIAN_UPLOAD }}
          known_hosts: ${{ secrets.KNOWN_HOSTS_ARMBIAN_UPLOAD }}
          if_key_exists: replace

      - name: Check API rate limits
        run: |

          # install dependencies
          if ! command -v "gh" > /dev/null 2>&1; then
             sudo apt-get -y -qq install gh
          fi

          while true
            do
            API_CALLS_TOTAL=$(gh api -H "Accept: application/vnd.github+json" -H "X-GitHub-Api-Version: 2022-11-28" /rate_limit | jq -r '.rate.limit')
            API_CALLS_LEFT=$(gh api -H "Accept: application/vnd.github+json" -H "X-GitHub-Api-Version: 2022-11-28" /rate_limit | jq -r '.rate.remaining')
            PERCENT=$(( API_CALLS_LEFT * 100 / API_CALLS_TOTAL ))
            if (( $PERCENT > 20 )); then
                echo "API rate in good shape $PERCENT % free"
                exit 0
            fi
            echo "API rate lower then 20%, sleping 10m"
            sleep 10m
          done

          # show current api rate
          curl -s -H "Accept: application/vnd.github.v3+json" -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" https://api.github.com/rate_limit

      - name: Import GPG key
        env:
          GPG_KEY1: ${{ secrets.GPG_KEY1 }}
        if: env.GPG_KEY1 != null
        uses: crazy-max/ghaction-import-gpg@v6
        with:
          gpg_private_key: ${{ secrets.GPG_KEY1 }}
          passphrase: ${{ secrets.GPG_PASSPHRASE1 }}

      - name: Sign
        env:
          GPG_PASSPHRASE1: ${{ secrets.GPG_PASSPHRASE1 }}
        if: env.GPG_PASSPHRASE1 != null
        run: |

          echo ${{ secrets.GPG_PASSPHRASE1 }} | gpg --passphrase-fd 0 --armor --detach-sign --pinentry-mode loopback --batch --yes output/images/*/archive/*img*.xz

      #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!11
      - name: Check filelist
        run: |
          find output

      - name: "Convert image to burn"
        id: convertburn
        run: |
          if ! command -v "dtc" > /dev/null 2>&1; then
             sudo apt update \
             && sudo apt install device-tree-compiler -y
          fi
          if ! command -v "cc" > /dev/null 2>&1; then
             sudo apt update \
             && sudo apt install build-essential cpp -y
          fi
          if ! command -v "zip" > /dev/null 2>&1; then
             sudo apt update \
             && sudo apt install zip -y
          fi


          UBOOTDEB=$(find output | grep linux-u-boot | head -n 1)
          IMG=$(find output | grep  -e  ".*images.*Armbian.*img.xz$" | head -n 1)
          # Armbian_23.8.0-trunk.52.jh.3.5_Jethubj80_bookworm_current_6.1.32.burn.img

          cd tools

          DEB="../${UBOOTDEB}"
          dpkg -x "$DEB" output
          UBOOT=$(find output/usr/lib -name u-boot.nosd.bin | head -n 1)
          echo UBOOT: ${UBOOT}
          find ../output

          ### 'BETA=yes' 'BOARD=jethubj80' 'BRANCH=current' 'BUILD_DESKTOP=no' 'BUILD_MINIMAL=no' 'RELEASE=bookworm'
          EVALCMD=$(echo ${{ matrix.invocation }} | sed 's/jethome-images//')
          eval ${EVALCMD}
          echo ${EVALCMD}
          case ${BOARD} in
            jethubj100)
              ./convert.sh ../${IMG} d1 armbian compress output/usr/lib/linux*/u-boot.nosd.bin
              SUPPORTED="D1,D1P"
              ;;
            jethubj200)
              ./convert.sh ../${IMG} d2 armbian compress output/usr/lib/linux*/u-boot.nosd.bin
              SUPPORTED="D2"
              ;;
            jethubj80)
              ./convert.sh ../${IMG} h1 armbian compress output/usr/lib/linux*/u-boot.nosd.bin
              SUPPORTED="H1"
              ;;
            *)
              echo "Unsupported board" ${BOARD}
              echo "Error in convert: Unsupported board" ${BOARD} >> GITHUB_STEP_SUMMARY
              exit 200
              ;;
          esac
          rm -rf output/usr

          IMGBURN=$(find output | grep  -e  "Armbian.*burn.img.zip$" | head -n 1)
          echo IMGBURN: ${IMGBURN}
          [ -z "${IMGBURN}" ] && exit 50

          if [ "${BETA}" == "yes" ]; then
            case "${{ env.BUILD_REF }}" in
              main*)
                CHANNEL="nightly"
                ;;
              v2*)
                CHANNEL="rc"
                ;;
              *)
                CHANNEL="${BUILD_REF}"
                ;;
            esac

          else
            CHANNEL="release"
          fi

          echo "board=${BOARD}" >> $GITHUB_OUTPUT
          echo "brd=${BOARD:6}"  >> $GITHUB_OUTPUT
          echo "branch=${BRANCH}" >> $GITHUB_OUTPUT
          echo "channel=${CHANNEL}" >> $GITHUB_OUTPUT
          echo "release=${RELEASE}" >> $GITHUB_OUTPUT
          echo "supported=${SUPPORTED}" >> $GITHUB_OUTPUT
          echo "image=${IMG}" >> $GITHUB_OUTPUT
          echo "imageburn=tools/${IMGBURN}" >> $GITHUB_OUTPUT

      - name: Sign burn
        env:
          GPG_PASSPHRASE1: ${{ secrets.GPG_PASSPHRASE1 }}
        if: env.GPG_PASSPHRASE1 != null
        run: |
          echo ${{ secrets.GPG_PASSPHRASE1 }} | gpg --passphrase-fd 0 --armor --detach-sign --pinentry-mode loopback --batch --yes ${{ steps.convertburn.outputs.imageburn }}

      - name: "Upload artefacts"
        if: ${{ github.event.inputs.uploadtoserver == 'github' || github.event.inputs.uploadtoserver == 'both' }}
        uses: ncipollo/release-action@v1
        with:
          repo: "${{ env.RELEASE_REPOSITORY }}"
          artifacts: "output/images/*/*/Armbian_*.*"
          tag: "${{ needs.matrix_prep.outputs.version }}"
          omitBody: true
          replacesArtifacts: true
          omitName: true
          makeLatest: false
          omitPrereleaseDuringUpdate: true
          allowUpdates: true
          artifactErrorsFailBuild: false
          token: "${{ env.GH_TOKEN }}"

      - name: "Upload artefacts"
        if: ${{ github.event.inputs.uploadtoserver == 'github' || github.event.inputs.uploadtoserver == 'both' }}
        uses: ncipollo/release-action@v1
        with:
          repo: "${{ env.RELEASE_REPOSITORY }}"
          artifacts: "${{ steps.convertburn.outputs.imageburn }}*"
          tag: "${{ needs.matrix_prep.outputs.version }}"
          omitBody: true
          replacesArtifacts: true
          omitName: true
          makeLatest: false
          omitPrereleaseDuringUpdate: true
          allowUpdates: true
          artifactErrorsFailBuild: false
          token: "${{ env.GH_TOKEN }}"

      - name: Deploy to fw.jethome.ru (sdcard)
        if: ${{ github.event.inputs.uploadtoserver == 'both' || github.event.inputs.uploadtoserver == 'jethome' }}
        id: upload-sdcard
        uses: jethome-iot/actions/firmware-upload@master
        with:
          url: https://fw.jethome.ru
          fullslug: "JetHome.${{ steps.convertburn.outputs.brd }}.Armbian.${{ steps.convertburn.outputs.channel }}.${{ steps.convertburn.outputs.release }}.${{ steps.convertburn.outputs.branch }}"
          image_type: "sdcard"
          firmware_file: "${{ steps.convertburn.outputs.image }}"
          hashpgp_file: "${{ steps.convertburn.outputs.image }}.asc"
          version: "${{ needs.matrix_prep.outputs.version }}"
          force_overwrite: "true"
          generatefirmwareslot: "true"
          update_latest: "true"
          supported_devices: "${{ steps.convertburn.outputs.supported }}"
          FWUPLOAD: ${{ secrets.FWUPLOAD }}

      - name: Deploy to fw.jethome.ru (burn)
        if: ${{ github.event.inputs.uploadtoserver == 'both' || github.event.inputs.uploadtoserver == 'jethome' }}
        id: upload-burn
        uses: jethome-iot/actions/firmware-upload@master
        with:
          url: https://fw.jethome.ru
          fullslug: "JetHome.${{ steps.convertburn.outputs.brd }}.Armbian.${{ steps.convertburn.outputs.channel }}.${{ steps.convertburn.outputs.release }}.${{ steps.convertburn.outputs.branch }}"
          image_type: "burn"
          firmware_file: "${{ steps.convertburn.outputs.imageburn }}"
          hashpgp_file: "${{ steps.convertburn.outputs.imageburn }}.asc"
          version: "${{ needs.matrix_prep.outputs.version }}"
          generatefirmwareslot: "false"
          force_overwrite: "true"
          update_latest: "true"
          supported_devices: "${{ steps.convertburn.outputs.supported }}"
          FWUPLOAD: ${{ secrets.FWUPLOAD }}

      - name: "Runner clean ${{ needs.matrix_prep.outputs.version }}"
        if: always()
        run: sudo rm -rfv output/images userpatches/VERSION
  "build-images-chunk-2": # templated "build-images-chunk-2"
    needs: [ "matrix_prep", "all-artifacts-ready" ]
    timeout-minutes: 240
    if: ${{ !failure() && !cancelled() && ( github.repository_owner == 'jethome-iot' ) && ( needs.matrix_prep.outputs.images-chunk-not-empty-2 == 'yes' ) }} # <-- HERE: Chunk number.
    strategy:
      fail-fast: false # let other jobs try to complete if one fails
      matrix: ${{ fromJSON(needs.matrix_prep.outputs.images-chunk-json-2) }} # <-- HERE: Chunk number.
    name: ${{ matrix.desc || 'Empty I2' }} # <-- HERE: Chunk number.
    runs-on: ${{ matrix.runs_on }}
    steps:

      # cleaning self hosted runners
      #- name: "Runner clean ${{ needs.matrix_prep.outputs.version }}"
      #  uses: armbian/actions/runner-clean@main

      # cleanup the place where we will clone the userpatches repo, to avoid git going insane and cleaning everything later
      - name: Cleanup userpatches repo
        if: ${{ ( env.USERPATCHES_REPOSITORY != '' ) && ( env.USERPATCHES_REF != '' ) }}
        run: sudo rm -rf userpatches.repo

      - name: Checkout build repo
        uses: actions/checkout@v4
        with:
          repository: ${{ env.BUILD_REPOSITORY }}
          ref: ${{ needs.matrix_prep.outputs.build-sha1 }}
          fetch-depth: ${{ matrix.fdepth }}
          clean: false # true is default. it *will* delete the hosts /dev if mounted inside.

      # clone the userpatches repo (`armbian/os`)
      - name: "Checkout userpatches repo: ${{env.USERPATCHES_REPOSITORY}}#${{env.USERPATCHES_REF}}"
        uses: actions/checkout@v4
        if: ${{ ( env.USERPATCHES_REPOSITORY != '' ) && ( env.USERPATCHES_REF != '' ) }}
        with:
          repository: ${{ env.USERPATCHES_REPOSITORY }}
          ref: ${{ env.USERPATCHES_REF }}
          fetch-depth: ${{ matrix.fdepth }}
          clean: false # true is default.
          path: userpatches.repo

      - name: Checkout jethome-tools repository
        uses: actions/checkout@v4
        with:
          repository: jethome-ru/jethome-tools
          path: tools
          ref: convert_jhos

      - name: "Put userpatches in place, and remove userpatches repo"
        if: ${{ ( env.USERPATCHES_REPOSITORY != '' ) && ( env.USERPATCHES_REF != '' ) }}
        run: |
          mkdir -pv userpatches
          rsync -av userpatches.repo/${{env.USERPATCHES_DIR}}/. userpatches/
          rm -rf userpatches.repo
          echo ${{ needs.matrix_prep.outputs.version }} > userpatches/VERSION

      - name: "Cleanup leftover output"
        run: |
          sudo rm -f userpatches/VERSION

      - name: ${{matrix.desc}}
        id: build-one-image
        timeout-minutes: 300
        run: |
          # calculate loop from runner name
          if [ -z "${ImageOS}" ]; then
            USE_FIXED_LOOP_DEVICE=$(echo ${RUNNER_NAME} | rev | cut -d"-" -f1  | rev | sed 's/^0*//' | sed -e 's/^/\/dev\/loop/')
          fi
          bash ./compile.sh ${{ matrix.invocation }} REVISION="${{ needs.matrix_prep.outputs.version }}" USE_FIXED_LOOP_DEVICE="$USE_FIXED_LOOP_DEVICE" SHARE_LOG=yes MAKE_FOLDERS="archive" IMAGE_VERSION=${{ needs.matrix_prep.outputs.version }} ${{env.EXTRA_PARAMS_IMAGE}} ${{env.EXTRA_PARAMS_ALL_BUILDS}}

      - name: "Logs: ${{ steps.build-one-image.outputs.logs_url }}"
        if: always()
        run: |
          echo "Logs: ${{ steps.build-one-image.outputs.logs_url }}"

      - name: Install SSH key for storage
        env:
          KEY_ARMBIAN_UPLOAD: ${{ secrets.KEY_ARMBIAN_UPLOAD }}
        if: env.KEY_ARMBIAN_UPLOAD != null
        uses: shimataro/ssh-key-action@v2
        with:
          key: ${{ secrets.KEY_ARMBIAN_UPLOAD }}
          known_hosts: ${{ secrets.KNOWN_HOSTS_ARMBIAN_UPLOAD }}
          if_key_exists: replace

      - name: Check API rate limits
        run: |

          # install dependencies
          if ! command -v "gh" > /dev/null 2>&1; then
             sudo apt-get -y -qq install gh
          fi

          while true
            do
            API_CALLS_TOTAL=$(gh api -H "Accept: application/vnd.github+json" -H "X-GitHub-Api-Version: 2022-11-28" /rate_limit | jq -r '.rate.limit')
            API_CALLS_LEFT=$(gh api -H "Accept: application/vnd.github+json" -H "X-GitHub-Api-Version: 2022-11-28" /rate_limit | jq -r '.rate.remaining')
            PERCENT=$(( API_CALLS_LEFT * 100 / API_CALLS_TOTAL ))
            if (( $PERCENT > 20 )); then
                echo "API rate in good shape $PERCENT % free"
                exit 0
            fi
            echo "API rate lower then 20%, sleping 10m"
            sleep 10m
          done

          # show current api rate
          curl -s -H "Accept: application/vnd.github.v3+json" -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" https://api.github.com/rate_limit

      - name: Import GPG key
        env:
          GPG_KEY1: ${{ secrets.GPG_KEY1 }}
        if: env.GPG_KEY1 != null
        uses: crazy-max/ghaction-import-gpg@v6
        with:
          gpg_private_key: ${{ secrets.GPG_KEY1 }}
          passphrase: ${{ secrets.GPG_PASSPHRASE1 }}

      - name: Sign
        env:
          GPG_PASSPHRASE1: ${{ secrets.GPG_PASSPHRASE1 }}
        if: env.GPG_PASSPHRASE1 != null
        run: |

          echo ${{ secrets.GPG_PASSPHRASE1 }} | gpg --passphrase-fd 0 --armor --detach-sign --pinentry-mode loopback --batch --yes output/images/*/archive/*img*.xz

      #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!11
      - name: Check filelist
        run: |
          find output

      - name: "Convert image to burn"
        id: convertburn
        run: |
          if ! command -v "dtc" > /dev/null 2>&1; then
             sudo apt update \
             && sudo apt install device-tree-compiler -y
          fi
          if ! command -v "cc" > /dev/null 2>&1; then
             sudo apt update \
             && sudo apt install build-essential cpp -y
          fi
          if ! command -v "zip" > /dev/null 2>&1; then
             sudo apt update \
             && sudo apt install zip -y
          fi


          UBOOTDEB=$(find output | grep linux-u-boot | head -n 1)
          IMG=$(find output | grep  -e  ".*images.*Armbian.*img.xz$" | head -n 1)
          # Armbian_23.8.0-trunk.52.jh.3.5_Jethubj80_bookworm_current_6.1.32.burn.img

          cd tools

          DEB="../${UBOOTDEB}"
          dpkg -x "$DEB" output
          UBOOT=$(find output/usr/lib -name u-boot.nosd.bin | head -n 1)
          echo UBOOT: ${UBOOT}
          find ../output

          ### 'BETA=yes' 'BOARD=jethubj80' 'BRANCH=current' 'BUILD_DESKTOP=no' 'BUILD_MINIMAL=no' 'RELEASE=bookworm'
          EVALCMD=$(echo ${{ matrix.invocation }} | sed 's/jethome-images//')
          eval ${EVALCMD}
          echo ${EVALCMD}
          case ${BOARD} in
            jethubj100)
              ./convert.sh ../${IMG} d1 armbian compress output/usr/lib/linux*/u-boot.nosd.bin
              SUPPORTED="D1,D1P"
              ;;
            jethubj200)
              ./convert.sh ../${IMG} d2 armbian compress output/usr/lib/linux*/u-boot.nosd.bin
              SUPPORTED="D2"
              ;;
            jethubj80)
              ./convert.sh ../${IMG} h1 armbian compress output/usr/lib/linux*/u-boot.nosd.bin
              SUPPORTED="H1"
              ;;
            *)
              echo "Unsupported board" ${BOARD}
              echo "Error in convert: Unsupported board" ${BOARD} >> GITHUB_STEP_SUMMARY
              exit 200
              ;;
          esac
          rm -rf output/usr

          IMGBURN=$(find output | grep  -e  "Armbian.*burn.img.zip$" | head -n 1)
          echo IMGBURN: ${IMGBURN}
          [ -z "${IMGBURN}" ] && exit 50

          if [ "${BETA}" == "yes" ]; then
            case "${{ env.BUILD_REF }}" in
              main*)
                CHANNEL="nightly"
                ;;
              v2*)
                CHANNEL="rc"
                ;;
              *)
                CHANNEL="${BUILD_REF}"
                ;;
            esac

          else
            CHANNEL="release"
          fi

          echo "board=${BOARD}" >> $GITHUB_OUTPUT
          echo "brd=${BOARD:6}"  >> $GITHUB_OUTPUT
          echo "branch=${BRANCH}" >> $GITHUB_OUTPUT
          echo "channel=${CHANNEL}" >> $GITHUB_OUTPUT
          echo "release=${RELEASE}" >> $GITHUB_OUTPUT
          echo "supported=${SUPPORTED}" >> $GITHUB_OUTPUT
          echo "image=${IMG}" >> $GITHUB_OUTPUT
          echo "imageburn=tools/${IMGBURN}" >> $GITHUB_OUTPUT

      - name: Sign burn
        env:
          GPG_PASSPHRASE1: ${{ secrets.GPG_PASSPHRASE1 }}
        if: env.GPG_PASSPHRASE1 != null
        run: |
          echo ${{ secrets.GPG_PASSPHRASE1 }} | gpg --passphrase-fd 0 --armor --detach-sign --pinentry-mode loopback --batch --yes ${{ steps.convertburn.outputs.imageburn }}

      - name: "Upload artefacts"
        if: ${{ github.event.inputs.uploadtoserver == 'github' || github.event.inputs.uploadtoserver == 'both' }}
        uses: ncipollo/release-action@v1
        with:
          repo: "${{ env.RELEASE_REPOSITORY }}"
          artifacts: "output/images/*/*/Armbian_*.*"
          tag: "${{ needs.matrix_prep.outputs.version }}"
          omitBody: true
          replacesArtifacts: true
          omitName: true
          makeLatest: false
          omitPrereleaseDuringUpdate: true
          allowUpdates: true
          artifactErrorsFailBuild: false
          token: "${{ env.GH_TOKEN }}"

      - name: "Upload artefacts"
        if: ${{ github.event.inputs.uploadtoserver == 'github' || github.event.inputs.uploadtoserver == 'both' }}
        uses: ncipollo/release-action@v1
        with:
          repo: "${{ env.RELEASE_REPOSITORY }}"
          artifacts: "${{ steps.convertburn.outputs.imageburn }}*"
          tag: "${{ needs.matrix_prep.outputs.version }}"
          omitBody: true
          replacesArtifacts: true
          omitName: true
          makeLatest: false
          omitPrereleaseDuringUpdate: true
          allowUpdates: true
          artifactErrorsFailBuild: false
          token: "${{ env.GH_TOKEN }}"

      - name: Deploy to fw.jethome.ru (sdcard)
        if: ${{ github.event.inputs.uploadtoserver == 'both' || github.event.inputs.uploadtoserver == 'jethome' }}
        id: upload-sdcard
        uses: jethome-iot/actions/firmware-upload@master
        with:
          url: https://fw.jethome.ru
          fullslug: "JetHome.${{ steps.convertburn.outputs.brd }}.Armbian.${{ steps.convertburn.outputs.channel }}.${{ steps.convertburn.outputs.release }}.${{ steps.convertburn.outputs.branch }}"
          image_type: "sdcard"
          firmware_file: "${{ steps.convertburn.outputs.image }}"
          hashpgp_file: "${{ steps.convertburn.outputs.image }}.asc"
          version: "${{ needs.matrix_prep.outputs.version }}"
          force_overwrite: "true"
          generatefirmwareslot: "true"
          update_latest: "true"
          supported_devices: "${{ steps.convertburn.outputs.supported }}"
          FWUPLOAD: ${{ secrets.FWUPLOAD }}

      - name: Deploy to fw.jethome.ru (burn)
        if: ${{ github.event.inputs.uploadtoserver == 'both' || github.event.inputs.uploadtoserver == 'jethome' }}
        id: upload-burn
        uses: jethome-iot/actions/firmware-upload@master
        with:
          url: https://fw.jethome.ru
          fullslug: "JetHome.${{ steps.convertburn.outputs.brd }}.Armbian.${{ steps.convertburn.outputs.channel }}.${{ steps.convertburn.outputs.release }}.${{ steps.convertburn.outputs.branch }}"
          image_type: "burn"
          firmware_file: "${{ steps.convertburn.outputs.imageburn }}"
          hashpgp_file: "${{ steps.convertburn.outputs.imageburn }}.asc"
          version: "${{ needs.matrix_prep.outputs.version }}"
          generatefirmwareslot: "false"
          force_overwrite: "true"
          update_latest: "true"
          supported_devices: "${{ steps.convertburn.outputs.supported }}"
          FWUPLOAD: ${{ secrets.FWUPLOAD }}

      - name: "Runner clean ${{ needs.matrix_prep.outputs.version }}"
        if: always()
        run: sudo rm -rfv output/images userpatches/VERSION
  "build-images-chunk-3": # templated "build-images-chunk-3"
    needs: [ "matrix_prep", "all-artifacts-ready" ]
    timeout-minutes: 240
    if: ${{ !failure() && !cancelled() && ( github.repository_owner == 'jethome-iot' ) && ( needs.matrix_prep.outputs.images-chunk-not-empty-3 == 'yes' ) }} # <-- HERE: Chunk number.
    strategy:
      fail-fast: false # let other jobs try to complete if one fails
      matrix: ${{ fromJSON(needs.matrix_prep.outputs.images-chunk-json-3) }} # <-- HERE: Chunk number.
    name: ${{ matrix.desc || 'Empty I3' }} # <-- HERE: Chunk number.
    runs-on: ${{ matrix.runs_on }}
    steps:

      # cleaning self hosted runners
      #- name: "Runner clean ${{ needs.matrix_prep.outputs.version }}"
      #  uses: armbian/actions/runner-clean@main

      # cleanup the place where we will clone the userpatches repo, to avoid git going insane and cleaning everything later
      - name: Cleanup userpatches repo
        if: ${{ ( env.USERPATCHES_REPOSITORY != '' ) && ( env.USERPATCHES_REF != '' ) }}
        run: sudo rm -rf userpatches.repo

      - name: Checkout build repo
        uses: actions/checkout@v4
        with:
          repository: ${{ env.BUILD_REPOSITORY }}
          ref: ${{ needs.matrix_prep.outputs.build-sha1 }}
          fetch-depth: ${{ matrix.fdepth }}
          clean: false # true is default. it *will* delete the hosts /dev if mounted inside.

      # clone the userpatches repo (`armbian/os`)
      - name: "Checkout userpatches repo: ${{env.USERPATCHES_REPOSITORY}}#${{env.USERPATCHES_REF}}"
        uses: actions/checkout@v4
        if: ${{ ( env.USERPATCHES_REPOSITORY != '' ) && ( env.USERPATCHES_REF != '' ) }}
        with:
          repository: ${{ env.USERPATCHES_REPOSITORY }}
          ref: ${{ env.USERPATCHES_REF }}
          fetch-depth: ${{ matrix.fdepth }}
          clean: false # true is default.
          path: userpatches.repo

      - name: Checkout jethome-tools repository
        uses: actions/checkout@v4
        with:
          repository: jethome-ru/jethome-tools
          path: tools
          ref: convert_jhos

      - name: "Put userpatches in place, and remove userpatches repo"
        if: ${{ ( env.USERPATCHES_REPOSITORY != '' ) && ( env.USERPATCHES_REF != '' ) }}
        run: |
          mkdir -pv userpatches
          rsync -av userpatches.repo/${{env.USERPATCHES_DIR}}/. userpatches/
          rm -rf userpatches.repo
          echo ${{ needs.matrix_prep.outputs.version }} > userpatches/VERSION

      - name: "Cleanup leftover output"
        run: |
          sudo rm -f userpatches/VERSION

      - name: ${{matrix.desc}}
        id: build-one-image
        timeout-minutes: 300
        run: |
          # calculate loop from runner name
          if [ -z "${ImageOS}" ]; then
            USE_FIXED_LOOP_DEVICE=$(echo ${RUNNER_NAME} | rev | cut -d"-" -f1  | rev | sed 's/^0*//' | sed -e 's/^/\/dev\/loop/')
          fi
          bash ./compile.sh ${{ matrix.invocation }} REVISION="${{ needs.matrix_prep.outputs.version }}" USE_FIXED_LOOP_DEVICE="$USE_FIXED_LOOP_DEVICE" SHARE_LOG=yes MAKE_FOLDERS="archive" IMAGE_VERSION=${{ needs.matrix_prep.outputs.version }} ${{env.EXTRA_PARAMS_IMAGE}} ${{env.EXTRA_PARAMS_ALL_BUILDS}}

      - name: "Logs: ${{ steps.build-one-image.outputs.logs_url }}"
        if: always()
        run: |
          echo "Logs: ${{ steps.build-one-image.outputs.logs_url }}"

      - name: Install SSH key for storage
        env:
          KEY_ARMBIAN_UPLOAD: ${{ secrets.KEY_ARMBIAN_UPLOAD }}
        if: env.KEY_ARMBIAN_UPLOAD != null
        uses: shimataro/ssh-key-action@v2
        with:
          key: ${{ secrets.KEY_ARMBIAN_UPLOAD }}
          known_hosts: ${{ secrets.KNOWN_HOSTS_ARMBIAN_UPLOAD }}
          if_key_exists: replace

      - name: Check API rate limits
        run: |

          # install dependencies
          if ! command -v "gh" > /dev/null 2>&1; then
             sudo apt-get -y -qq install gh
          fi

          while true
            do
            API_CALLS_TOTAL=$(gh api -H "Accept: application/vnd.github+json" -H "X-GitHub-Api-Version: 2022-11-28" /rate_limit | jq -r '.rate.limit')
            API_CALLS_LEFT=$(gh api -H "Accept: application/vnd.github+json" -H "X-GitHub-Api-Version: 2022-11-28" /rate_limit | jq -r '.rate.remaining')
            PERCENT=$(( API_CALLS_LEFT * 100 / API_CALLS_TOTAL ))
            if (( $PERCENT > 20 )); then
                echo "API rate in good shape $PERCENT % free"
                exit 0
            fi
            echo "API rate lower then 20%, sleping 10m"
            sleep 10m
          done

          # show current api rate
          curl -s -H "Accept: application/vnd.github.v3+json" -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" https://api.github.com/rate_limit

      - name: Import GPG key
        env:
          GPG_KEY1: ${{ secrets.GPG_KEY1 }}
        if: env.GPG_KEY1 != null
        uses: crazy-max/ghaction-import-gpg@v6
        with:
          gpg_private_key: ${{ secrets.GPG_KEY1 }}
          passphrase: ${{ secrets.GPG_PASSPHRASE1 }}

      - name: Sign
        env:
          GPG_PASSPHRASE1: ${{ secrets.GPG_PASSPHRASE1 }}
        if: env.GPG_PASSPHRASE1 != null
        run: |

          echo ${{ secrets.GPG_PASSPHRASE1 }} | gpg --passphrase-fd 0 --armor --detach-sign --pinentry-mode loopback --batch --yes output/images/*/archive/*img*.xz

      #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!11
      - name: Check filelist
        run: |
          find output

      - name: "Convert image to burn"
        id: convertburn
        run: |
          if ! command -v "dtc" > /dev/null 2>&1; then
             sudo apt update \
             && sudo apt install device-tree-compiler -y
          fi
          if ! command -v "cc" > /dev/null 2>&1; then
             sudo apt update \
             && sudo apt install build-essential cpp -y
          fi
          if ! command -v "zip" > /dev/null 2>&1; then
             sudo apt update \
             && sudo apt install zip -y
          fi


          UBOOTDEB=$(find output | grep linux-u-boot | head -n 1)
          IMG=$(find output | grep  -e  ".*images.*Armbian.*img.xz$" | head -n 1)
          # Armbian_23.8.0-trunk.52.jh.3.5_Jethubj80_bookworm_current_6.1.32.burn.img

          cd tools

          DEB="../${UBOOTDEB}"
          dpkg -x "$DEB" output
          UBOOT=$(find output/usr/lib -name u-boot.nosd.bin | head -n 1)
          echo UBOOT: ${UBOOT}
          find ../output

          ### 'BETA=yes' 'BOARD=jethubj80' 'BRANCH=current' 'BUILD_DESKTOP=no' 'BUILD_MINIMAL=no' 'RELEASE=bookworm'
          EVALCMD=$(echo ${{ matrix.invocation }} | sed 's/jethome-images//')
          eval ${EVALCMD}
          echo ${EVALCMD}
          case ${BOARD} in
            jethubj100)
              ./convert.sh ../${IMG} d1 armbian compress output/usr/lib/linux*/u-boot.nosd.bin
              SUPPORTED="D1,D1P"
              ;;
            jethubj200)
              ./convert.sh ../${IMG} d2 armbian compress output/usr/lib/linux*/u-boot.nosd.bin
              SUPPORTED="D2"
              ;;
            jethubj80)
              ./convert.sh ../${IMG} h1 armbian compress output/usr/lib/linux*/u-boot.nosd.bin
              SUPPORTED="H1"
              ;;
            *)
              echo "Unsupported board" ${BOARD}
              echo "Error in convert: Unsupported board" ${BOARD} >> GITHUB_STEP_SUMMARY
              exit 200
              ;;
          esac
          rm -rf output/usr

          IMGBURN=$(find output | grep  -e  "Armbian.*burn.img.zip$" | head -n 1)
          echo IMGBURN: ${IMGBURN}
          [ -z "${IMGBURN}" ] && exit 50

          if [ "${BETA}" == "yes" ]; then
            case "${{ env.BUILD_REF }}" in
              main*)
                CHANNEL="nightly"
                ;;
              v2*)
                CHANNEL="rc"
                ;;
              *)
                CHANNEL="${BUILD_REF}"
                ;;
            esac

          else
            CHANNEL="release"
          fi

          echo "board=${BOARD}" >> $GITHUB_OUTPUT
          echo "brd=${BOARD:6}"  >> $GITHUB_OUTPUT
          echo "branch=${BRANCH}" >> $GITHUB_OUTPUT
          echo "channel=${CHANNEL}" >> $GITHUB_OUTPUT
          echo "release=${RELEASE}" >> $GITHUB_OUTPUT
          echo "supported=${SUPPORTED}" >> $GITHUB_OUTPUT
          echo "image=${IMG}" >> $GITHUB_OUTPUT
          echo "imageburn=tools/${IMGBURN}" >> $GITHUB_OUTPUT

      - name: Sign burn
        env:
          GPG_PASSPHRASE1: ${{ secrets.GPG_PASSPHRASE1 }}
        if: env.GPG_PASSPHRASE1 != null
        run: |
          echo ${{ secrets.GPG_PASSPHRASE1 }} | gpg --passphrase-fd 0 --armor --detach-sign --pinentry-mode loopback --batch --yes ${{ steps.convertburn.outputs.imageburn }}

      - name: "Upload artefacts"
        if: ${{ github.event.inputs.uploadtoserver == 'github' || github.event.inputs.uploadtoserver == 'both' }}
        uses: ncipollo/release-action@v1
        with:
          repo: "${{ env.RELEASE_REPOSITORY }}"
          artifacts: "output/images/*/*/Armbian_*.*"
          tag: "${{ needs.matrix_prep.outputs.version }}"
          omitBody: true
          replacesArtifacts: true
          omitName: true
          makeLatest: false
          omitPrereleaseDuringUpdate: true
          allowUpdates: true
          artifactErrorsFailBuild: false
          token: "${{ env.GH_TOKEN }}"

      - name: "Upload artefacts"
        if: ${{ github.event.inputs.uploadtoserver == 'github' || github.event.inputs.uploadtoserver == 'both' }}
        uses: ncipollo/release-action@v1
        with:
          repo: "${{ env.RELEASE_REPOSITORY }}"
          artifacts: "${{ steps.convertburn.outputs.imageburn }}*"
          tag: "${{ needs.matrix_prep.outputs.version }}"
          omitBody: true
          replacesArtifacts: true
          omitName: true
          makeLatest: false
          omitPrereleaseDuringUpdate: true
          allowUpdates: true
          artifactErrorsFailBuild: false
          token: "${{ env.GH_TOKEN }}"

      - name: Deploy to fw.jethome.ru (sdcard)
        if: ${{ github.event.inputs.uploadtoserver == 'both' || github.event.inputs.uploadtoserver == 'jethome' }}
        id: upload-sdcard
        uses: jethome-iot/actions/firmware-upload@master
        with:
          url: https://fw.jethome.ru
          fullslug: "JetHome.${{ steps.convertburn.outputs.brd }}.Armbian.${{ steps.convertburn.outputs.channel }}.${{ steps.convertburn.outputs.release }}.${{ steps.convertburn.outputs.branch }}"
          image_type: "sdcard"
          firmware_file: "${{ steps.convertburn.outputs.image }}"
          hashpgp_file: "${{ steps.convertburn.outputs.image }}.asc"
          version: "${{ needs.matrix_prep.outputs.version }}"
          force_overwrite: "true"
          generatefirmwareslot: "true"
          update_latest: "true"
          supported_devices: "${{ steps.convertburn.outputs.supported }}"
          FWUPLOAD: ${{ secrets.FWUPLOAD }}

      - name: Deploy to fw.jethome.ru (burn)
        if: ${{ github.event.inputs.uploadtoserver == 'both' || github.event.inputs.uploadtoserver == 'jethome' }}
        id: upload-burn
        uses: jethome-iot/actions/firmware-upload@master
        with:
          url: https://fw.jethome.ru
          fullslug: "JetHome.${{ steps.convertburn.outputs.brd }}.Armbian.${{ steps.convertburn.outputs.channel }}.${{ steps.convertburn.outputs.release }}.${{ steps.convertburn.outputs.branch }}"
          image_type: "burn"
          firmware_file: "${{ steps.convertburn.outputs.imageburn }}"
          hashpgp_file: "${{ steps.convertburn.outputs.imageburn }}.asc"
          version: "${{ needs.matrix_prep.outputs.version }}"
          generatefirmwareslot: "false"
          force_overwrite: "true"
          update_latest: "true"
          supported_devices: "${{ steps.convertburn.outputs.supported }}"
          FWUPLOAD: ${{ secrets.FWUPLOAD }}

      - name: "Runner clean ${{ needs.matrix_prep.outputs.version }}"
        if: always()
        run: sudo rm -rfv output/images userpatches/VERSION
  "build-images-chunk-4": # templated "build-images-chunk-4"
    needs: [ "matrix_prep", "all-artifacts-ready" ]
    timeout-minutes: 240
    if: ${{ !failure() && !cancelled() && ( github.repository_owner == 'jethome-iot' ) && ( needs.matrix_prep.outputs.images-chunk-not-empty-4 == 'yes' ) }} # <-- HERE: Chunk number.
    strategy:
      fail-fast: false # let other jobs try to complete if one fails
      matrix: ${{ fromJSON(needs.matrix_prep.outputs.images-chunk-json-4) }} # <-- HERE: Chunk number.
    name: ${{ matrix.desc || 'Empty I4' }} # <-- HERE: Chunk number.
    runs-on: ${{ matrix.runs_on }}
    steps:

      # cleaning self hosted runners
      #- name: "Runner clean ${{ needs.matrix_prep.outputs.version }}"
      #  uses: armbian/actions/runner-clean@main

      # cleanup the place where we will clone the userpatches repo, to avoid git going insane and cleaning everything later
      - name: Cleanup userpatches repo
        if: ${{ ( env.USERPATCHES_REPOSITORY != '' ) && ( env.USERPATCHES_REF != '' ) }}
        run: sudo rm -rf userpatches.repo

      - name: Checkout build repo
        uses: actions/checkout@v4
        with:
          repository: ${{ env.BUILD_REPOSITORY }}
          ref: ${{ needs.matrix_prep.outputs.build-sha1 }}
          fetch-depth: ${{ matrix.fdepth }}
          clean: false # true is default. it *will* delete the hosts /dev if mounted inside.

      # clone the userpatches repo (`armbian/os`)
      - name: "Checkout userpatches repo: ${{env.USERPATCHES_REPOSITORY}}#${{env.USERPATCHES_REF}}"
        uses: actions/checkout@v4
        if: ${{ ( env.USERPATCHES_REPOSITORY != '' ) && ( env.USERPATCHES_REF != '' ) }}
        with:
          repository: ${{ env.USERPATCHES_REPOSITORY }}
          ref: ${{ env.USERPATCHES_REF }}
          fetch-depth: ${{ matrix.fdepth }}
          clean: false # true is default.
          path: userpatches.repo

      - name: Checkout jethome-tools repository
        uses: actions/checkout@v4
        with:
          repository: jethome-ru/jethome-tools
          path: tools
          ref: convert_jhos

      - name: "Put userpatches in place, and remove userpatches repo"
        if: ${{ ( env.USERPATCHES_REPOSITORY != '' ) && ( env.USERPATCHES_REF != '' ) }}
        run: |
          mkdir -pv userpatches
          rsync -av userpatches.repo/${{env.USERPATCHES_DIR}}/. userpatches/
          rm -rf userpatches.repo
          echo ${{ needs.matrix_prep.outputs.version }} > userpatches/VERSION

      - name: "Cleanup leftover output"
        run: |
          sudo rm -f userpatches/VERSION

      - name: ${{matrix.desc}}
        id: build-one-image
        timeout-minutes: 300
        run: |
          # calculate loop from runner name
          if [ -z "${ImageOS}" ]; then
            USE_FIXED_LOOP_DEVICE=$(echo ${RUNNER_NAME} | rev | cut -d"-" -f1  | rev | sed 's/^0*//' | sed -e 's/^/\/dev\/loop/')
          fi
          bash ./compile.sh ${{ matrix.invocation }} REVISION="${{ needs.matrix_prep.outputs.version }}" USE_FIXED_LOOP_DEVICE="$USE_FIXED_LOOP_DEVICE" SHARE_LOG=yes MAKE_FOLDERS="archive" IMAGE_VERSION=${{ needs.matrix_prep.outputs.version }} ${{env.EXTRA_PARAMS_IMAGE}} ${{env.EXTRA_PARAMS_ALL_BUILDS}}

      - name: "Logs: ${{ steps.build-one-image.outputs.logs_url }}"
        if: always()
        run: |
          echo "Logs: ${{ steps.build-one-image.outputs.logs_url }}"

      - name: Install SSH key for storage
        env:
          KEY_ARMBIAN_UPLOAD: ${{ secrets.KEY_ARMBIAN_UPLOAD }}
        if: env.KEY_ARMBIAN_UPLOAD != null
        uses: shimataro/ssh-key-action@v2
        with:
          key: ${{ secrets.KEY_ARMBIAN_UPLOAD }}
          known_hosts: ${{ secrets.KNOWN_HOSTS_ARMBIAN_UPLOAD }}
          if_key_exists: replace

      - name: Check API rate limits
        run: |

          # install dependencies
          if ! command -v "gh" > /dev/null 2>&1; then
             sudo apt-get -y -qq install gh
          fi

          while true
            do
            API_CALLS_TOTAL=$(gh api -H "Accept: application/vnd.github+json" -H "X-GitHub-Api-Version: 2022-11-28" /rate_limit | jq -r '.rate.limit')
            API_CALLS_LEFT=$(gh api -H "Accept: application/vnd.github+json" -H "X-GitHub-Api-Version: 2022-11-28" /rate_limit | jq -r '.rate.remaining')
            PERCENT=$(( API_CALLS_LEFT * 100 / API_CALLS_TOTAL ))
            if (( $PERCENT > 20 )); then
                echo "API rate in good shape $PERCENT % free"
                exit 0
            fi
            echo "API rate lower then 20%, sleping 10m"
            sleep 10m
          done

          # show current api rate
          curl -s -H "Accept: application/vnd.github.v3+json" -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" https://api.github.com/rate_limit

      - name: Import GPG key
        env:
          GPG_KEY1: ${{ secrets.GPG_KEY1 }}
        if: env.GPG_KEY1 != null
        uses: crazy-max/ghaction-import-gpg@v6
        with:
          gpg_private_key: ${{ secrets.GPG_KEY1 }}
          passphrase: ${{ secrets.GPG_PASSPHRASE1 }}

      - name: Sign
        env:
          GPG_PASSPHRASE1: ${{ secrets.GPG_PASSPHRASE1 }}
        if: env.GPG_PASSPHRASE1 != null
        run: |

          echo ${{ secrets.GPG_PASSPHRASE1 }} | gpg --passphrase-fd 0 --armor --detach-sign --pinentry-mode loopback --batch --yes output/images/*/archive/*img*.xz

      #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!11
      - name: Check filelist
        run: |
          find output

      - name: "Convert image to burn"
        id: convertburn
        run: |
          if ! command -v "dtc" > /dev/null 2>&1; then
             sudo apt update \
             && sudo apt install device-tree-compiler -y
          fi
          if ! command -v "cc" > /dev/null 2>&1; then
             sudo apt update \
             && sudo apt install build-essential cpp -y
          fi
          if ! command -v "zip" > /dev/null 2>&1; then
             sudo apt update \
             && sudo apt install zip -y
          fi


          UBOOTDEB=$(find output | grep linux-u-boot | head -n 1)
          IMG=$(find output | grep  -e  ".*images.*Armbian.*img.xz$" | head -n 1)
          # Armbian_23.8.0-trunk.52.jh.3.5_Jethubj80_bookworm_current_6.1.32.burn.img

          cd tools

          DEB="../${UBOOTDEB}"
          dpkg -x "$DEB" output
          UBOOT=$(find output/usr/lib -name u-boot.nosd.bin | head -n 1)
          echo UBOOT: ${UBOOT}
          find ../output

          ### 'BETA=yes' 'BOARD=jethubj80' 'BRANCH=current' 'BUILD_DESKTOP=no' 'BUILD_MINIMAL=no' 'RELEASE=bookworm'
          EVALCMD=$(echo ${{ matrix.invocation }} | sed 's/jethome-images//')
          eval ${EVALCMD}
          echo ${EVALCMD}
          case ${BOARD} in
            jethubj100)
              ./convert.sh ../${IMG} d1 armbian compress output/usr/lib/linux*/u-boot.nosd.bin
              SUPPORTED="D1,D1P"
              ;;
            jethubj200)
              ./convert.sh ../${IMG} d2 armbian compress output/usr/lib/linux*/u-boot.nosd.bin
              SUPPORTED="D2"
              ;;
            jethubj80)
              ./convert.sh ../${IMG} h1 armbian compress output/usr/lib/linux*/u-boot.nosd.bin
              SUPPORTED="H1"
              ;;
            *)
              echo "Unsupported board" ${BOARD}
              echo "Error in convert: Unsupported board" ${BOARD} >> GITHUB_STEP_SUMMARY
              exit 200
              ;;
          esac
          rm -rf output/usr

          IMGBURN=$(find output | grep  -e  "Armbian.*burn.img.zip$" | head -n 1)
          echo IMGBURN: ${IMGBURN}
          [ -z "${IMGBURN}" ] && exit 50

          if [ "${BETA}" == "yes" ]; then
            case "${{ env.BUILD_REF }}" in
              main*)
                CHANNEL="nightly"
                ;;
              v2*)
                CHANNEL="rc"
                ;;
              *)
                CHANNEL="${BUILD_REF}"
                ;;
            esac

          else
            CHANNEL="release"
          fi

          echo "board=${BOARD}" >> $GITHUB_OUTPUT
          echo "brd=${BOARD:6}"  >> $GITHUB_OUTPUT
          echo "branch=${BRANCH}" >> $GITHUB_OUTPUT
          echo "channel=${CHANNEL}" >> $GITHUB_OUTPUT
          echo "release=${RELEASE}" >> $GITHUB_OUTPUT
          echo "supported=${SUPPORTED}" >> $GITHUB_OUTPUT
          echo "image=${IMG}" >> $GITHUB_OUTPUT
          echo "imageburn=tools/${IMGBURN}" >> $GITHUB_OUTPUT

      - name: Sign burn
        env:
          GPG_PASSPHRASE1: ${{ secrets.GPG_PASSPHRASE1 }}
        if: env.GPG_PASSPHRASE1 != null
        run: |
          echo ${{ secrets.GPG_PASSPHRASE1 }} | gpg --passphrase-fd 0 --armor --detach-sign --pinentry-mode loopback --batch --yes ${{ steps.convertburn.outputs.imageburn }}

      - name: "Upload artefacts"
        if: ${{ github.event.inputs.uploadtoserver == 'github' || github.event.inputs.uploadtoserver == 'both' }}
        uses: ncipollo/release-action@v1
        with:
          repo: "${{ env.RELEASE_REPOSITORY }}"
          artifacts: "output/images/*/*/Armbian_*.*"
          tag: "${{ needs.matrix_prep.outputs.version }}"
          omitBody: true
          replacesArtifacts: true
          omitName: true
          makeLatest: false
          omitPrereleaseDuringUpdate: true
          allowUpdates: true
          artifactErrorsFailBuild: false
          token: "${{ env.GH_TOKEN }}"

      - name: "Upload artefacts"
        if: ${{ github.event.inputs.uploadtoserver == 'github' || github.event.inputs.uploadtoserver == 'both' }}
        uses: ncipollo/release-action@v1
        with:
          repo: "${{ env.RELEASE_REPOSITORY }}"
          artifacts: "${{ steps.convertburn.outputs.imageburn }}*"
          tag: "${{ needs.matrix_prep.outputs.version }}"
          omitBody: true
          replacesArtifacts: true
          omitName: true
          makeLatest: false
          omitPrereleaseDuringUpdate: true
          allowUpdates: true
          artifactErrorsFailBuild: false
          token: "${{ env.GH_TOKEN }}"

      - name: Deploy to fw.jethome.ru (sdcard)
        if: ${{ github.event.inputs.uploadtoserver == 'both' || github.event.inputs.uploadtoserver == 'jethome' }}
        id: upload-sdcard
        uses: jethome-iot/actions/firmware-upload@master
        with:
          url: https://fw.jethome.ru
          fullslug: "JetHome.${{ steps.convertburn.outputs.brd }}.Armbian.${{ steps.convertburn.outputs.channel }}.${{ steps.convertburn.outputs.release }}.${{ steps.convertburn.outputs.branch }}"
          image_type: "sdcard"
          firmware_file: "${{ steps.convertburn.outputs.image }}"
          hashpgp_file: "${{ steps.convertburn.outputs.image }}.asc"
          version: "${{ needs.matrix_prep.outputs.version }}"
          force_overwrite: "true"
          generatefirmwareslot: "true"
          update_latest: "true"
          supported_devices: "${{ steps.convertburn.outputs.supported }}"
          FWUPLOAD: ${{ secrets.FWUPLOAD }}

      - name: Deploy to fw.jethome.ru (burn)
        if: ${{ github.event.inputs.uploadtoserver == 'both' || github.event.inputs.uploadtoserver == 'jethome' }}
        id: upload-burn
        uses: jethome-iot/actions/firmware-upload@master
        with:
          url: https://fw.jethome.ru
          fullslug: "JetHome.${{ steps.convertburn.outputs.brd }}.Armbian.${{ steps.convertburn.outputs.channel }}.${{ steps.convertburn.outputs.release }}.${{ steps.convertburn.outputs.branch }}"
          image_type: "burn"
          firmware_file: "${{ steps.convertburn.outputs.imageburn }}"
          hashpgp_file: "${{ steps.convertburn.outputs.imageburn }}.asc"
          version: "${{ needs.matrix_prep.outputs.version }}"
          generatefirmwareslot: "false"
          force_overwrite: "true"
          update_latest: "true"
          supported_devices: "${{ steps.convertburn.outputs.supported }}"
          FWUPLOAD: ${{ secrets.FWUPLOAD }}

      - name: "Runner clean ${{ needs.matrix_prep.outputs.version }}"
        if: always()
        run: sudo rm -rfv output/images userpatches/VERSION
  "build-images-chunk-5": # templated "build-images-chunk-5"
    needs: [ "matrix_prep", "all-artifacts-ready" ]
    timeout-minutes: 240
    if: ${{ !failure() && !cancelled() && ( github.repository_owner == 'jethome-iot' ) && ( needs.matrix_prep.outputs.images-chunk-not-empty-5 == 'yes' ) }} # <-- HERE: Chunk number.
    strategy:
      fail-fast: false # let other jobs try to complete if one fails
      matrix: ${{ fromJSON(needs.matrix_prep.outputs.images-chunk-json-5) }} # <-- HERE: Chunk number.
    name: ${{ matrix.desc || 'Empty I5' }} # <-- HERE: Chunk number.
    runs-on: ${{ matrix.runs_on }}
    steps:

      # cleaning self hosted runners
      #- name: "Runner clean ${{ needs.matrix_prep.outputs.version }}"
      #  uses: armbian/actions/runner-clean@main

      # cleanup the place where we will clone the userpatches repo, to avoid git going insane and cleaning everything later
      - name: Cleanup userpatches repo
        if: ${{ ( env.USERPATCHES_REPOSITORY != '' ) && ( env.USERPATCHES_REF != '' ) }}
        run: sudo rm -rf userpatches.repo

      - name: Checkout build repo
        uses: actions/checkout@v4
        with:
          repository: ${{ env.BUILD_REPOSITORY }}
          ref: ${{ needs.matrix_prep.outputs.build-sha1 }}
          fetch-depth: ${{ matrix.fdepth }}
          clean: false # true is default. it *will* delete the hosts /dev if mounted inside.

      # clone the userpatches repo (`armbian/os`)
      - name: "Checkout userpatches repo: ${{env.USERPATCHES_REPOSITORY}}#${{env.USERPATCHES_REF}}"
        uses: actions/checkout@v4
        if: ${{ ( env.USERPATCHES_REPOSITORY != '' ) && ( env.USERPATCHES_REF != '' ) }}
        with:
          repository: ${{ env.USERPATCHES_REPOSITORY }}
          ref: ${{ env.USERPATCHES_REF }}
          fetch-depth: ${{ matrix.fdepth }}
          clean: false # true is default.
          path: userpatches.repo

      - name: Checkout jethome-tools repository
        uses: actions/checkout@v4
        with:
          repository: jethome-ru/jethome-tools
          path: tools
          ref: convert_jhos

      - name: "Put userpatches in place, and remove userpatches repo"
        if: ${{ ( env.USERPATCHES_REPOSITORY != '' ) && ( env.USERPATCHES_REF != '' ) }}
        run: |
          mkdir -pv userpatches
          rsync -av userpatches.repo/${{env.USERPATCHES_DIR}}/. userpatches/
          rm -rf userpatches.repo
          echo ${{ needs.matrix_prep.outputs.version }} > userpatches/VERSION

      - name: "Cleanup leftover output"
        run: |
          sudo rm -f userpatches/VERSION

      - name: ${{matrix.desc}}
        id: build-one-image
        timeout-minutes: 300
        run: |
          # calculate loop from runner name
          if [ -z "${ImageOS}" ]; then
            USE_FIXED_LOOP_DEVICE=$(echo ${RUNNER_NAME} | rev | cut -d"-" -f1  | rev | sed 's/^0*//' | sed -e 's/^/\/dev\/loop/')
          fi
          bash ./compile.sh ${{ matrix.invocation }} REVISION="${{ needs.matrix_prep.outputs.version }}" USE_FIXED_LOOP_DEVICE="$USE_FIXED_LOOP_DEVICE" SHARE_LOG=yes MAKE_FOLDERS="archive" IMAGE_VERSION=${{ needs.matrix_prep.outputs.version }} ${{env.EXTRA_PARAMS_IMAGE}} ${{env.EXTRA_PARAMS_ALL_BUILDS}}

      - name: "Logs: ${{ steps.build-one-image.outputs.logs_url }}"
        if: always()
        run: |
          echo "Logs: ${{ steps.build-one-image.outputs.logs_url }}"

      - name: Install SSH key for storage
        env:
          KEY_ARMBIAN_UPLOAD: ${{ secrets.KEY_ARMBIAN_UPLOAD }}
        if: env.KEY_ARMBIAN_UPLOAD != null
        uses: shimataro/ssh-key-action@v2
        with:
          key: ${{ secrets.KEY_ARMBIAN_UPLOAD }}
          known_hosts: ${{ secrets.KNOWN_HOSTS_ARMBIAN_UPLOAD }}
          if_key_exists: replace

      - name: Check API rate limits
        run: |

          # install dependencies
          if ! command -v "gh" > /dev/null 2>&1; then
             sudo apt-get -y -qq install gh
          fi

          while true
            do
            API_CALLS_TOTAL=$(gh api -H "Accept: application/vnd.github+json" -H "X-GitHub-Api-Version: 2022-11-28" /rate_limit | jq -r '.rate.limit')
            API_CALLS_LEFT=$(gh api -H "Accept: application/vnd.github+json" -H "X-GitHub-Api-Version: 2022-11-28" /rate_limit | jq -r '.rate.remaining')
            PERCENT=$(( API_CALLS_LEFT * 100 / API_CALLS_TOTAL ))
            if (( $PERCENT > 20 )); then
                echo "API rate in good shape $PERCENT % free"
                exit 0
            fi
            echo "API rate lower then 20%, sleping 10m"
            sleep 10m
          done

          # show current api rate
          curl -s -H "Accept: application/vnd.github.v3+json" -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" https://api.github.com/rate_limit

      - name: Import GPG key
        env:
          GPG_KEY1: ${{ secrets.GPG_KEY1 }}
        if: env.GPG_KEY1 != null
        uses: crazy-max/ghaction-import-gpg@v6
        with:
          gpg_private_key: ${{ secrets.GPG_KEY1 }}
          passphrase: ${{ secrets.GPG_PASSPHRASE1 }}

      - name: Sign
        env:
          GPG_PASSPHRASE1: ${{ secrets.GPG_PASSPHRASE1 }}
        if: env.GPG_PASSPHRASE1 != null
        run: |

          echo ${{ secrets.GPG_PASSPHRASE1 }} | gpg --passphrase-fd 0 --armor --detach-sign --pinentry-mode loopback --batch --yes output/images/*/archive/*img*.xz

      #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!11
      - name: Check filelist
        run: |
          find output

      - name: "Convert image to burn"
        id: convertburn
        run: |
          if ! command -v "dtc" > /dev/null 2>&1; then
             sudo apt update \
             && sudo apt install device-tree-compiler -y
          fi
          if ! command -v "cc" > /dev/null 2>&1; then
             sudo apt update \
             && sudo apt install build-essential cpp -y
          fi
          if ! command -v "zip" > /dev/null 2>&1; then
             sudo apt update \
             && sudo apt install zip -y
          fi


          UBOOTDEB=$(find output | grep linux-u-boot | head -n 1)
          IMG=$(find output | grep  -e  ".*images.*Armbian.*img.xz$" | head -n 1)
          # Armbian_23.8.0-trunk.52.jh.3.5_Jethubj80_bookworm_current_6.1.32.burn.img

          cd tools

          DEB="../${UBOOTDEB}"
          dpkg -x "$DEB" output
          UBOOT=$(find output/usr/lib -name u-boot.nosd.bin | head -n 1)
          echo UBOOT: ${UBOOT}
          find ../output

          ### 'BETA=yes' 'BOARD=jethubj80' 'BRANCH=current' 'BUILD_DESKTOP=no' 'BUILD_MINIMAL=no' 'RELEASE=bookworm'
          EVALCMD=$(echo ${{ matrix.invocation }} | sed 's/jethome-images//')
          eval ${EVALCMD}
          echo ${EVALCMD}
          case ${BOARD} in
            jethubj100)
              ./convert.sh ../${IMG} d1 armbian compress output/usr/lib/linux*/u-boot.nosd.bin
              SUPPORTED="D1,D1P"
              ;;
            jethubj200)
              ./convert.sh ../${IMG} d2 armbian compress output/usr/lib/linux*/u-boot.nosd.bin
              SUPPORTED="D2"
              ;;
            jethubj80)
              ./convert.sh ../${IMG} h1 armbian compress output/usr/lib/linux*/u-boot.nosd.bin
              SUPPORTED="H1"
              ;;
            *)
              echo "Unsupported board" ${BOARD}
              echo "Error in convert: Unsupported board" ${BOARD} >> GITHUB_STEP_SUMMARY
              exit 200
              ;;
          esac
          rm -rf output/usr

          IMGBURN=$(find output | grep  -e  "Armbian.*burn.img.zip$" | head -n 1)
          echo IMGBURN: ${IMGBURN}
          [ -z "${IMGBURN}" ] && exit 50

          if [ "${BETA}" == "yes" ]; then
            case "${{ env.BUILD_REF }}" in
              main*)
                CHANNEL="nightly"
                ;;
              v2*)
                CHANNEL="rc"
                ;;
              *)
                CHANNEL="${BUILD_REF}"
                ;;
            esac

          else
            CHANNEL="release"
          fi

          echo "board=${BOARD}" >> $GITHUB_OUTPUT
          echo "brd=${BOARD:6}"  >> $GITHUB_OUTPUT
          echo "branch=${BRANCH}" >> $GITHUB_OUTPUT
          echo "channel=${CHANNEL}" >> $GITHUB_OUTPUT
          echo "release=${RELEASE}" >> $GITHUB_OUTPUT
          echo "supported=${SUPPORTED}" >> $GITHUB_OUTPUT
          echo "image=${IMG}" >> $GITHUB_OUTPUT
          echo "imageburn=tools/${IMGBURN}" >> $GITHUB_OUTPUT

      - name: Sign burn
        env:
          GPG_PASSPHRASE1: ${{ secrets.GPG_PASSPHRASE1 }}
        if: env.GPG_PASSPHRASE1 != null
        run: |
          echo ${{ secrets.GPG_PASSPHRASE1 }} | gpg --passphrase-fd 0 --armor --detach-sign --pinentry-mode loopback --batch --yes ${{ steps.convertburn.outputs.imageburn }}

      - name: "Upload artefacts"
        if: ${{ github.event.inputs.uploadtoserver == 'github' || github.event.inputs.uploadtoserver == 'both' }}
        uses: ncipollo/release-action@v1
        with:
          repo: "${{ env.RELEASE_REPOSITORY }}"
          artifacts: "output/images/*/*/Armbian_*.*"
          tag: "${{ needs.matrix_prep.outputs.version }}"
          omitBody: true
          replacesArtifacts: true
          omitName: true
          makeLatest: false
          omitPrereleaseDuringUpdate: true
          allowUpdates: true
          artifactErrorsFailBuild: false
          token: "${{ env.GH_TOKEN }}"

      - name: "Upload artefacts"
        if: ${{ github.event.inputs.uploadtoserver == 'github' || github.event.inputs.uploadtoserver == 'both' }}
        uses: ncipollo/release-action@v1
        with:
          repo: "${{ env.RELEASE_REPOSITORY }}"
          artifacts: "${{ steps.convertburn.outputs.imageburn }}*"
          tag: "${{ needs.matrix_prep.outputs.version }}"
          omitBody: true
          replacesArtifacts: true
          omitName: true
          makeLatest: false
          omitPrereleaseDuringUpdate: true
          allowUpdates: true
          artifactErrorsFailBuild: false
          token: "${{ env.GH_TOKEN }}"

      - name: Deploy to fw.jethome.ru (sdcard)
        if: ${{ github.event.inputs.uploadtoserver == 'both' || github.event.inputs.uploadtoserver == 'jethome' }}
        id: upload-sdcard
        uses: jethome-iot/actions/firmware-upload@master
        with:
          url: https://fw.jethome.ru
          fullslug: "JetHome.${{ steps.convertburn.outputs.brd }}.Armbian.${{ steps.convertburn.outputs.channel }}.${{ steps.convertburn.outputs.release }}.${{ steps.convertburn.outputs.branch }}"
          image_type: "sdcard"
          firmware_file: "${{ steps.convertburn.outputs.image }}"
          hashpgp_file: "${{ steps.convertburn.outputs.image }}.asc"
          version: "${{ needs.matrix_prep.outputs.version }}"
          force_overwrite: "true"
          generatefirmwareslot: "true"
          update_latest: "true"
          supported_devices: "${{ steps.convertburn.outputs.supported }}"
          FWUPLOAD: ${{ secrets.FWUPLOAD }}

      - name: Deploy to fw.jethome.ru (burn)
        if: ${{ github.event.inputs.uploadtoserver == 'both' || github.event.inputs.uploadtoserver == 'jethome' }}
        id: upload-burn
        uses: jethome-iot/actions/firmware-upload@master
        with:
          url: https://fw.jethome.ru
          fullslug: "JetHome.${{ steps.convertburn.outputs.brd }}.Armbian.${{ steps.convertburn.outputs.channel }}.${{ steps.convertburn.outputs.release }}.${{ steps.convertburn.outputs.branch }}"
          image_type: "burn"
          firmware_file: "${{ steps.convertburn.outputs.imageburn }}"
          hashpgp_file: "${{ steps.convertburn.outputs.imageburn }}.asc"
          version: "${{ needs.matrix_prep.outputs.version }}"
          generatefirmwareslot: "false"
          force_overwrite: "true"
          update_latest: "true"
          supported_devices: "${{ steps.convertburn.outputs.supported }}"
          FWUPLOAD: ${{ secrets.FWUPLOAD }}

      - name: "Runner clean ${{ needs.matrix_prep.outputs.version }}"
        if: always()
        run: sudo rm -rfv output/images userpatches/VERSION
  "build-images-chunk-6": # templated "build-images-chunk-6"
    needs: [ "matrix_prep", "all-artifacts-ready" ]
    timeout-minutes: 240
    if: ${{ !failure() && !cancelled() && ( github.repository_owner == 'jethome-iot' ) && ( needs.matrix_prep.outputs.images-chunk-not-empty-6 == 'yes' ) }} # <-- HERE: Chunk number.
    strategy:
      fail-fast: false # let other jobs try to complete if one fails
      matrix: ${{ fromJSON(needs.matrix_prep.outputs.images-chunk-json-6) }} # <-- HERE: Chunk number.
    name: ${{ matrix.desc || 'Empty I6' }} # <-- HERE: Chunk number.
    runs-on: ${{ matrix.runs_on }}
    steps:

      # cleaning self hosted runners
      #- name: "Runner clean ${{ needs.matrix_prep.outputs.version }}"
      #  uses: armbian/actions/runner-clean@main

      # cleanup the place where we will clone the userpatches repo, to avoid git going insane and cleaning everything later
      - name: Cleanup userpatches repo
        if: ${{ ( env.USERPATCHES_REPOSITORY != '' ) && ( env.USERPATCHES_REF != '' ) }}
        run: sudo rm -rf userpatches.repo

      - name: Checkout build repo
        uses: actions/checkout@v4
        with:
          repository: ${{ env.BUILD_REPOSITORY }}
          ref: ${{ needs.matrix_prep.outputs.build-sha1 }}
          fetch-depth: ${{ matrix.fdepth }}
          clean: false # true is default. it *will* delete the hosts /dev if mounted inside.

      # clone the userpatches repo (`armbian/os`)
      - name: "Checkout userpatches repo: ${{env.USERPATCHES_REPOSITORY}}#${{env.USERPATCHES_REF}}"
        uses: actions/checkout@v4
        if: ${{ ( env.USERPATCHES_REPOSITORY != '' ) && ( env.USERPATCHES_REF != '' ) }}
        with:
          repository: ${{ env.USERPATCHES_REPOSITORY }}
          ref: ${{ env.USERPATCHES_REF }}
          fetch-depth: ${{ matrix.fdepth }}
          clean: false # true is default.
          path: userpatches.repo

      - name: Checkout jethome-tools repository
        uses: actions/checkout@v4
        with:
          repository: jethome-ru/jethome-tools
          path: tools
          ref: convert_jhos

      - name: "Put userpatches in place, and remove userpatches repo"
        if: ${{ ( env.USERPATCHES_REPOSITORY != '' ) && ( env.USERPATCHES_REF != '' ) }}
        run: |
          mkdir -pv userpatches
          rsync -av userpatches.repo/${{env.USERPATCHES_DIR}}/. userpatches/
          rm -rf userpatches.repo
          echo ${{ needs.matrix_prep.outputs.version }} > userpatches/VERSION

      - name: "Cleanup leftover output"
        run: |
          sudo rm -f userpatches/VERSION

      - name: ${{matrix.desc}}
        id: build-one-image
        timeout-minutes: 300
        run: |
          # calculate loop from runner name
          if [ -z "${ImageOS}" ]; then
            USE_FIXED_LOOP_DEVICE=$(echo ${RUNNER_NAME} | rev | cut -d"-" -f1  | rev | sed 's/^0*//' | sed -e 's/^/\/dev\/loop/')
          fi
          bash ./compile.sh ${{ matrix.invocation }} REVISION="${{ needs.matrix_prep.outputs.version }}" USE_FIXED_LOOP_DEVICE="$USE_FIXED_LOOP_DEVICE" SHARE_LOG=yes MAKE_FOLDERS="archive" IMAGE_VERSION=${{ needs.matrix_prep.outputs.version }} ${{env.EXTRA_PARAMS_IMAGE}} ${{env.EXTRA_PARAMS_ALL_BUILDS}}

      - name: "Logs: ${{ steps.build-one-image.outputs.logs_url }}"
        if: always()
        run: |
          echo "Logs: ${{ steps.build-one-image.outputs.logs_url }}"

      - name: Install SSH key for storage
        env:
          KEY_ARMBIAN_UPLOAD: ${{ secrets.KEY_ARMBIAN_UPLOAD }}
        if: env.KEY_ARMBIAN_UPLOAD != null
        uses: shimataro/ssh-key-action@v2
        with:
          key: ${{ secrets.KEY_ARMBIAN_UPLOAD }}
          known_hosts: ${{ secrets.KNOWN_HOSTS_ARMBIAN_UPLOAD }}
          if_key_exists: replace

      - name: Check API rate limits
        run: |

          # install dependencies
          if ! command -v "gh" > /dev/null 2>&1; then
             sudo apt-get -y -qq install gh
          fi

          while true
            do
            API_CALLS_TOTAL=$(gh api -H "Accept: application/vnd.github+json" -H "X-GitHub-Api-Version: 2022-11-28" /rate_limit | jq -r '.rate.limit')
            API_CALLS_LEFT=$(gh api -H "Accept: application/vnd.github+json" -H "X-GitHub-Api-Version: 2022-11-28" /rate_limit | jq -r '.rate.remaining')
            PERCENT=$(( API_CALLS_LEFT * 100 / API_CALLS_TOTAL ))
            if (( $PERCENT > 20 )); then
                echo "API rate in good shape $PERCENT % free"
                exit 0
            fi
            echo "API rate lower then 20%, sleping 10m"
            sleep 10m
          done

          # show current api rate
          curl -s -H "Accept: application/vnd.github.v3+json" -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" https://api.github.com/rate_limit

      - name: Import GPG key
        env:
          GPG_KEY1: ${{ secrets.GPG_KEY1 }}
        if: env.GPG_KEY1 != null
        uses: crazy-max/ghaction-import-gpg@v6
        with:
          gpg_private_key: ${{ secrets.GPG_KEY1 }}
          passphrase: ${{ secrets.GPG_PASSPHRASE1 }}

      - name: Sign
        env:
          GPG_PASSPHRASE1: ${{ secrets.GPG_PASSPHRASE1 }}
        if: env.GPG_PASSPHRASE1 != null
        run: |

          echo ${{ secrets.GPG_PASSPHRASE1 }} | gpg --passphrase-fd 0 --armor --detach-sign --pinentry-mode loopback --batch --yes output/images/*/archive/*img*.xz

      #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!11
      - name: Check filelist
        run: |
          find output

      - name: "Convert image to burn"
        id: convertburn
        run: |
          if ! command -v "dtc" > /dev/null 2>&1; then
             sudo apt update \
             && sudo apt install device-tree-compiler -y
          fi
          if ! command -v "cc" > /dev/null 2>&1; then
             sudo apt update \
             && sudo apt install build-essential cpp -y
          fi
          if ! command -v "zip" > /dev/null 2>&1; then
             sudo apt update \
             && sudo apt install zip -y
          fi


          UBOOTDEB=$(find output | grep linux-u-boot | head -n 1)
          IMG=$(find output | grep  -e  ".*images.*Armbian.*img.xz$" | head -n 1)
          # Armbian_23.8.0-trunk.52.jh.3.5_Jethubj80_bookworm_current_6.1.32.burn.img

          cd tools

          DEB="../${UBOOTDEB}"
          dpkg -x "$DEB" output
          UBOOT=$(find output/usr/lib -name u-boot.nosd.bin | head -n 1)
          echo UBOOT: ${UBOOT}
          find ../output

          ### 'BETA=yes' 'BOARD=jethubj80' 'BRANCH=current' 'BUILD_DESKTOP=no' 'BUILD_MINIMAL=no' 'RELEASE=bookworm'
          EVALCMD=$(echo ${{ matrix.invocation }} | sed 's/jethome-images//')
          eval ${EVALCMD}
          echo ${EVALCMD}
          case ${BOARD} in
            jethubj100)
              ./convert.sh ../${IMG} d1 armbian compress output/usr/lib/linux*/u-boot.nosd.bin
              SUPPORTED="D1,D1P"
              ;;
            jethubj200)
              ./convert.sh ../${IMG} d2 armbian compress output/usr/lib/linux*/u-boot.nosd.bin
              SUPPORTED="D2"
              ;;
            jethubj80)
              ./convert.sh ../${IMG} h1 armbian compress output/usr/lib/linux*/u-boot.nosd.bin
              SUPPORTED="H1"
              ;;
            *)
              echo "Unsupported board" ${BOARD}
              echo "Error in convert: Unsupported board" ${BOARD} >> GITHUB_STEP_SUMMARY
              exit 200
              ;;
          esac
          rm -rf output/usr

          IMGBURN=$(find output | grep  -e  "Armbian.*burn.img.zip$" | head -n 1)
          echo IMGBURN: ${IMGBURN}
          [ -z "${IMGBURN}" ] && exit 50

          if [ "${BETA}" == "yes" ]; then
            case "${{ env.BUILD_REF }}" in
              main*)
                CHANNEL="nightly"
                ;;
              v2*)
                CHANNEL="rc"
                ;;
              *)
                CHANNEL="${BUILD_REF}"
                ;;
            esac

          else
            CHANNEL="release"
          fi

          echo "board=${BOARD}" >> $GITHUB_OUTPUT
          echo "brd=${BOARD:6}"  >> $GITHUB_OUTPUT
          echo "branch=${BRANCH}" >> $GITHUB_OUTPUT
          echo "channel=${CHANNEL}" >> $GITHUB_OUTPUT
          echo "release=${RELEASE}" >> $GITHUB_OUTPUT
          echo "supported=${SUPPORTED}" >> $GITHUB_OUTPUT
          echo "image=${IMG}" >> $GITHUB_OUTPUT
          echo "imageburn=tools/${IMGBURN}" >> $GITHUB_OUTPUT

      - name: Sign burn
        env:
          GPG_PASSPHRASE1: ${{ secrets.GPG_PASSPHRASE1 }}
        if: env.GPG_PASSPHRASE1 != null
        run: |
          echo ${{ secrets.GPG_PASSPHRASE1 }} | gpg --passphrase-fd 0 --armor --detach-sign --pinentry-mode loopback --batch --yes ${{ steps.convertburn.outputs.imageburn }}

      - name: "Upload artefacts"
        if: ${{ github.event.inputs.uploadtoserver == 'github' || github.event.inputs.uploadtoserver == 'both' }}
        uses: ncipollo/release-action@v1
        with:
          repo: "${{ env.RELEASE_REPOSITORY }}"
          artifacts: "output/images/*/*/Armbian_*.*"
          tag: "${{ needs.matrix_prep.outputs.version }}"
          omitBody: true
          replacesArtifacts: true
          omitName: true
          makeLatest: false
          omitPrereleaseDuringUpdate: true
          allowUpdates: true
          artifactErrorsFailBuild: false
          token: "${{ env.GH_TOKEN }}"

      - name: "Upload artefacts"
        if: ${{ github.event.inputs.uploadtoserver == 'github' || github.event.inputs.uploadtoserver == 'both' }}
        uses: ncipollo/release-action@v1
        with:
          repo: "${{ env.RELEASE_REPOSITORY }}"
          artifacts: "${{ steps.convertburn.outputs.imageburn }}*"
          tag: "${{ needs.matrix_prep.outputs.version }}"
          omitBody: true
          replacesArtifacts: true
          omitName: true
          makeLatest: false
          omitPrereleaseDuringUpdate: true
          allowUpdates: true
          artifactErrorsFailBuild: false
          token: "${{ env.GH_TOKEN }}"

      - name: Deploy to fw.jethome.ru (sdcard)
        if: ${{ github.event.inputs.uploadtoserver == 'both' || github.event.inputs.uploadtoserver == 'jethome' }}
        id: upload-sdcard
        uses: jethome-iot/actions/firmware-upload@master
        with:
          url: https://fw.jethome.ru
          fullslug: "JetHome.${{ steps.convertburn.outputs.brd }}.Armbian.${{ steps.convertburn.outputs.channel }}.${{ steps.convertburn.outputs.release }}.${{ steps.convertburn.outputs.branch }}"
          image_type: "sdcard"
          firmware_file: "${{ steps.convertburn.outputs.image }}"
          hashpgp_file: "${{ steps.convertburn.outputs.image }}.asc"
          version: "${{ needs.matrix_prep.outputs.version }}"
          force_overwrite: "true"
          generatefirmwareslot: "true"
          update_latest: "true"
          supported_devices: "${{ steps.convertburn.outputs.supported }}"
          FWUPLOAD: ${{ secrets.FWUPLOAD }}

      - name: Deploy to fw.jethome.ru (burn)
        if: ${{ github.event.inputs.uploadtoserver == 'both' || github.event.inputs.uploadtoserver == 'jethome' }}
        id: upload-burn
        uses: jethome-iot/actions/firmware-upload@master
        with:
          url: https://fw.jethome.ru
          fullslug: "JetHome.${{ steps.convertburn.outputs.brd }}.Armbian.${{ steps.convertburn.outputs.channel }}.${{ steps.convertburn.outputs.release }}.${{ steps.convertburn.outputs.branch }}"
          image_type: "burn"
          firmware_file: "${{ steps.convertburn.outputs.imageburn }}"
          hashpgp_file: "${{ steps.convertburn.outputs.imageburn }}.asc"
          version: "${{ needs.matrix_prep.outputs.version }}"
          generatefirmwareslot: "false"
          force_overwrite: "true"
          update_latest: "true"
          supported_devices: "${{ steps.convertburn.outputs.supported }}"
          FWUPLOAD: ${{ secrets.FWUPLOAD }}

      - name: "Runner clean ${{ needs.matrix_prep.outputs.version }}"
        if: always()
        run: sudo rm -rfv output/images userpatches/VERSION
  "build-images-chunk-7": # templated "build-images-chunk-7"
    needs: [ "matrix_prep", "all-artifacts-ready" ]
    timeout-minutes: 240
    if: ${{ !failure() && !cancelled() && ( github.repository_owner == 'jethome-iot' ) && ( needs.matrix_prep.outputs.images-chunk-not-empty-7 == 'yes' ) }} # <-- HERE: Chunk number.
    strategy:
      fail-fast: false # let other jobs try to complete if one fails
      matrix: ${{ fromJSON(needs.matrix_prep.outputs.images-chunk-json-7) }} # <-- HERE: Chunk number.
    name: ${{ matrix.desc || 'Empty I7' }} # <-- HERE: Chunk number.
    runs-on: ${{ matrix.runs_on }}
    steps:

      # cleaning self hosted runners
      #- name: "Runner clean ${{ needs.matrix_prep.outputs.version }}"
      #  uses: armbian/actions/runner-clean@main

      # cleanup the place where we will clone the userpatches repo, to avoid git going insane and cleaning everything later
      - name: Cleanup userpatches repo
        if: ${{ ( env.USERPATCHES_REPOSITORY != '' ) && ( env.USERPATCHES_REF != '' ) }}
        run: sudo rm -rf userpatches.repo

      - name: Checkout build repo
        uses: actions/checkout@v4
        with:
          repository: ${{ env.BUILD_REPOSITORY }}
          ref: ${{ needs.matrix_prep.outputs.build-sha1 }}
          fetch-depth: ${{ matrix.fdepth }}
          clean: false # true is default. it *will* delete the hosts /dev if mounted inside.

      # clone the userpatches repo (`armbian/os`)
      - name: "Checkout userpatches repo: ${{env.USERPATCHES_REPOSITORY}}#${{env.USERPATCHES_REF}}"
        uses: actions/checkout@v4
        if: ${{ ( env.USERPATCHES_REPOSITORY != '' ) && ( env.USERPATCHES_REF != '' ) }}
        with:
          repository: ${{ env.USERPATCHES_REPOSITORY }}
          ref: ${{ env.USERPATCHES_REF }}
          fetch-depth: ${{ matrix.fdepth }}
          clean: false # true is default.
          path: userpatches.repo

      - name: Checkout jethome-tools repository
        uses: actions/checkout@v4
        with:
          repository: jethome-ru/jethome-tools
          path: tools
          ref: convert_jhos

      - name: "Put userpatches in place, and remove userpatches repo"
        if: ${{ ( env.USERPATCHES_REPOSITORY != '' ) && ( env.USERPATCHES_REF != '' ) }}
        run: |
          mkdir -pv userpatches
          rsync -av userpatches.repo/${{env.USERPATCHES_DIR}}/. userpatches/
          rm -rf userpatches.repo
          echo ${{ needs.matrix_prep.outputs.version }} > userpatches/VERSION

      - name: "Cleanup leftover output"
        run: |
          sudo rm -f userpatches/VERSION

      - name: ${{matrix.desc}}
        id: build-one-image
        timeout-minutes: 300
        run: |
          # calculate loop from runner name
          if [ -z "${ImageOS}" ]; then
            USE_FIXED_LOOP_DEVICE=$(echo ${RUNNER_NAME} | rev | cut -d"-" -f1  | rev | sed 's/^0*//' | sed -e 's/^/\/dev\/loop/')
          fi
          bash ./compile.sh ${{ matrix.invocation }} REVISION="${{ needs.matrix_prep.outputs.version }}" USE_FIXED_LOOP_DEVICE="$USE_FIXED_LOOP_DEVICE" SHARE_LOG=yes MAKE_FOLDERS="archive" IMAGE_VERSION=${{ needs.matrix_prep.outputs.version }} ${{env.EXTRA_PARAMS_IMAGE}} ${{env.EXTRA_PARAMS_ALL_BUILDS}}

      - name: "Logs: ${{ steps.build-one-image.outputs.logs_url }}"
        if: always()
        run: |
          echo "Logs: ${{ steps.build-one-image.outputs.logs_url }}"

      - name: Install SSH key for storage
        env:
          KEY_ARMBIAN_UPLOAD: ${{ secrets.KEY_ARMBIAN_UPLOAD }}
        if: env.KEY_ARMBIAN_UPLOAD != null
        uses: shimataro/ssh-key-action@v2
        with:
          key: ${{ secrets.KEY_ARMBIAN_UPLOAD }}
          known_hosts: ${{ secrets.KNOWN_HOSTS_ARMBIAN_UPLOAD }}
          if_key_exists: replace

      - name: Check API rate limits
        run: |

          # install dependencies
          if ! command -v "gh" > /dev/null 2>&1; then
             sudo apt-get -y -qq install gh
          fi

          while true
            do
            API_CALLS_TOTAL=$(gh api -H "Accept: application/vnd.github+json" -H "X-GitHub-Api-Version: 2022-11-28" /rate_limit | jq -r '.rate.limit')
            API_CALLS_LEFT=$(gh api -H "Accept: application/vnd.github+json" -H "X-GitHub-Api-Version: 2022-11-28" /rate_limit | jq -r '.rate.remaining')
            PERCENT=$(( API_CALLS_LEFT * 100 / API_CALLS_TOTAL ))
            if (( $PERCENT > 20 )); then
                echo "API rate in good shape $PERCENT % free"
                exit 0
            fi
            echo "API rate lower then 20%, sleping 10m"
            sleep 10m
          done

          # show current api rate
          curl -s -H "Accept: application/vnd.github.v3+json" -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" https://api.github.com/rate_limit

      - name: Import GPG key
        env:
          GPG_KEY1: ${{ secrets.GPG_KEY1 }}
        if: env.GPG_KEY1 != null
        uses: crazy-max/ghaction-import-gpg@v6
        with:
          gpg_private_key: ${{ secrets.GPG_KEY1 }}
          passphrase: ${{ secrets.GPG_PASSPHRASE1 }}

      - name: Sign
        env:
          GPG_PASSPHRASE1: ${{ secrets.GPG_PASSPHRASE1 }}
        if: env.GPG_PASSPHRASE1 != null
        run: |

          echo ${{ secrets.GPG_PASSPHRASE1 }} | gpg --passphrase-fd 0 --armor --detach-sign --pinentry-mode loopback --batch --yes output/images/*/archive/*img*.xz

      #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!11
      - name: Check filelist
        run: |
          find output

      - name: "Convert image to burn"
        id: convertburn
        run: |
          if ! command -v "dtc" > /dev/null 2>&1; then
             sudo apt update \
             && sudo apt install device-tree-compiler -y
          fi
          if ! command -v "cc" > /dev/null 2>&1; then
             sudo apt update \
             && sudo apt install build-essential cpp -y
          fi
          if ! command -v "zip" > /dev/null 2>&1; then
             sudo apt update \
             && sudo apt install zip -y
          fi


          UBOOTDEB=$(find output | grep linux-u-boot | head -n 1)
          IMG=$(find output | grep  -e  ".*images.*Armbian.*img.xz$" | head -n 1)
          # Armbian_23.8.0-trunk.52.jh.3.5_Jethubj80_bookworm_current_6.1.32.burn.img

          cd tools

          DEB="../${UBOOTDEB}"
          dpkg -x "$DEB" output
          UBOOT=$(find output/usr/lib -name u-boot.nosd.bin | head -n 1)
          echo UBOOT: ${UBOOT}
          find ../output

          ### 'BETA=yes' 'BOARD=jethubj80' 'BRANCH=current' 'BUILD_DESKTOP=no' 'BUILD_MINIMAL=no' 'RELEASE=bookworm'
          EVALCMD=$(echo ${{ matrix.invocation }} | sed 's/jethome-images//')
          eval ${EVALCMD}
          echo ${EVALCMD}
          case ${BOARD} in
            jethubj100)
              ./convert.sh ../${IMG} d1 armbian compress output/usr/lib/linux*/u-boot.nosd.bin
              SUPPORTED="D1,D1P"
              ;;
            jethubj200)
              ./convert.sh ../${IMG} d2 armbian compress output/usr/lib/linux*/u-boot.nosd.bin
              SUPPORTED="D2"
              ;;
            jethubj80)
              ./convert.sh ../${IMG} h1 armbian compress output/usr/lib/linux*/u-boot.nosd.bin
              SUPPORTED="H1"
              ;;
            *)
              echo "Unsupported board" ${BOARD}
              echo "Error in convert: Unsupported board" ${BOARD} >> GITHUB_STEP_SUMMARY
              exit 200
              ;;
          esac
          rm -rf output/usr

          IMGBURN=$(find output | grep  -e  "Armbian.*burn.img.zip$" | head -n 1)
          echo IMGBURN: ${IMGBURN}
          [ -z "${IMGBURN}" ] && exit 50

          if [ "${BETA}" == "yes" ]; then
            case "${{ env.BUILD_REF }}" in
              main*)
                CHANNEL="nightly"
                ;;
              v2*)
                CHANNEL="rc"
                ;;
              *)
                CHANNEL="${BUILD_REF}"
                ;;
            esac

          else
            CHANNEL="release"
          fi

          echo "board=${BOARD}" >> $GITHUB_OUTPUT
          echo "brd=${BOARD:6}"  >> $GITHUB_OUTPUT
          echo "branch=${BRANCH}" >> $GITHUB_OUTPUT
          echo "channel=${CHANNEL}" >> $GITHUB_OUTPUT
          echo "release=${RELEASE}" >> $GITHUB_OUTPUT
          echo "supported=${SUPPORTED}" >> $GITHUB_OUTPUT
          echo "image=${IMG}" >> $GITHUB_OUTPUT
          echo "imageburn=tools/${IMGBURN}" >> $GITHUB_OUTPUT

      - name: Sign burn
        env:
          GPG_PASSPHRASE1: ${{ secrets.GPG_PASSPHRASE1 }}
        if: env.GPG_PASSPHRASE1 != null
        run: |
          echo ${{ secrets.GPG_PASSPHRASE1 }} | gpg --passphrase-fd 0 --armor --detach-sign --pinentry-mode loopback --batch --yes ${{ steps.convertburn.outputs.imageburn }}

      - name: "Upload artefacts"
        if: ${{ github.event.inputs.uploadtoserver == 'github' || github.event.inputs.uploadtoserver == 'both' }}
        uses: ncipollo/release-action@v1
        with:
          repo: "${{ env.RELEASE_REPOSITORY }}"
          artifacts: "output/images/*/*/Armbian_*.*"
          tag: "${{ needs.matrix_prep.outputs.version }}"
          omitBody: true
          replacesArtifacts: true
          omitName: true
          makeLatest: false
          omitPrereleaseDuringUpdate: true
          allowUpdates: true
          artifactErrorsFailBuild: false
          token: "${{ env.GH_TOKEN }}"

      - name: "Upload artefacts"
        if: ${{ github.event.inputs.uploadtoserver == 'github' || github.event.inputs.uploadtoserver == 'both' }}
        uses: ncipollo/release-action@v1
        with:
          repo: "${{ env.RELEASE_REPOSITORY }}"
          artifacts: "${{ steps.convertburn.outputs.imageburn }}*"
          tag: "${{ needs.matrix_prep.outputs.version }}"
          omitBody: true
          replacesArtifacts: true
          omitName: true
          makeLatest: false
          omitPrereleaseDuringUpdate: true
          allowUpdates: true
          artifactErrorsFailBuild: false
          token: "${{ env.GH_TOKEN }}"

      - name: Deploy to fw.jethome.ru (sdcard)
        if: ${{ github.event.inputs.uploadtoserver == 'both' || github.event.inputs.uploadtoserver == 'jethome' }}
        id: upload-sdcard
        uses: jethome-iot/actions/firmware-upload@master
        with:
          url: https://fw.jethome.ru
          fullslug: "JetHome.${{ steps.convertburn.outputs.brd }}.Armbian.${{ steps.convertburn.outputs.channel }}.${{ steps.convertburn.outputs.release }}.${{ steps.convertburn.outputs.branch }}"
          image_type: "sdcard"
          firmware_file: "${{ steps.convertburn.outputs.image }}"
          hashpgp_file: "${{ steps.convertburn.outputs.image }}.asc"
          version: "${{ needs.matrix_prep.outputs.version }}"
          force_overwrite: "true"
          generatefirmwareslot: "true"
          update_latest: "true"
          supported_devices: "${{ steps.convertburn.outputs.supported }}"
          FWUPLOAD: ${{ secrets.FWUPLOAD }}

      - name: Deploy to fw.jethome.ru (burn)
        if: ${{ github.event.inputs.uploadtoserver == 'both' || github.event.inputs.uploadtoserver == 'jethome' }}
        id: upload-burn
        uses: jethome-iot/actions/firmware-upload@master
        with:
          url: https://fw.jethome.ru
          fullslug: "JetHome.${{ steps.convertburn.outputs.brd }}.Armbian.${{ steps.convertburn.outputs.channel }}.${{ steps.convertburn.outputs.release }}.${{ steps.convertburn.outputs.branch }}"
          image_type: "burn"
          firmware_file: "${{ steps.convertburn.outputs.imageburn }}"
          hashpgp_file: "${{ steps.convertburn.outputs.imageburn }}.asc"
          version: "${{ needs.matrix_prep.outputs.version }}"
          generatefirmwareslot: "false"
          force_overwrite: "true"
          update_latest: "true"
          supported_devices: "${{ steps.convertburn.outputs.supported }}"
          FWUPLOAD: ${{ secrets.FWUPLOAD }}

      - name: "Runner clean ${{ needs.matrix_prep.outputs.version }}"
        if: always()
        run: sudo rm -rfv output/images userpatches/VERSION
  "build-images-chunk-8": # templated "build-images-chunk-8"
    needs: [ "matrix_prep", "all-artifacts-ready" ]
    timeout-minutes: 240
    if: ${{ !failure() && !cancelled() && ( github.repository_owner == 'jethome-iot' ) && ( needs.matrix_prep.outputs.images-chunk-not-empty-8 == 'yes' ) }} # <-- HERE: Chunk number.
    strategy:
      fail-fast: false # let other jobs try to complete if one fails
      matrix: ${{ fromJSON(needs.matrix_prep.outputs.images-chunk-json-8) }} # <-- HERE: Chunk number.
    name: ${{ matrix.desc || 'Empty I8' }} # <-- HERE: Chunk number.
    runs-on: ${{ matrix.runs_on }}
    steps:

      # cleaning self hosted runners
      #- name: "Runner clean ${{ needs.matrix_prep.outputs.version }}"
      #  uses: armbian/actions/runner-clean@main

      # cleanup the place where we will clone the userpatches repo, to avoid git going insane and cleaning everything later
      - name: Cleanup userpatches repo
        if: ${{ ( env.USERPATCHES_REPOSITORY != '' ) && ( env.USERPATCHES_REF != '' ) }}
        run: sudo rm -rf userpatches.repo

      - name: Checkout build repo
        uses: actions/checkout@v4
        with:
          repository: ${{ env.BUILD_REPOSITORY }}
          ref: ${{ needs.matrix_prep.outputs.build-sha1 }}
          fetch-depth: ${{ matrix.fdepth }}
          clean: false # true is default. it *will* delete the hosts /dev if mounted inside.

      # clone the userpatches repo (`armbian/os`)
      - name: "Checkout userpatches repo: ${{env.USERPATCHES_REPOSITORY}}#${{env.USERPATCHES_REF}}"
        uses: actions/checkout@v4
        if: ${{ ( env.USERPATCHES_REPOSITORY != '' ) && ( env.USERPATCHES_REF != '' ) }}
        with:
          repository: ${{ env.USERPATCHES_REPOSITORY }}
          ref: ${{ env.USERPATCHES_REF }}
          fetch-depth: ${{ matrix.fdepth }}
          clean: false # true is default.
          path: userpatches.repo

      - name: Checkout jethome-tools repository
        uses: actions/checkout@v4
        with:
          repository: jethome-ru/jethome-tools
          path: tools
          ref: convert_jhos

      - name: "Put userpatches in place, and remove userpatches repo"
        if: ${{ ( env.USERPATCHES_REPOSITORY != '' ) && ( env.USERPATCHES_REF != '' ) }}
        run: |
          mkdir -pv userpatches
          rsync -av userpatches.repo/${{env.USERPATCHES_DIR}}/. userpatches/
          rm -rf userpatches.repo
          echo ${{ needs.matrix_prep.outputs.version }} > userpatches/VERSION

      - name: "Cleanup leftover output"
        run: |
          sudo rm -f userpatches/VERSION

      - name: ${{matrix.desc}}
        id: build-one-image
        timeout-minutes: 300
        run: |
          # calculate loop from runner name
          if [ -z "${ImageOS}" ]; then
            USE_FIXED_LOOP_DEVICE=$(echo ${RUNNER_NAME} | rev | cut -d"-" -f1  | rev | sed 's/^0*//' | sed -e 's/^/\/dev\/loop/')
          fi
          bash ./compile.sh ${{ matrix.invocation }} REVISION="${{ needs.matrix_prep.outputs.version }}" USE_FIXED_LOOP_DEVICE="$USE_FIXED_LOOP_DEVICE" SHARE_LOG=yes MAKE_FOLDERS="archive" IMAGE_VERSION=${{ needs.matrix_prep.outputs.version }} ${{env.EXTRA_PARAMS_IMAGE}} ${{env.EXTRA_PARAMS_ALL_BUILDS}}

      - name: "Logs: ${{ steps.build-one-image.outputs.logs_url }}"
        if: always()
        run: |
          echo "Logs: ${{ steps.build-one-image.outputs.logs_url }}"

      - name: Install SSH key for storage
        env:
          KEY_ARMBIAN_UPLOAD: ${{ secrets.KEY_ARMBIAN_UPLOAD }}
        if: env.KEY_ARMBIAN_UPLOAD != null
        uses: shimataro/ssh-key-action@v2
        with:
          key: ${{ secrets.KEY_ARMBIAN_UPLOAD }}
          known_hosts: ${{ secrets.KNOWN_HOSTS_ARMBIAN_UPLOAD }}
          if_key_exists: replace

      - name: Check API rate limits
        run: |

          # install dependencies
          if ! command -v "gh" > /dev/null 2>&1; then
             sudo apt-get -y -qq install gh
          fi

          while true
            do
            API_CALLS_TOTAL=$(gh api -H "Accept: application/vnd.github+json" -H "X-GitHub-Api-Version: 2022-11-28" /rate_limit | jq -r '.rate.limit')
            API_CALLS_LEFT=$(gh api -H "Accept: application/vnd.github+json" -H "X-GitHub-Api-Version: 2022-11-28" /rate_limit | jq -r '.rate.remaining')
            PERCENT=$(( API_CALLS_LEFT * 100 / API_CALLS_TOTAL ))
            if (( $PERCENT > 20 )); then
                echo "API rate in good shape $PERCENT % free"
                exit 0
            fi
            echo "API rate lower then 20%, sleping 10m"
            sleep 10m
          done

          # show current api rate
          curl -s -H "Accept: application/vnd.github.v3+json" -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" https://api.github.com/rate_limit

      - name: Import GPG key
        env:
          GPG_KEY1: ${{ secrets.GPG_KEY1 }}
        if: env.GPG_KEY1 != null
        uses: crazy-max/ghaction-import-gpg@v6
        with:
          gpg_private_key: ${{ secrets.GPG_KEY1 }}
          passphrase: ${{ secrets.GPG_PASSPHRASE1 }}

      - name: Sign
        env:
          GPG_PASSPHRASE1: ${{ secrets.GPG_PASSPHRASE1 }}
        if: env.GPG_PASSPHRASE1 != null
        run: |

          echo ${{ secrets.GPG_PASSPHRASE1 }} | gpg --passphrase-fd 0 --armor --detach-sign --pinentry-mode loopback --batch --yes output/images/*/archive/*img*.xz

      #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!11
      - name: Check filelist
        run: |
          find output

      - name: "Convert image to burn"
        id: convertburn
        run: |
          if ! command -v "dtc" > /dev/null 2>&1; then
             sudo apt update \
             && sudo apt install device-tree-compiler -y
          fi
          if ! command -v "cc" > /dev/null 2>&1; then
             sudo apt update \
             && sudo apt install build-essential cpp -y
          fi
          if ! command -v "zip" > /dev/null 2>&1; then
             sudo apt update \
             && sudo apt install zip -y
          fi


          UBOOTDEB=$(find output | grep linux-u-boot | head -n 1)
          IMG=$(find output | grep  -e  ".*images.*Armbian.*img.xz$" | head -n 1)
          # Armbian_23.8.0-trunk.52.jh.3.5_Jethubj80_bookworm_current_6.1.32.burn.img

          cd tools

          DEB="../${UBOOTDEB}"
          dpkg -x "$DEB" output
          UBOOT=$(find output/usr/lib -name u-boot.nosd.bin | head -n 1)
          echo UBOOT: ${UBOOT}
          find ../output

          ### 'BETA=yes' 'BOARD=jethubj80' 'BRANCH=current' 'BUILD_DESKTOP=no' 'BUILD_MINIMAL=no' 'RELEASE=bookworm'
          EVALCMD=$(echo ${{ matrix.invocation }} | sed 's/jethome-images//')
          eval ${EVALCMD}
          echo ${EVALCMD}
          case ${BOARD} in
            jethubj100)
              ./convert.sh ../${IMG} d1 armbian compress output/usr/lib/linux*/u-boot.nosd.bin
              SUPPORTED="D1,D1P"
              ;;
            jethubj200)
              ./convert.sh ../${IMG} d2 armbian compress output/usr/lib/linux*/u-boot.nosd.bin
              SUPPORTED="D2"
              ;;
            jethubj80)
              ./convert.sh ../${IMG} h1 armbian compress output/usr/lib/linux*/u-boot.nosd.bin
              SUPPORTED="H1"
              ;;
            *)
              echo "Unsupported board" ${BOARD}
              echo "Error in convert: Unsupported board" ${BOARD} >> GITHUB_STEP_SUMMARY
              exit 200
              ;;
          esac
          rm -rf output/usr

          IMGBURN=$(find output | grep  -e  "Armbian.*burn.img.zip$" | head -n 1)
          echo IMGBURN: ${IMGBURN}
          [ -z "${IMGBURN}" ] && exit 50

          if [ "${BETA}" == "yes" ]; then
            case "${{ env.BUILD_REF }}" in
              main*)
                CHANNEL="nightly"
                ;;
              v2*)
                CHANNEL="rc"
                ;;
              *)
                CHANNEL="${BUILD_REF}"
                ;;
            esac

          else
            CHANNEL="release"
          fi

          echo "board=${BOARD}" >> $GITHUB_OUTPUT
          echo "brd=${BOARD:6}"  >> $GITHUB_OUTPUT
          echo "branch=${BRANCH}" >> $GITHUB_OUTPUT
          echo "channel=${CHANNEL}" >> $GITHUB_OUTPUT
          echo "release=${RELEASE}" >> $GITHUB_OUTPUT
          echo "supported=${SUPPORTED}" >> $GITHUB_OUTPUT
          echo "image=${IMG}" >> $GITHUB_OUTPUT
          echo "imageburn=tools/${IMGBURN}" >> $GITHUB_OUTPUT

      - name: Sign burn
        env:
          GPG_PASSPHRASE1: ${{ secrets.GPG_PASSPHRASE1 }}
        if: env.GPG_PASSPHRASE1 != null
        run: |
          echo ${{ secrets.GPG_PASSPHRASE1 }} | gpg --passphrase-fd 0 --armor --detach-sign --pinentry-mode loopback --batch --yes ${{ steps.convertburn.outputs.imageburn }}

      - name: "Upload artefacts"
        if: ${{ github.event.inputs.uploadtoserver == 'github' || github.event.inputs.uploadtoserver == 'both' }}
        uses: ncipollo/release-action@v1
        with:
          repo: "${{ env.RELEASE_REPOSITORY }}"
          artifacts: "output/images/*/*/Armbian_*.*"
          tag: "${{ needs.matrix_prep.outputs.version }}"
          omitBody: true
          replacesArtifacts: true
          omitName: true
          makeLatest: false
          omitPrereleaseDuringUpdate: true
          allowUpdates: true
          artifactErrorsFailBuild: false
          token: "${{ env.GH_TOKEN }}"

      - name: "Upload artefacts"
        if: ${{ github.event.inputs.uploadtoserver == 'github' || github.event.inputs.uploadtoserver == 'both' }}
        uses: ncipollo/release-action@v1
        with:
          repo: "${{ env.RELEASE_REPOSITORY }}"
          artifacts: "${{ steps.convertburn.outputs.imageburn }}*"
          tag: "${{ needs.matrix_prep.outputs.version }}"
          omitBody: true
          replacesArtifacts: true
          omitName: true
          makeLatest: false
          omitPrereleaseDuringUpdate: true
          allowUpdates: true
          artifactErrorsFailBuild: false
          token: "${{ env.GH_TOKEN }}"

      - name: Deploy to fw.jethome.ru (sdcard)
        if: ${{ github.event.inputs.uploadtoserver == 'both' || github.event.inputs.uploadtoserver == 'jethome' }}
        id: upload-sdcard
        uses: jethome-iot/actions/firmware-upload@master
        with:
          url: https://fw.jethome.ru
          fullslug: "JetHome.${{ steps.convertburn.outputs.brd }}.Armbian.${{ steps.convertburn.outputs.channel }}.${{ steps.convertburn.outputs.release }}.${{ steps.convertburn.outputs.branch }}"
          image_type: "sdcard"
          firmware_file: "${{ steps.convertburn.outputs.image }}"
          hashpgp_file: "${{ steps.convertburn.outputs.image }}.asc"
          version: "${{ needs.matrix_prep.outputs.version }}"
          force_overwrite: "true"
          generatefirmwareslot: "true"
          update_latest: "true"
          supported_devices: "${{ steps.convertburn.outputs.supported }}"
          FWUPLOAD: ${{ secrets.FWUPLOAD }}

      - name: Deploy to fw.jethome.ru (burn)
        if: ${{ github.event.inputs.uploadtoserver == 'both' || github.event.inputs.uploadtoserver == 'jethome' }}
        id: upload-burn
        uses: jethome-iot/actions/firmware-upload@master
        with:
          url: https://fw.jethome.ru
          fullslug: "JetHome.${{ steps.convertburn.outputs.brd }}.Armbian.${{ steps.convertburn.outputs.channel }}.${{ steps.convertburn.outputs.release }}.${{ steps.convertburn.outputs.branch }}"
          image_type: "burn"
          firmware_file: "${{ steps.convertburn.outputs.imageburn }}"
          hashpgp_file: "${{ steps.convertburn.outputs.imageburn }}.asc"
          version: "${{ needs.matrix_prep.outputs.version }}"
          generatefirmwareslot: "false"
          force_overwrite: "true"
          update_latest: "true"
          supported_devices: "${{ steps.convertburn.outputs.supported }}"
          FWUPLOAD: ${{ secrets.FWUPLOAD }}

      - name: "Runner clean ${{ needs.matrix_prep.outputs.version }}"
        if: always()
        run: sudo rm -rfv output/images userpatches/VERSION
  "build-images-chunk-9": # templated "build-images-chunk-9"
    needs: [ "matrix_prep", "all-artifacts-ready" ]
    timeout-minutes: 240
    if: ${{ !failure() && !cancelled() && ( github.repository_owner == 'jethome-iot' ) && ( needs.matrix_prep.outputs.images-chunk-not-empty-9 == 'yes' ) }} # <-- HERE: Chunk number.
    strategy:
      fail-fast: false # let other jobs try to complete if one fails
      matrix: ${{ fromJSON(needs.matrix_prep.outputs.images-chunk-json-9) }} # <-- HERE: Chunk number.
    name: ${{ matrix.desc || 'Empty I9' }} # <-- HERE: Chunk number.
    runs-on: ${{ matrix.runs_on }}
    steps:

      # cleaning self hosted runners
      #- name: "Runner clean ${{ needs.matrix_prep.outputs.version }}"
      #  uses: armbian/actions/runner-clean@main

      # cleanup the place where we will clone the userpatches repo, to avoid git going insane and cleaning everything later
      - name: Cleanup userpatches repo
        if: ${{ ( env.USERPATCHES_REPOSITORY != '' ) && ( env.USERPATCHES_REF != '' ) }}
        run: sudo rm -rf userpatches.repo

      - name: Checkout build repo
        uses: actions/checkout@v4
        with:
          repository: ${{ env.BUILD_REPOSITORY }}
          ref: ${{ needs.matrix_prep.outputs.build-sha1 }}
          fetch-depth: ${{ matrix.fdepth }}
          clean: false # true is default. it *will* delete the hosts /dev if mounted inside.

      # clone the userpatches repo (`armbian/os`)
      - name: "Checkout userpatches repo: ${{env.USERPATCHES_REPOSITORY}}#${{env.USERPATCHES_REF}}"
        uses: actions/checkout@v4
        if: ${{ ( env.USERPATCHES_REPOSITORY != '' ) && ( env.USERPATCHES_REF != '' ) }}
        with:
          repository: ${{ env.USERPATCHES_REPOSITORY }}
          ref: ${{ env.USERPATCHES_REF }}
          fetch-depth: ${{ matrix.fdepth }}
          clean: false # true is default.
          path: userpatches.repo

      - name: Checkout jethome-tools repository
        uses: actions/checkout@v4
        with:
          repository: jethome-ru/jethome-tools
          path: tools
          ref: convert_jhos

      - name: "Put userpatches in place, and remove userpatches repo"
        if: ${{ ( env.USERPATCHES_REPOSITORY != '' ) && ( env.USERPATCHES_REF != '' ) }}
        run: |
          mkdir -pv userpatches
          rsync -av userpatches.repo/${{env.USERPATCHES_DIR}}/. userpatches/
          rm -rf userpatches.repo
          echo ${{ needs.matrix_prep.outputs.version }} > userpatches/VERSION

      - name: "Cleanup leftover output"
        run: |
          sudo rm -f userpatches/VERSION

      - name: ${{matrix.desc}}
        id: build-one-image
        timeout-minutes: 300
        run: |
          # calculate loop from runner name
          if [ -z "${ImageOS}" ]; then
            USE_FIXED_LOOP_DEVICE=$(echo ${RUNNER_NAME} | rev | cut -d"-" -f1  | rev | sed 's/^0*//' | sed -e 's/^/\/dev\/loop/')
          fi
          bash ./compile.sh ${{ matrix.invocation }} REVISION="${{ needs.matrix_prep.outputs.version }}" USE_FIXED_LOOP_DEVICE="$USE_FIXED_LOOP_DEVICE" SHARE_LOG=yes MAKE_FOLDERS="archive" IMAGE_VERSION=${{ needs.matrix_prep.outputs.version }} ${{env.EXTRA_PARAMS_IMAGE}} ${{env.EXTRA_PARAMS_ALL_BUILDS}}

      - name: "Logs: ${{ steps.build-one-image.outputs.logs_url }}"
        if: always()
        run: |
          echo "Logs: ${{ steps.build-one-image.outputs.logs_url }}"

      - name: Install SSH key for storage
        env:
          KEY_ARMBIAN_UPLOAD: ${{ secrets.KEY_ARMBIAN_UPLOAD }}
        if: env.KEY_ARMBIAN_UPLOAD != null
        uses: shimataro/ssh-key-action@v2
        with:
          key: ${{ secrets.KEY_ARMBIAN_UPLOAD }}
          known_hosts: ${{ secrets.KNOWN_HOSTS_ARMBIAN_UPLOAD }}
          if_key_exists: replace

      - name: Check API rate limits
        run: |

          # install dependencies
          if ! command -v "gh" > /dev/null 2>&1; then
             sudo apt-get -y -qq install gh
          fi

          while true
            do
            API_CALLS_TOTAL=$(gh api -H "Accept: application/vnd.github+json" -H "X-GitHub-Api-Version: 2022-11-28" /rate_limit | jq -r '.rate.limit')
            API_CALLS_LEFT=$(gh api -H "Accept: application/vnd.github+json" -H "X-GitHub-Api-Version: 2022-11-28" /rate_limit | jq -r '.rate.remaining')
            PERCENT=$(( API_CALLS_LEFT * 100 / API_CALLS_TOTAL ))
            if (( $PERCENT > 20 )); then
                echo "API rate in good shape $PERCENT % free"
                exit 0
            fi
            echo "API rate lower then 20%, sleping 10m"
            sleep 10m
          done

          # show current api rate
          curl -s -H "Accept: application/vnd.github.v3+json" -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" https://api.github.com/rate_limit

      - name: Import GPG key
        env:
          GPG_KEY1: ${{ secrets.GPG_KEY1 }}
        if: env.GPG_KEY1 != null
        uses: crazy-max/ghaction-import-gpg@v6
        with:
          gpg_private_key: ${{ secrets.GPG_KEY1 }}
          passphrase: ${{ secrets.GPG_PASSPHRASE1 }}

      - name: Sign
        env:
          GPG_PASSPHRASE1: ${{ secrets.GPG_PASSPHRASE1 }}
        if: env.GPG_PASSPHRASE1 != null
        run: |

          echo ${{ secrets.GPG_PASSPHRASE1 }} | gpg --passphrase-fd 0 --armor --detach-sign --pinentry-mode loopback --batch --yes output/images/*/archive/*img*.xz

      #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!11
      - name: Check filelist
        run: |
          find output

      - name: "Convert image to burn"
        id: convertburn
        run: |
          if ! command -v "dtc" > /dev/null 2>&1; then
             sudo apt update \
             && sudo apt install device-tree-compiler -y
          fi
          if ! command -v "cc" > /dev/null 2>&1; then
             sudo apt update \
             && sudo apt install build-essential cpp -y
          fi
          if ! command -v "zip" > /dev/null 2>&1; then
             sudo apt update \
             && sudo apt install zip -y
          fi


          UBOOTDEB=$(find output | grep linux-u-boot | head -n 1)
          IMG=$(find output | grep  -e  ".*images.*Armbian.*img.xz$" | head -n 1)
          # Armbian_23.8.0-trunk.52.jh.3.5_Jethubj80_bookworm_current_6.1.32.burn.img

          cd tools

          DEB="../${UBOOTDEB}"
          dpkg -x "$DEB" output
          UBOOT=$(find output/usr/lib -name u-boot.nosd.bin | head -n 1)
          echo UBOOT: ${UBOOT}
          find ../output

          ### 'BETA=yes' 'BOARD=jethubj80' 'BRANCH=current' 'BUILD_DESKTOP=no' 'BUILD_MINIMAL=no' 'RELEASE=bookworm'
          EVALCMD=$(echo ${{ matrix.invocation }} | sed 's/jethome-images//')
          eval ${EVALCMD}
          echo ${EVALCMD}
          case ${BOARD} in
            jethubj100)
              ./convert.sh ../${IMG} d1 armbian compress output/usr/lib/linux*/u-boot.nosd.bin
              SUPPORTED="D1,D1P"
              ;;
            jethubj200)
              ./convert.sh ../${IMG} d2 armbian compress output/usr/lib/linux*/u-boot.nosd.bin
              SUPPORTED="D2"
              ;;
            jethubj80)
              ./convert.sh ../${IMG} h1 armbian compress output/usr/lib/linux*/u-boot.nosd.bin
              SUPPORTED="H1"
              ;;
            *)
              echo "Unsupported board" ${BOARD}
              echo "Error in convert: Unsupported board" ${BOARD} >> GITHUB_STEP_SUMMARY
              exit 200
              ;;
          esac
          rm -rf output/usr

          IMGBURN=$(find output | grep  -e  "Armbian.*burn.img.zip$" | head -n 1)
          echo IMGBURN: ${IMGBURN}
          [ -z "${IMGBURN}" ] && exit 50

          if [ "${BETA}" == "yes" ]; then
            case "${{ env.BUILD_REF }}" in
              main*)
                CHANNEL="nightly"
                ;;
              v2*)
                CHANNEL="rc"
                ;;
              *)
                CHANNEL="${BUILD_REF}"
                ;;
            esac

          else
            CHANNEL="release"
          fi

          echo "board=${BOARD}" >> $GITHUB_OUTPUT
          echo "brd=${BOARD:6}"  >> $GITHUB_OUTPUT
          echo "branch=${BRANCH}" >> $GITHUB_OUTPUT
          echo "channel=${CHANNEL}" >> $GITHUB_OUTPUT
          echo "release=${RELEASE}" >> $GITHUB_OUTPUT
          echo "supported=${SUPPORTED}" >> $GITHUB_OUTPUT
          echo "image=${IMG}" >> $GITHUB_OUTPUT
          echo "imageburn=tools/${IMGBURN}" >> $GITHUB_OUTPUT

      - name: Sign burn
        env:
          GPG_PASSPHRASE1: ${{ secrets.GPG_PASSPHRASE1 }}
        if: env.GPG_PASSPHRASE1 != null
        run: |
          echo ${{ secrets.GPG_PASSPHRASE1 }} | gpg --passphrase-fd 0 --armor --detach-sign --pinentry-mode loopback --batch --yes ${{ steps.convertburn.outputs.imageburn }}

      - name: "Upload artefacts"
        if: ${{ github.event.inputs.uploadtoserver == 'github' || github.event.inputs.uploadtoserver == 'both' }}
        uses: ncipollo/release-action@v1
        with:
          repo: "${{ env.RELEASE_REPOSITORY }}"
          artifacts: "output/images/*/*/Armbian_*.*"
          tag: "${{ needs.matrix_prep.outputs.version }}"
          omitBody: true
          replacesArtifacts: true
          omitName: true
          makeLatest: false
          omitPrereleaseDuringUpdate: true
          allowUpdates: true
          artifactErrorsFailBuild: false
          token: "${{ env.GH_TOKEN }}"

      - name: "Upload artefacts"
        if: ${{ github.event.inputs.uploadtoserver == 'github' || github.event.inputs.uploadtoserver == 'both' }}
        uses: ncipollo/release-action@v1
        with:
          repo: "${{ env.RELEASE_REPOSITORY }}"
          artifacts: "${{ steps.convertburn.outputs.imageburn }}*"
          tag: "${{ needs.matrix_prep.outputs.version }}"
          omitBody: true
          replacesArtifacts: true
          omitName: true
          makeLatest: false
          omitPrereleaseDuringUpdate: true
          allowUpdates: true
          artifactErrorsFailBuild: false
          token: "${{ env.GH_TOKEN }}"

      - name: Deploy to fw.jethome.ru (sdcard)
        if: ${{ github.event.inputs.uploadtoserver == 'both' || github.event.inputs.uploadtoserver == 'jethome' }}
        id: upload-sdcard
        uses: jethome-iot/actions/firmware-upload@master
        with:
          url: https://fw.jethome.ru
          fullslug: "JetHome.${{ steps.convertburn.outputs.brd }}.Armbian.${{ steps.convertburn.outputs.channel }}.${{ steps.convertburn.outputs.release }}.${{ steps.convertburn.outputs.branch }}"
          image_type: "sdcard"
          firmware_file: "${{ steps.convertburn.outputs.image }}"
          hashpgp_file: "${{ steps.convertburn.outputs.image }}.asc"
          version: "${{ needs.matrix_prep.outputs.version }}"
          force_overwrite: "true"
          generatefirmwareslot: "true"
          update_latest: "true"
          supported_devices: "${{ steps.convertburn.outputs.supported }}"
          FWUPLOAD: ${{ secrets.FWUPLOAD }}

      - name: Deploy to fw.jethome.ru (burn)
        if: ${{ github.event.inputs.uploadtoserver == 'both' || github.event.inputs.uploadtoserver == 'jethome' }}
        id: upload-burn
        uses: jethome-iot/actions/firmware-upload@master
        with:
          url: https://fw.jethome.ru
          fullslug: "JetHome.${{ steps.convertburn.outputs.brd }}.Armbian.${{ steps.convertburn.outputs.channel }}.${{ steps.convertburn.outputs.release }}.${{ steps.convertburn.outputs.branch }}"
          image_type: "burn"
          firmware_file: "${{ steps.convertburn.outputs.imageburn }}"
          hashpgp_file: "${{ steps.convertburn.outputs.imageburn }}.asc"
          version: "${{ needs.matrix_prep.outputs.version }}"
          generatefirmwareslot: "false"
          force_overwrite: "true"
          update_latest: "true"
          supported_devices: "${{ steps.convertburn.outputs.supported }}"
          FWUPLOAD: ${{ secrets.FWUPLOAD }}

      - name: "Runner clean ${{ needs.matrix_prep.outputs.version }}"
        if: always()
        run: sudo rm -rfv output/images userpatches/VERSION
  "build-images-chunk-10": # templated "build-images-chunk-10"
    needs: [ "matrix_prep", "all-artifacts-ready" ]
    timeout-minutes: 240
    if: ${{ !failure() && !cancelled() && ( github.repository_owner == 'jethome-iot' ) && ( needs.matrix_prep.outputs.images-chunk-not-empty-10 == 'yes' ) }} # <-- HERE: Chunk number.
    strategy:
      fail-fast: false # let other jobs try to complete if one fails
      matrix: ${{ fromJSON(needs.matrix_prep.outputs.images-chunk-json-10) }} # <-- HERE: Chunk number.
    name: ${{ matrix.desc || 'Empty I10' }} # <-- HERE: Chunk number.
    runs-on: ${{ matrix.runs_on }}
    steps:

      # cleaning self hosted runners
      #- name: "Runner clean ${{ needs.matrix_prep.outputs.version }}"
      #  uses: armbian/actions/runner-clean@main

      # cleanup the place where we will clone the userpatches repo, to avoid git going insane and cleaning everything later
      - name: Cleanup userpatches repo
        if: ${{ ( env.USERPATCHES_REPOSITORY != '' ) && ( env.USERPATCHES_REF != '' ) }}
        run: sudo rm -rf userpatches.repo

      - name: Checkout build repo
        uses: actions/checkout@v4
        with:
          repository: ${{ env.BUILD_REPOSITORY }}
          ref: ${{ needs.matrix_prep.outputs.build-sha1 }}
          fetch-depth: ${{ matrix.fdepth }}
          clean: false # true is default. it *will* delete the hosts /dev if mounted inside.

      # clone the userpatches repo (`armbian/os`)
      - name: "Checkout userpatches repo: ${{env.USERPATCHES_REPOSITORY}}#${{env.USERPATCHES_REF}}"
        uses: actions/checkout@v4
        if: ${{ ( env.USERPATCHES_REPOSITORY != '' ) && ( env.USERPATCHES_REF != '' ) }}
        with:
          repository: ${{ env.USERPATCHES_REPOSITORY }}
          ref: ${{ env.USERPATCHES_REF }}
          fetch-depth: ${{ matrix.fdepth }}
          clean: false # true is default.
          path: userpatches.repo

      - name: Checkout jethome-tools repository
        uses: actions/checkout@v4
        with:
          repository: jethome-ru/jethome-tools
          path: tools
          ref: convert_jhos

      - name: "Put userpatches in place, and remove userpatches repo"
        if: ${{ ( env.USERPATCHES_REPOSITORY != '' ) && ( env.USERPATCHES_REF != '' ) }}
        run: |
          mkdir -pv userpatches
          rsync -av userpatches.repo/${{env.USERPATCHES_DIR}}/. userpatches/
          rm -rf userpatches.repo
          echo ${{ needs.matrix_prep.outputs.version }} > userpatches/VERSION

      - name: "Cleanup leftover output"
        run: |
          sudo rm -f userpatches/VERSION

      - name: ${{matrix.desc}}
        id: build-one-image
        timeout-minutes: 300
        run: |
          # calculate loop from runner name
          if [ -z "${ImageOS}" ]; then
            USE_FIXED_LOOP_DEVICE=$(echo ${RUNNER_NAME} | rev | cut -d"-" -f1  | rev | sed 's/^0*//' | sed -e 's/^/\/dev\/loop/')
          fi
          bash ./compile.sh ${{ matrix.invocation }} REVISION="${{ needs.matrix_prep.outputs.version }}" USE_FIXED_LOOP_DEVICE="$USE_FIXED_LOOP_DEVICE" SHARE_LOG=yes MAKE_FOLDERS="archive" IMAGE_VERSION=${{ needs.matrix_prep.outputs.version }} ${{env.EXTRA_PARAMS_IMAGE}} ${{env.EXTRA_PARAMS_ALL_BUILDS}}

      - name: "Logs: ${{ steps.build-one-image.outputs.logs_url }}"
        if: always()
        run: |
          echo "Logs: ${{ steps.build-one-image.outputs.logs_url }}"

      - name: Install SSH key for storage
        env:
          KEY_ARMBIAN_UPLOAD: ${{ secrets.KEY_ARMBIAN_UPLOAD }}
        if: env.KEY_ARMBIAN_UPLOAD != null
        uses: shimataro/ssh-key-action@v2
        with:
          key: ${{ secrets.KEY_ARMBIAN_UPLOAD }}
          known_hosts: ${{ secrets.KNOWN_HOSTS_ARMBIAN_UPLOAD }}
          if_key_exists: replace

      - name: Check API rate limits
        run: |

          # install dependencies
          if ! command -v "gh" > /dev/null 2>&1; then
             sudo apt-get -y -qq install gh
          fi

          while true
            do
            API_CALLS_TOTAL=$(gh api -H "Accept: application/vnd.github+json" -H "X-GitHub-Api-Version: 2022-11-28" /rate_limit | jq -r '.rate.limit')
            API_CALLS_LEFT=$(gh api -H "Accept: application/vnd.github+json" -H "X-GitHub-Api-Version: 2022-11-28" /rate_limit | jq -r '.rate.remaining')
            PERCENT=$(( API_CALLS_LEFT * 100 / API_CALLS_TOTAL ))
            if (( $PERCENT > 20 )); then
                echo "API rate in good shape $PERCENT % free"
                exit 0
            fi
            echo "API rate lower then 20%, sleping 10m"
            sleep 10m
          done

          # show current api rate
          curl -s -H "Accept: application/vnd.github.v3+json" -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" https://api.github.com/rate_limit

      - name: Import GPG key
        env:
          GPG_KEY1: ${{ secrets.GPG_KEY1 }}
        if: env.GPG_KEY1 != null
        uses: crazy-max/ghaction-import-gpg@v6
        with:
          gpg_private_key: ${{ secrets.GPG_KEY1 }}
          passphrase: ${{ secrets.GPG_PASSPHRASE1 }}

      - name: Sign
        env:
          GPG_PASSPHRASE1: ${{ secrets.GPG_PASSPHRASE1 }}
        if: env.GPG_PASSPHRASE1 != null
        run: |

          echo ${{ secrets.GPG_PASSPHRASE1 }} | gpg --passphrase-fd 0 --armor --detach-sign --pinentry-mode loopback --batch --yes output/images/*/archive/*img*.xz

      #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!11
      - name: Check filelist
        run: |
          find output

      - name: "Convert image to burn"
        id: convertburn
        run: |
          if ! command -v "dtc" > /dev/null 2>&1; then
             sudo apt update \
             && sudo apt install device-tree-compiler -y
          fi
          if ! command -v "cc" > /dev/null 2>&1; then
             sudo apt update \
             && sudo apt install build-essential cpp -y
          fi
          if ! command -v "zip" > /dev/null 2>&1; then
             sudo apt update \
             && sudo apt install zip -y
          fi


          UBOOTDEB=$(find output | grep linux-u-boot | head -n 1)
          IMG=$(find output | grep  -e  ".*images.*Armbian.*img.xz$" | head -n 1)
          # Armbian_23.8.0-trunk.52.jh.3.5_Jethubj80_bookworm_current_6.1.32.burn.img

          cd tools

          DEB="../${UBOOTDEB}"
          dpkg -x "$DEB" output
          UBOOT=$(find output/usr/lib -name u-boot.nosd.bin | head -n 1)
          echo UBOOT: ${UBOOT}
          find ../output

          ### 'BETA=yes' 'BOARD=jethubj80' 'BRANCH=current' 'BUILD_DESKTOP=no' 'BUILD_MINIMAL=no' 'RELEASE=bookworm'
          EVALCMD=$(echo ${{ matrix.invocation }} | sed 's/jethome-images//')
          eval ${EVALCMD}
          echo ${EVALCMD}
          case ${BOARD} in
            jethubj100)
              ./convert.sh ../${IMG} d1 armbian compress output/usr/lib/linux*/u-boot.nosd.bin
              SUPPORTED="D1,D1P"
              ;;
            jethubj200)
              ./convert.sh ../${IMG} d2 armbian compress output/usr/lib/linux*/u-boot.nosd.bin
              SUPPORTED="D2"
              ;;
            jethubj80)
              ./convert.sh ../${IMG} h1 armbian compress output/usr/lib/linux*/u-boot.nosd.bin
              SUPPORTED="H1"
              ;;
            *)
              echo "Unsupported board" ${BOARD}
              echo "Error in convert: Unsupported board" ${BOARD} >> GITHUB_STEP_SUMMARY
              exit 200
              ;;
          esac
          rm -rf output/usr

          IMGBURN=$(find output | grep  -e  "Armbian.*burn.img.zip$" | head -n 1)
          echo IMGBURN: ${IMGBURN}
          [ -z "${IMGBURN}" ] && exit 50

          if [ "${BETA}" == "yes" ]; then
            case "${{ env.BUILD_REF }}" in
              main*)
                CHANNEL="nightly"
                ;;
              v2*)
                CHANNEL="rc"
                ;;
              *)
                CHANNEL="${BUILD_REF}"
                ;;
            esac

          else
            CHANNEL="release"
          fi

          echo "board=${BOARD}" >> $GITHUB_OUTPUT
          echo "brd=${BOARD:6}"  >> $GITHUB_OUTPUT
          echo "branch=${BRANCH}" >> $GITHUB_OUTPUT
          echo "channel=${CHANNEL}" >> $GITHUB_OUTPUT
          echo "release=${RELEASE}" >> $GITHUB_OUTPUT
          echo "supported=${SUPPORTED}" >> $GITHUB_OUTPUT
          echo "image=${IMG}" >> $GITHUB_OUTPUT
          echo "imageburn=tools/${IMGBURN}" >> $GITHUB_OUTPUT

      - name: Sign burn
        env:
          GPG_PASSPHRASE1: ${{ secrets.GPG_PASSPHRASE1 }}
        if: env.GPG_PASSPHRASE1 != null
        run: |
          echo ${{ secrets.GPG_PASSPHRASE1 }} | gpg --passphrase-fd 0 --armor --detach-sign --pinentry-mode loopback --batch --yes ${{ steps.convertburn.outputs.imageburn }}

      - name: "Upload artefacts"
        if: ${{ github.event.inputs.uploadtoserver == 'github' || github.event.inputs.uploadtoserver == 'both' }}
        uses: ncipollo/release-action@v1
        with:
          repo: "${{ env.RELEASE_REPOSITORY }}"
          artifacts: "output/images/*/*/Armbian_*.*"
          tag: "${{ needs.matrix_prep.outputs.version }}"
          omitBody: true
          replacesArtifacts: true
          omitName: true
          makeLatest: false
          omitPrereleaseDuringUpdate: true
          allowUpdates: true
          artifactErrorsFailBuild: false
          token: "${{ env.GH_TOKEN }}"

      - name: "Upload artefacts"
        if: ${{ github.event.inputs.uploadtoserver == 'github' || github.event.inputs.uploadtoserver == 'both' }}
        uses: ncipollo/release-action@v1
        with:
          repo: "${{ env.RELEASE_REPOSITORY }}"
          artifacts: "${{ steps.convertburn.outputs.imageburn }}*"
          tag: "${{ needs.matrix_prep.outputs.version }}"
          omitBody: true
          replacesArtifacts: true
          omitName: true
          makeLatest: false
          omitPrereleaseDuringUpdate: true
          allowUpdates: true
          artifactErrorsFailBuild: false
          token: "${{ env.GH_TOKEN }}"

      - name: Deploy to fw.jethome.ru (sdcard)
        if: ${{ github.event.inputs.uploadtoserver == 'both' || github.event.inputs.uploadtoserver == 'jethome' }}
        id: upload-sdcard
        uses: jethome-iot/actions/firmware-upload@master
        with:
          url: https://fw.jethome.ru
          fullslug: "JetHome.${{ steps.convertburn.outputs.brd }}.Armbian.${{ steps.convertburn.outputs.channel }}.${{ steps.convertburn.outputs.release }}.${{ steps.convertburn.outputs.branch }}"
          image_type: "sdcard"
          firmware_file: "${{ steps.convertburn.outputs.image }}"
          hashpgp_file: "${{ steps.convertburn.outputs.image }}.asc"
          version: "${{ needs.matrix_prep.outputs.version }}"
          force_overwrite: "true"
          generatefirmwareslot: "true"
          update_latest: "true"
          supported_devices: "${{ steps.convertburn.outputs.supported }}"
          FWUPLOAD: ${{ secrets.FWUPLOAD }}

      - name: Deploy to fw.jethome.ru (burn)
        if: ${{ github.event.inputs.uploadtoserver == 'both' || github.event.inputs.uploadtoserver == 'jethome' }}
        id: upload-burn
        uses: jethome-iot/actions/firmware-upload@master
        with:
          url: https://fw.jethome.ru
          fullslug: "JetHome.${{ steps.convertburn.outputs.brd }}.Armbian.${{ steps.convertburn.outputs.channel }}.${{ steps.convertburn.outputs.release }}.${{ steps.convertburn.outputs.branch }}"
          image_type: "burn"
          firmware_file: "${{ steps.convertburn.outputs.imageburn }}"
          hashpgp_file: "${{ steps.convertburn.outputs.imageburn }}.asc"
          version: "${{ needs.matrix_prep.outputs.version }}"
          generatefirmwareslot: "false"
          force_overwrite: "true"
          update_latest: "true"
          supported_devices: "${{ steps.convertburn.outputs.supported }}"
          FWUPLOAD: ${{ secrets.FWUPLOAD }}

      - name: "Runner clean ${{ needs.matrix_prep.outputs.version }}"
        if: always()
        run: sudo rm -rfv output/images userpatches/VERSION
  "build-images-chunk-11": # templated "build-images-chunk-11"
    needs: [ "matrix_prep", "all-artifacts-ready" ]
    timeout-minutes: 240
    if: ${{ !failure() && !cancelled() && ( github.repository_owner == 'jethome-iot' ) && ( needs.matrix_prep.outputs.images-chunk-not-empty-11 == 'yes' ) }} # <-- HERE: Chunk number.
    strategy:
      fail-fast: false # let other jobs try to complete if one fails
      matrix: ${{ fromJSON(needs.matrix_prep.outputs.images-chunk-json-11) }} # <-- HERE: Chunk number.
    name: ${{ matrix.desc || 'Empty I11' }} # <-- HERE: Chunk number.
    runs-on: ${{ matrix.runs_on }}
    steps:

      # cleaning self hosted runners
      #- name: "Runner clean ${{ needs.matrix_prep.outputs.version }}"
      #  uses: armbian/actions/runner-clean@main

      # cleanup the place where we will clone the userpatches repo, to avoid git going insane and cleaning everything later
      - name: Cleanup userpatches repo
        if: ${{ ( env.USERPATCHES_REPOSITORY != '' ) && ( env.USERPATCHES_REF != '' ) }}
        run: sudo rm -rf userpatches.repo

      - name: Checkout build repo
        uses: actions/checkout@v4
        with:
          repository: ${{ env.BUILD_REPOSITORY }}
          ref: ${{ needs.matrix_prep.outputs.build-sha1 }}
          fetch-depth: ${{ matrix.fdepth }}
          clean: false # true is default. it *will* delete the hosts /dev if mounted inside.

      # clone the userpatches repo (`armbian/os`)
      - name: "Checkout userpatches repo: ${{env.USERPATCHES_REPOSITORY}}#${{env.USERPATCHES_REF}}"
        uses: actions/checkout@v4
        if: ${{ ( env.USERPATCHES_REPOSITORY != '' ) && ( env.USERPATCHES_REF != '' ) }}
        with:
          repository: ${{ env.USERPATCHES_REPOSITORY }}
          ref: ${{ env.USERPATCHES_REF }}
          fetch-depth: ${{ matrix.fdepth }}
          clean: false # true is default.
          path: userpatches.repo

      - name: Checkout jethome-tools repository
        uses: actions/checkout@v4
        with:
          repository: jethome-ru/jethome-tools
          path: tools
          ref: convert_jhos

      - name: "Put userpatches in place, and remove userpatches repo"
        if: ${{ ( env.USERPATCHES_REPOSITORY != '' ) && ( env.USERPATCHES_REF != '' ) }}
        run: |
          mkdir -pv userpatches
          rsync -av userpatches.repo/${{env.USERPATCHES_DIR}}/. userpatches/
          rm -rf userpatches.repo
          echo ${{ needs.matrix_prep.outputs.version }} > userpatches/VERSION

      - name: "Cleanup leftover output"
        run: |
          sudo rm -f userpatches/VERSION

      - name: ${{matrix.desc}}
        id: build-one-image
        timeout-minutes: 300
        run: |
          # calculate loop from runner name
          if [ -z "${ImageOS}" ]; then
            USE_FIXED_LOOP_DEVICE=$(echo ${RUNNER_NAME} | rev | cut -d"-" -f1  | rev | sed 's/^0*//' | sed -e 's/^/\/dev\/loop/')
          fi
          bash ./compile.sh ${{ matrix.invocation }} REVISION="${{ needs.matrix_prep.outputs.version }}" USE_FIXED_LOOP_DEVICE="$USE_FIXED_LOOP_DEVICE" SHARE_LOG=yes MAKE_FOLDERS="archive" IMAGE_VERSION=${{ needs.matrix_prep.outputs.version }} ${{env.EXTRA_PARAMS_IMAGE}} ${{env.EXTRA_PARAMS_ALL_BUILDS}}

      - name: "Logs: ${{ steps.build-one-image.outputs.logs_url }}"
        if: always()
        run: |
          echo "Logs: ${{ steps.build-one-image.outputs.logs_url }}"

      - name: Install SSH key for storage
        env:
          KEY_ARMBIAN_UPLOAD: ${{ secrets.KEY_ARMBIAN_UPLOAD }}
        if: env.KEY_ARMBIAN_UPLOAD != null
        uses: shimataro/ssh-key-action@v2
        with:
          key: ${{ secrets.KEY_ARMBIAN_UPLOAD }}
          known_hosts: ${{ secrets.KNOWN_HOSTS_ARMBIAN_UPLOAD }}
          if_key_exists: replace

      - name: Check API rate limits
        run: |

          # install dependencies
          if ! command -v "gh" > /dev/null 2>&1; then
             sudo apt-get -y -qq install gh
          fi

          while true
            do
            API_CALLS_TOTAL=$(gh api -H "Accept: application/vnd.github+json" -H "X-GitHub-Api-Version: 2022-11-28" /rate_limit | jq -r '.rate.limit')
            API_CALLS_LEFT=$(gh api -H "Accept: application/vnd.github+json" -H "X-GitHub-Api-Version: 2022-11-28" /rate_limit | jq -r '.rate.remaining')
            PERCENT=$(( API_CALLS_LEFT * 100 / API_CALLS_TOTAL ))
            if (( $PERCENT > 20 )); then
                echo "API rate in good shape $PERCENT % free"
                exit 0
            fi
            echo "API rate lower then 20%, sleping 10m"
            sleep 10m
          done

          # show current api rate
          curl -s -H "Accept: application/vnd.github.v3+json" -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" https://api.github.com/rate_limit

      - name: Import GPG key
        env:
          GPG_KEY1: ${{ secrets.GPG_KEY1 }}
        if: env.GPG_KEY1 != null
        uses: crazy-max/ghaction-import-gpg@v6
        with:
          gpg_private_key: ${{ secrets.GPG_KEY1 }}
          passphrase: ${{ secrets.GPG_PASSPHRASE1 }}

      - name: Sign
        env:
          GPG_PASSPHRASE1: ${{ secrets.GPG_PASSPHRASE1 }}
        if: env.GPG_PASSPHRASE1 != null
        run: |

          echo ${{ secrets.GPG_PASSPHRASE1 }} | gpg --passphrase-fd 0 --armor --detach-sign --pinentry-mode loopback --batch --yes output/images/*/archive/*img*.xz

      #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!11
      - name: Check filelist
        run: |
          find output

      - name: "Convert image to burn"
        id: convertburn
        run: |
          if ! command -v "dtc" > /dev/null 2>&1; then
             sudo apt update \
             && sudo apt install device-tree-compiler -y
          fi
          if ! command -v "cc" > /dev/null 2>&1; then
             sudo apt update \
             && sudo apt install build-essential cpp -y
          fi
          if ! command -v "zip" > /dev/null 2>&1; then
             sudo apt update \
             && sudo apt install zip -y
          fi


          UBOOTDEB=$(find output | grep linux-u-boot | head -n 1)
          IMG=$(find output | grep  -e  ".*images.*Armbian.*img.xz$" | head -n 1)
          # Armbian_23.8.0-trunk.52.jh.3.5_Jethubj80_bookworm_current_6.1.32.burn.img

          cd tools

          DEB="../${UBOOTDEB}"
          dpkg -x "$DEB" output
          UBOOT=$(find output/usr/lib -name u-boot.nosd.bin | head -n 1)
          echo UBOOT: ${UBOOT}
          find ../output

          ### 'BETA=yes' 'BOARD=jethubj80' 'BRANCH=current' 'BUILD_DESKTOP=no' 'BUILD_MINIMAL=no' 'RELEASE=bookworm'
          EVALCMD=$(echo ${{ matrix.invocation }} | sed 's/jethome-images//')
          eval ${EVALCMD}
          echo ${EVALCMD}
          case ${BOARD} in
            jethubj100)
              ./convert.sh ../${IMG} d1 armbian compress output/usr/lib/linux*/u-boot.nosd.bin
              SUPPORTED="D1,D1P"
              ;;
            jethubj200)
              ./convert.sh ../${IMG} d2 armbian compress output/usr/lib/linux*/u-boot.nosd.bin
              SUPPORTED="D2"
              ;;
            jethubj80)
              ./convert.sh ../${IMG} h1 armbian compress output/usr/lib/linux*/u-boot.nosd.bin
              SUPPORTED="H1"
              ;;
            *)
              echo "Unsupported board" ${BOARD}
              echo "Error in convert: Unsupported board" ${BOARD} >> GITHUB_STEP_SUMMARY
              exit 200
              ;;
          esac
          rm -rf output/usr

          IMGBURN=$(find output | grep  -e  "Armbian.*burn.img.zip$" | head -n 1)
          echo IMGBURN: ${IMGBURN}
          [ -z "${IMGBURN}" ] && exit 50

          if [ "${BETA}" == "yes" ]; then
            case "${{ env.BUILD_REF }}" in
              main*)
                CHANNEL="nightly"
                ;;
              v2*)
                CHANNEL="rc"
                ;;
              *)
                CHANNEL="${BUILD_REF}"
                ;;
            esac

          else
            CHANNEL="release"
          fi

          echo "board=${BOARD}" >> $GITHUB_OUTPUT
          echo "brd=${BOARD:6}"  >> $GITHUB_OUTPUT
          echo "branch=${BRANCH}" >> $GITHUB_OUTPUT
          echo "channel=${CHANNEL}" >> $GITHUB_OUTPUT
          echo "release=${RELEASE}" >> $GITHUB_OUTPUT
          echo "supported=${SUPPORTED}" >> $GITHUB_OUTPUT
          echo "image=${IMG}" >> $GITHUB_OUTPUT
          echo "imageburn=tools/${IMGBURN}" >> $GITHUB_OUTPUT

      - name: Sign burn
        env:
          GPG_PASSPHRASE1: ${{ secrets.GPG_PASSPHRASE1 }}
        if: env.GPG_PASSPHRASE1 != null
        run: |
          echo ${{ secrets.GPG_PASSPHRASE1 }} | gpg --passphrase-fd 0 --armor --detach-sign --pinentry-mode loopback --batch --yes ${{ steps.convertburn.outputs.imageburn }}

      - name: "Upload artefacts"
        if: ${{ github.event.inputs.uploadtoserver == 'github' || github.event.inputs.uploadtoserver == 'both' }}
        uses: ncipollo/release-action@v1
        with:
          repo: "${{ env.RELEASE_REPOSITORY }}"
          artifacts: "output/images/*/*/Armbian_*.*"
          tag: "${{ needs.matrix_prep.outputs.version }}"
          omitBody: true
          replacesArtifacts: true
          omitName: true
          makeLatest: false
          omitPrereleaseDuringUpdate: true
          allowUpdates: true
          artifactErrorsFailBuild: false
          token: "${{ env.GH_TOKEN }}"

      - name: "Upload artefacts"
        if: ${{ github.event.inputs.uploadtoserver == 'github' || github.event.inputs.uploadtoserver == 'both' }}
        uses: ncipollo/release-action@v1
        with:
          repo: "${{ env.RELEASE_REPOSITORY }}"
          artifacts: "${{ steps.convertburn.outputs.imageburn }}*"
          tag: "${{ needs.matrix_prep.outputs.version }}"
          omitBody: true
          replacesArtifacts: true
          omitName: true
          makeLatest: false
          omitPrereleaseDuringUpdate: true
          allowUpdates: true
          artifactErrorsFailBuild: false
          token: "${{ env.GH_TOKEN }}"

      - name: Deploy to fw.jethome.ru (sdcard)
        if: ${{ github.event.inputs.uploadtoserver == 'both' || github.event.inputs.uploadtoserver == 'jethome' }}
        id: upload-sdcard
        uses: jethome-iot/actions/firmware-upload@master
        with:
          url: https://fw.jethome.ru
          fullslug: "JetHome.${{ steps.convertburn.outputs.brd }}.Armbian.${{ steps.convertburn.outputs.channel }}.${{ steps.convertburn.outputs.release }}.${{ steps.convertburn.outputs.branch }}"
          image_type: "sdcard"
          firmware_file: "${{ steps.convertburn.outputs.image }}"
          hashpgp_file: "${{ steps.convertburn.outputs.image }}.asc"
          version: "${{ needs.matrix_prep.outputs.version }}"
          force_overwrite: "true"
          generatefirmwareslot: "true"
          update_latest: "true"
          supported_devices: "${{ steps.convertburn.outputs.supported }}"
          FWUPLOAD: ${{ secrets.FWUPLOAD }}

      - name: Deploy to fw.jethome.ru (burn)
        if: ${{ github.event.inputs.uploadtoserver == 'both' || github.event.inputs.uploadtoserver == 'jethome' }}
        id: upload-burn
        uses: jethome-iot/actions/firmware-upload@master
        with:
          url: https://fw.jethome.ru
          fullslug: "JetHome.${{ steps.convertburn.outputs.brd }}.Armbian.${{ steps.convertburn.outputs.channel }}.${{ steps.convertburn.outputs.release }}.${{ steps.convertburn.outputs.branch }}"
          image_type: "burn"
          firmware_file: "${{ steps.convertburn.outputs.imageburn }}"
          hashpgp_file: "${{ steps.convertburn.outputs.imageburn }}.asc"
          version: "${{ needs.matrix_prep.outputs.version }}"
          generatefirmwareslot: "false"
          force_overwrite: "true"
          update_latest: "true"
          supported_devices: "${{ steps.convertburn.outputs.supported }}"
          FWUPLOAD: ${{ secrets.FWUPLOAD }}

      - name: "Runner clean ${{ needs.matrix_prep.outputs.version }}"
        if: always()
        run: sudo rm -rfv output/images userpatches/VERSION
  "build-images-chunk-12": # templated "build-images-chunk-12"
    needs: [ "matrix_prep", "all-artifacts-ready" ]
    timeout-minutes: 240
    if: ${{ !failure() && !cancelled() && ( github.repository_owner == 'jethome-iot' ) && ( needs.matrix_prep.outputs.images-chunk-not-empty-12 == 'yes' ) }} # <-- HERE: Chunk number.
    strategy:
      fail-fast: false # let other jobs try to complete if one fails
      matrix: ${{ fromJSON(needs.matrix_prep.outputs.images-chunk-json-12) }} # <-- HERE: Chunk number.
    name: ${{ matrix.desc || 'Empty I12' }} # <-- HERE: Chunk number.
    runs-on: ${{ matrix.runs_on }}
    steps:

      # cleaning self hosted runners
      #- name: "Runner clean ${{ needs.matrix_prep.outputs.version }}"
      #  uses: armbian/actions/runner-clean@main

      # cleanup the place where we will clone the userpatches repo, to avoid git going insane and cleaning everything later
      - name: Cleanup userpatches repo
        if: ${{ ( env.USERPATCHES_REPOSITORY != '' ) && ( env.USERPATCHES_REF != '' ) }}
        run: sudo rm -rf userpatches.repo

      - name: Checkout build repo
        uses: actions/checkout@v4
        with:
          repository: ${{ env.BUILD_REPOSITORY }}
          ref: ${{ needs.matrix_prep.outputs.build-sha1 }}
          fetch-depth: ${{ matrix.fdepth }}
          clean: false # true is default. it *will* delete the hosts /dev if mounted inside.

      # clone the userpatches repo (`armbian/os`)
      - name: "Checkout userpatches repo: ${{env.USERPATCHES_REPOSITORY}}#${{env.USERPATCHES_REF}}"
        uses: actions/checkout@v4
        if: ${{ ( env.USERPATCHES_REPOSITORY != '' ) && ( env.USERPATCHES_REF != '' ) }}
        with:
          repository: ${{ env.USERPATCHES_REPOSITORY }}
          ref: ${{ env.USERPATCHES_REF }}
          fetch-depth: ${{ matrix.fdepth }}
          clean: false # true is default.
          path: userpatches.repo

      - name: Checkout jethome-tools repository
        uses: actions/checkout@v4
        with:
          repository: jethome-ru/jethome-tools
          path: tools
          ref: convert_jhos

      - name: "Put userpatches in place, and remove userpatches repo"
        if: ${{ ( env.USERPATCHES_REPOSITORY != '' ) && ( env.USERPATCHES_REF != '' ) }}
        run: |
          mkdir -pv userpatches
          rsync -av userpatches.repo/${{env.USERPATCHES_DIR}}/. userpatches/
          rm -rf userpatches.repo
          echo ${{ needs.matrix_prep.outputs.version }} > userpatches/VERSION

      - name: "Cleanup leftover output"
        run: |
          sudo rm -f userpatches/VERSION

      - name: ${{matrix.desc}}
        id: build-one-image
        timeout-minutes: 300
        run: |
          # calculate loop from runner name
          if [ -z "${ImageOS}" ]; then
            USE_FIXED_LOOP_DEVICE=$(echo ${RUNNER_NAME} | rev | cut -d"-" -f1  | rev | sed 's/^0*//' | sed -e 's/^/\/dev\/loop/')
          fi
          bash ./compile.sh ${{ matrix.invocation }} REVISION="${{ needs.matrix_prep.outputs.version }}" USE_FIXED_LOOP_DEVICE="$USE_FIXED_LOOP_DEVICE" SHARE_LOG=yes MAKE_FOLDERS="archive" IMAGE_VERSION=${{ needs.matrix_prep.outputs.version }} ${{env.EXTRA_PARAMS_IMAGE}} ${{env.EXTRA_PARAMS_ALL_BUILDS}}

      - name: "Logs: ${{ steps.build-one-image.outputs.logs_url }}"
        if: always()
        run: |
          echo "Logs: ${{ steps.build-one-image.outputs.logs_url }}"

      - name: Install SSH key for storage
        env:
          KEY_ARMBIAN_UPLOAD: ${{ secrets.KEY_ARMBIAN_UPLOAD }}
        if: env.KEY_ARMBIAN_UPLOAD != null
        uses: shimataro/ssh-key-action@v2
        with:
          key: ${{ secrets.KEY_ARMBIAN_UPLOAD }}
          known_hosts: ${{ secrets.KNOWN_HOSTS_ARMBIAN_UPLOAD }}
          if_key_exists: replace

      - name: Check API rate limits
        run: |

          # install dependencies
          if ! command -v "gh" > /dev/null 2>&1; then
             sudo apt-get -y -qq install gh
          fi

          while true
            do
            API_CALLS_TOTAL=$(gh api -H "Accept: application/vnd.github+json" -H "X-GitHub-Api-Version: 2022-11-28" /rate_limit | jq -r '.rate.limit')
            API_CALLS_LEFT=$(gh api -H "Accept: application/vnd.github+json" -H "X-GitHub-Api-Version: 2022-11-28" /rate_limit | jq -r '.rate.remaining')
            PERCENT=$(( API_CALLS_LEFT * 100 / API_CALLS_TOTAL ))
            if (( $PERCENT > 20 )); then
                echo "API rate in good shape $PERCENT % free"
                exit 0
            fi
            echo "API rate lower then 20%, sleping 10m"
            sleep 10m
          done

          # show current api rate
          curl -s -H "Accept: application/vnd.github.v3+json" -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" https://api.github.com/rate_limit

      - name: Import GPG key
        env:
          GPG_KEY1: ${{ secrets.GPG_KEY1 }}
        if: env.GPG_KEY1 != null
        uses: crazy-max/ghaction-import-gpg@v6
        with:
          gpg_private_key: ${{ secrets.GPG_KEY1 }}
          passphrase: ${{ secrets.GPG_PASSPHRASE1 }}

      - name: Sign
        env:
          GPG_PASSPHRASE1: ${{ secrets.GPG_PASSPHRASE1 }}
        if: env.GPG_PASSPHRASE1 != null
        run: |

          echo ${{ secrets.GPG_PASSPHRASE1 }} | gpg --passphrase-fd 0 --armor --detach-sign --pinentry-mode loopback --batch --yes output/images/*/archive/*img*.xz

      #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!11
      - name: Check filelist
        run: |
          find output

      - name: "Convert image to burn"
        id: convertburn
        run: |
          if ! command -v "dtc" > /dev/null 2>&1; then
             sudo apt update \
             && sudo apt install device-tree-compiler -y
          fi
          if ! command -v "cc" > /dev/null 2>&1; then
             sudo apt update \
             && sudo apt install build-essential cpp -y
          fi
          if ! command -v "zip" > /dev/null 2>&1; then
             sudo apt update \
             && sudo apt install zip -y
          fi


          UBOOTDEB=$(find output | grep linux-u-boot | head -n 1)
          IMG=$(find output | grep  -e  ".*images.*Armbian.*img.xz$" | head -n 1)
          # Armbian_23.8.0-trunk.52.jh.3.5_Jethubj80_bookworm_current_6.1.32.burn.img

          cd tools

          DEB="../${UBOOTDEB}"
          dpkg -x "$DEB" output
          UBOOT=$(find output/usr/lib -name u-boot.nosd.bin | head -n 1)
          echo UBOOT: ${UBOOT}
          find ../output

          ### 'BETA=yes' 'BOARD=jethubj80' 'BRANCH=current' 'BUILD_DESKTOP=no' 'BUILD_MINIMAL=no' 'RELEASE=bookworm'
          EVALCMD=$(echo ${{ matrix.invocation }} | sed 's/jethome-images//')
          eval ${EVALCMD}
          echo ${EVALCMD}
          case ${BOARD} in
            jethubj100)
              ./convert.sh ../${IMG} d1 armbian compress output/usr/lib/linux*/u-boot.nosd.bin
              SUPPORTED="D1,D1P"
              ;;
            jethubj200)
              ./convert.sh ../${IMG} d2 armbian compress output/usr/lib/linux*/u-boot.nosd.bin
              SUPPORTED="D2"
              ;;
            jethubj80)
              ./convert.sh ../${IMG} h1 armbian compress output/usr/lib/linux*/u-boot.nosd.bin
              SUPPORTED="H1"
              ;;
            *)
              echo "Unsupported board" ${BOARD}
              echo "Error in convert: Unsupported board" ${BOARD} >> GITHUB_STEP_SUMMARY
              exit 200
              ;;
          esac
          rm -rf output/usr

          IMGBURN=$(find output | grep  -e  "Armbian.*burn.img.zip$" | head -n 1)
          echo IMGBURN: ${IMGBURN}
          [ -z "${IMGBURN}" ] && exit 50

          if [ "${BETA}" == "yes" ]; then
            case "${{ env.BUILD_REF }}" in
              main*)
                CHANNEL="nightly"
                ;;
              v2*)
                CHANNEL="rc"
                ;;
              *)
                CHANNEL="${BUILD_REF}"
                ;;
            esac

          else
            CHANNEL="release"
          fi

          echo "board=${BOARD}" >> $GITHUB_OUTPUT
          echo "brd=${BOARD:6}"  >> $GITHUB_OUTPUT
          echo "branch=${BRANCH}" >> $GITHUB_OUTPUT
          echo "channel=${CHANNEL}" >> $GITHUB_OUTPUT
          echo "release=${RELEASE}" >> $GITHUB_OUTPUT
          echo "supported=${SUPPORTED}" >> $GITHUB_OUTPUT
          echo "image=${IMG}" >> $GITHUB_OUTPUT
          echo "imageburn=tools/${IMGBURN}" >> $GITHUB_OUTPUT

      - name: Sign burn
        env:
          GPG_PASSPHRASE1: ${{ secrets.GPG_PASSPHRASE1 }}
        if: env.GPG_PASSPHRASE1 != null
        run: |
          echo ${{ secrets.GPG_PASSPHRASE1 }} | gpg --passphrase-fd 0 --armor --detach-sign --pinentry-mode loopback --batch --yes ${{ steps.convertburn.outputs.imageburn }}

      - name: "Upload artefacts"
        if: ${{ github.event.inputs.uploadtoserver == 'github' || github.event.inputs.uploadtoserver == 'both' }}
        uses: ncipollo/release-action@v1
        with:
          repo: "${{ env.RELEASE_REPOSITORY }}"
          artifacts: "output/images/*/*/Armbian_*.*"
          tag: "${{ needs.matrix_prep.outputs.version }}"
          omitBody: true
          replacesArtifacts: true
          omitName: true
          makeLatest: false
          omitPrereleaseDuringUpdate: true
          allowUpdates: true
          artifactErrorsFailBuild: false
          token: "${{ env.GH_TOKEN }}"

      - name: "Upload artefacts"
        if: ${{ github.event.inputs.uploadtoserver == 'github' || github.event.inputs.uploadtoserver == 'both' }}
        uses: ncipollo/release-action@v1
        with:
          repo: "${{ env.RELEASE_REPOSITORY }}"
          artifacts: "${{ steps.convertburn.outputs.imageburn }}*"
          tag: "${{ needs.matrix_prep.outputs.version }}"
          omitBody: true
          replacesArtifacts: true
          omitName: true
          makeLatest: false
          omitPrereleaseDuringUpdate: true
          allowUpdates: true
          artifactErrorsFailBuild: false
          token: "${{ env.GH_TOKEN }}"

      - name: Deploy to fw.jethome.ru (sdcard)
        if: ${{ github.event.inputs.uploadtoserver == 'both' || github.event.inputs.uploadtoserver == 'jethome' }}
        id: upload-sdcard
        uses: jethome-iot/actions/firmware-upload@master
        with:
          url: https://fw.jethome.ru
          fullslug: "JetHome.${{ steps.convertburn.outputs.brd }}.Armbian.${{ steps.convertburn.outputs.channel }}.${{ steps.convertburn.outputs.release }}.${{ steps.convertburn.outputs.branch }}"
          image_type: "sdcard"
          firmware_file: "${{ steps.convertburn.outputs.image }}"
          hashpgp_file: "${{ steps.convertburn.outputs.image }}.asc"
          version: "${{ needs.matrix_prep.outputs.version }}"
          force_overwrite: "true"
          generatefirmwareslot: "true"
          update_latest: "true"
          supported_devices: "${{ steps.convertburn.outputs.supported }}"
          FWUPLOAD: ${{ secrets.FWUPLOAD }}

      - name: Deploy to fw.jethome.ru (burn)
        if: ${{ github.event.inputs.uploadtoserver == 'both' || github.event.inputs.uploadtoserver == 'jethome' }}
        id: upload-burn
        uses: jethome-iot/actions/firmware-upload@master
        with:
          url: https://fw.jethome.ru
          fullslug: "JetHome.${{ steps.convertburn.outputs.brd }}.Armbian.${{ steps.convertburn.outputs.channel }}.${{ steps.convertburn.outputs.release }}.${{ steps.convertburn.outputs.branch }}"
          image_type: "burn"
          firmware_file: "${{ steps.convertburn.outputs.imageburn }}"
          hashpgp_file: "${{ steps.convertburn.outputs.imageburn }}.asc"
          version: "${{ needs.matrix_prep.outputs.version }}"
          generatefirmwareslot: "false"
          force_overwrite: "true"
          update_latest: "true"
          supported_devices: "${{ steps.convertburn.outputs.supported }}"
          FWUPLOAD: ${{ secrets.FWUPLOAD }}

      - name: "Runner clean ${{ needs.matrix_prep.outputs.version }}"
        if: always()
        run: sudo rm -rfv output/images userpatches/VERSION
  "build-images-chunk-13": # templated "build-images-chunk-13"
    needs: [ "matrix_prep", "all-artifacts-ready" ]
    timeout-minutes: 240
    if: ${{ !failure() && !cancelled() && ( github.repository_owner == 'jethome-iot' ) && ( needs.matrix_prep.outputs.images-chunk-not-empty-13 == 'yes' ) }} # <-- HERE: Chunk number.
    strategy:
      fail-fast: false # let other jobs try to complete if one fails
      matrix: ${{ fromJSON(needs.matrix_prep.outputs.images-chunk-json-13) }} # <-- HERE: Chunk number.
    name: ${{ matrix.desc || 'Empty I13' }} # <-- HERE: Chunk number.
    runs-on: ${{ matrix.runs_on }}
    steps:

      # cleaning self hosted runners
      #- name: "Runner clean ${{ needs.matrix_prep.outputs.version }}"
      #  uses: armbian/actions/runner-clean@main

      # cleanup the place where we will clone the userpatches repo, to avoid git going insane and cleaning everything later
      - name: Cleanup userpatches repo
        if: ${{ ( env.USERPATCHES_REPOSITORY != '' ) && ( env.USERPATCHES_REF != '' ) }}
        run: sudo rm -rf userpatches.repo

      - name: Checkout build repo
        uses: actions/checkout@v4
        with:
          repository: ${{ env.BUILD_REPOSITORY }}
          ref: ${{ needs.matrix_prep.outputs.build-sha1 }}
          fetch-depth: ${{ matrix.fdepth }}
          clean: false # true is default. it *will* delete the hosts /dev if mounted inside.

      # clone the userpatches repo (`armbian/os`)
      - name: "Checkout userpatches repo: ${{env.USERPATCHES_REPOSITORY}}#${{env.USERPATCHES_REF}}"
        uses: actions/checkout@v4
        if: ${{ ( env.USERPATCHES_REPOSITORY != '' ) && ( env.USERPATCHES_REF != '' ) }}
        with:
          repository: ${{ env.USERPATCHES_REPOSITORY }}
          ref: ${{ env.USERPATCHES_REF }}
          fetch-depth: ${{ matrix.fdepth }}
          clean: false # true is default.
          path: userpatches.repo

      - name: Checkout jethome-tools repository
        uses: actions/checkout@v4
        with:
          repository: jethome-ru/jethome-tools
          path: tools
          ref: convert_jhos

      - name: "Put userpatches in place, and remove userpatches repo"
        if: ${{ ( env.USERPATCHES_REPOSITORY != '' ) && ( env.USERPATCHES_REF != '' ) }}
        run: |
          mkdir -pv userpatches
          rsync -av userpatches.repo/${{env.USERPATCHES_DIR}}/. userpatches/
          rm -rf userpatches.repo
          echo ${{ needs.matrix_prep.outputs.version }} > userpatches/VERSION

      - name: "Cleanup leftover output"
        run: |
          sudo rm -f userpatches/VERSION

      - name: ${{matrix.desc}}
        id: build-one-image
        timeout-minutes: 300
        run: |
          # calculate loop from runner name
          if [ -z "${ImageOS}" ]; then
            USE_FIXED_LOOP_DEVICE=$(echo ${RUNNER_NAME} | rev | cut -d"-" -f1  | rev | sed 's/^0*//' | sed -e 's/^/\/dev\/loop/')
          fi
          bash ./compile.sh ${{ matrix.invocation }} REVISION="${{ needs.matrix_prep.outputs.version }}" USE_FIXED_LOOP_DEVICE="$USE_FIXED_LOOP_DEVICE" SHARE_LOG=yes MAKE_FOLDERS="archive" IMAGE_VERSION=${{ needs.matrix_prep.outputs.version }} ${{env.EXTRA_PARAMS_IMAGE}} ${{env.EXTRA_PARAMS_ALL_BUILDS}}

      - name: "Logs: ${{ steps.build-one-image.outputs.logs_url }}"
        if: always()
        run: |
          echo "Logs: ${{ steps.build-one-image.outputs.logs_url }}"

      - name: Install SSH key for storage
        env:
          KEY_ARMBIAN_UPLOAD: ${{ secrets.KEY_ARMBIAN_UPLOAD }}
        if: env.KEY_ARMBIAN_UPLOAD != null
        uses: shimataro/ssh-key-action@v2
        with:
          key: ${{ secrets.KEY_ARMBIAN_UPLOAD }}
          known_hosts: ${{ secrets.KNOWN_HOSTS_ARMBIAN_UPLOAD }}
          if_key_exists: replace

      - name: Check API rate limits
        run: |

          # install dependencies
          if ! command -v "gh" > /dev/null 2>&1; then
             sudo apt-get -y -qq install gh
          fi

          while true
            do
            API_CALLS_TOTAL=$(gh api -H "Accept: application/vnd.github+json" -H "X-GitHub-Api-Version: 2022-11-28" /rate_limit | jq -r '.rate.limit')
            API_CALLS_LEFT=$(gh api -H "Accept: application/vnd.github+json" -H "X-GitHub-Api-Version: 2022-11-28" /rate_limit | jq -r '.rate.remaining')
            PERCENT=$(( API_CALLS_LEFT * 100 / API_CALLS_TOTAL ))
            if (( $PERCENT > 20 )); then
                echo "API rate in good shape $PERCENT % free"
                exit 0
            fi
            echo "API rate lower then 20%, sleping 10m"
            sleep 10m
          done

          # show current api rate
          curl -s -H "Accept: application/vnd.github.v3+json" -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" https://api.github.com/rate_limit

      - name: Import GPG key
        env:
          GPG_KEY1: ${{ secrets.GPG_KEY1 }}
        if: env.GPG_KEY1 != null
        uses: crazy-max/ghaction-import-gpg@v6
        with:
          gpg_private_key: ${{ secrets.GPG_KEY1 }}
          passphrase: ${{ secrets.GPG_PASSPHRASE1 }}

      - name: Sign
        env:
          GPG_PASSPHRASE1: ${{ secrets.GPG_PASSPHRASE1 }}
        if: env.GPG_PASSPHRASE1 != null
        run: |

          echo ${{ secrets.GPG_PASSPHRASE1 }} | gpg --passphrase-fd 0 --armor --detach-sign --pinentry-mode loopback --batch --yes output/images/*/archive/*img*.xz

      #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!11
      - name: Check filelist
        run: |
          find output

      - name: "Convert image to burn"
        id: convertburn
        run: |
          if ! command -v "dtc" > /dev/null 2>&1; then
             sudo apt update \
             && sudo apt install device-tree-compiler -y
          fi
          if ! command -v "cc" > /dev/null 2>&1; then
             sudo apt update \
             && sudo apt install build-essential cpp -y
          fi
          if ! command -v "zip" > /dev/null 2>&1; then
             sudo apt update \
             && sudo apt install zip -y
          fi


          UBOOTDEB=$(find output | grep linux-u-boot | head -n 1)
          IMG=$(find output | grep  -e  ".*images.*Armbian.*img.xz$" | head -n 1)
          # Armbian_23.8.0-trunk.52.jh.3.5_Jethubj80_bookworm_current_6.1.32.burn.img

          cd tools

          DEB="../${UBOOTDEB}"
          dpkg -x "$DEB" output
          UBOOT=$(find output/usr/lib -name u-boot.nosd.bin | head -n 1)
          echo UBOOT: ${UBOOT}
          find ../output

          ### 'BETA=yes' 'BOARD=jethubj80' 'BRANCH=current' 'BUILD_DESKTOP=no' 'BUILD_MINIMAL=no' 'RELEASE=bookworm'
          EVALCMD=$(echo ${{ matrix.invocation }} | sed 's/jethome-images//')
          eval ${EVALCMD}
          echo ${EVALCMD}
          case ${BOARD} in
            jethubj100)
              ./convert.sh ../${IMG} d1 armbian compress output/usr/lib/linux*/u-boot.nosd.bin
              SUPPORTED="D1,D1P"
              ;;
            jethubj200)
              ./convert.sh ../${IMG} d2 armbian compress output/usr/lib/linux*/u-boot.nosd.bin
              SUPPORTED="D2"
              ;;
            jethubj80)
              ./convert.sh ../${IMG} h1 armbian compress output/usr/lib/linux*/u-boot.nosd.bin
              SUPPORTED="H1"
              ;;
            *)
              echo "Unsupported board" ${BOARD}
              echo "Error in convert: Unsupported board" ${BOARD} >> GITHUB_STEP_SUMMARY
              exit 200
              ;;
          esac
          rm -rf output/usr

          IMGBURN=$(find output | grep  -e  "Armbian.*burn.img.zip$" | head -n 1)
          echo IMGBURN: ${IMGBURN}
          [ -z "${IMGBURN}" ] && exit 50

          if [ "${BETA}" == "yes" ]; then
            case "${{ env.BUILD_REF }}" in
              main*)
                CHANNEL="nightly"
                ;;
              v2*)
                CHANNEL="rc"
                ;;
              *)
                CHANNEL="${BUILD_REF}"
                ;;
            esac

          else
            CHANNEL="release"
          fi

          echo "board=${BOARD}" >> $GITHUB_OUTPUT
          echo "brd=${BOARD:6}"  >> $GITHUB_OUTPUT
          echo "branch=${BRANCH}" >> $GITHUB_OUTPUT
          echo "channel=${CHANNEL}" >> $GITHUB_OUTPUT
          echo "release=${RELEASE}" >> $GITHUB_OUTPUT
          echo "supported=${SUPPORTED}" >> $GITHUB_OUTPUT
          echo "image=${IMG}" >> $GITHUB_OUTPUT
          echo "imageburn=tools/${IMGBURN}" >> $GITHUB_OUTPUT

      - name: Sign burn
        env:
          GPG_PASSPHRASE1: ${{ secrets.GPG_PASSPHRASE1 }}
        if: env.GPG_PASSPHRASE1 != null
        run: |
          echo ${{ secrets.GPG_PASSPHRASE1 }} | gpg --passphrase-fd 0 --armor --detach-sign --pinentry-mode loopback --batch --yes ${{ steps.convertburn.outputs.imageburn }}

      - name: "Upload artefacts"
        if: ${{ github.event.inputs.uploadtoserver == 'github' || github.event.inputs.uploadtoserver == 'both' }}
        uses: ncipollo/release-action@v1
        with:
          repo: "${{ env.RELEASE_REPOSITORY }}"
          artifacts: "output/images/*/*/Armbian_*.*"
          tag: "${{ needs.matrix_prep.outputs.version }}"
          omitBody: true
          replacesArtifacts: true
          omitName: true
          makeLatest: false
          omitPrereleaseDuringUpdate: true
          allowUpdates: true
          artifactErrorsFailBuild: false
          token: "${{ env.GH_TOKEN }}"

      - name: "Upload artefacts"
        if: ${{ github.event.inputs.uploadtoserver == 'github' || github.event.inputs.uploadtoserver == 'both' }}
        uses: ncipollo/release-action@v1
        with:
          repo: "${{ env.RELEASE_REPOSITORY }}"
          artifacts: "${{ steps.convertburn.outputs.imageburn }}*"
          tag: "${{ needs.matrix_prep.outputs.version }}"
          omitBody: true
          replacesArtifacts: true
          omitName: true
          makeLatest: false
          omitPrereleaseDuringUpdate: true
          allowUpdates: true
          artifactErrorsFailBuild: false
          token: "${{ env.GH_TOKEN }}"

      - name: Deploy to fw.jethome.ru (sdcard)
        if: ${{ github.event.inputs.uploadtoserver == 'both' || github.event.inputs.uploadtoserver == 'jethome' }}
        id: upload-sdcard
        uses: jethome-iot/actions/firmware-upload@master
        with:
          url: https://fw.jethome.ru
          fullslug: "JetHome.${{ steps.convertburn.outputs.brd }}.Armbian.${{ steps.convertburn.outputs.channel }}.${{ steps.convertburn.outputs.release }}.${{ steps.convertburn.outputs.branch }}"
          image_type: "sdcard"
          firmware_file: "${{ steps.convertburn.outputs.image }}"
          hashpgp_file: "${{ steps.convertburn.outputs.image }}.asc"
          version: "${{ needs.matrix_prep.outputs.version }}"
          force_overwrite: "true"
          generatefirmwareslot: "true"
          update_latest: "true"
          supported_devices: "${{ steps.convertburn.outputs.supported }}"
          FWUPLOAD: ${{ secrets.FWUPLOAD }}

      - name: Deploy to fw.jethome.ru (burn)
        if: ${{ github.event.inputs.uploadtoserver == 'both' || github.event.inputs.uploadtoserver == 'jethome' }}
        id: upload-burn
        uses: jethome-iot/actions/firmware-upload@master
        with:
          url: https://fw.jethome.ru
          fullslug: "JetHome.${{ steps.convertburn.outputs.brd }}.Armbian.${{ steps.convertburn.outputs.channel }}.${{ steps.convertburn.outputs.release }}.${{ steps.convertburn.outputs.branch }}"
          image_type: "burn"
          firmware_file: "${{ steps.convertburn.outputs.imageburn }}"
          hashpgp_file: "${{ steps.convertburn.outputs.imageburn }}.asc"
          version: "${{ needs.matrix_prep.outputs.version }}"
          generatefirmwareslot: "false"
          force_overwrite: "true"
          update_latest: "true"
          supported_devices: "${{ steps.convertburn.outputs.supported }}"
          FWUPLOAD: ${{ secrets.FWUPLOAD }}

      - name: "Runner clean ${{ needs.matrix_prep.outputs.version }}"
        if: always()
        run: sudo rm -rfv output/images userpatches/VERSION
  "build-images-chunk-14": # templated "build-images-chunk-14"
    needs: [ "matrix_prep", "all-artifacts-ready" ]
    timeout-minutes: 240
    if: ${{ !failure() && !cancelled() && ( github.repository_owner == 'jethome-iot' ) && ( needs.matrix_prep.outputs.images-chunk-not-empty-14 == 'yes' ) }} # <-- HERE: Chunk number.
    strategy:
      fail-fast: false # let other jobs try to complete if one fails
      matrix: ${{ fromJSON(needs.matrix_prep.outputs.images-chunk-json-14) }} # <-- HERE: Chunk number.
    name: ${{ matrix.desc || 'Empty I14' }} # <-- HERE: Chunk number.
    runs-on: ${{ matrix.runs_on }}
    steps:

      # cleaning self hosted runners
      #- name: "Runner clean ${{ needs.matrix_prep.outputs.version }}"
      #  uses: armbian/actions/runner-clean@main

      # cleanup the place where we will clone the userpatches repo, to avoid git going insane and cleaning everything later
      - name: Cleanup userpatches repo
        if: ${{ ( env.USERPATCHES_REPOSITORY != '' ) && ( env.USERPATCHES_REF != '' ) }}
        run: sudo rm -rf userpatches.repo

      - name: Checkout build repo
        uses: actions/checkout@v4
        with:
          repository: ${{ env.BUILD_REPOSITORY }}
          ref: ${{ needs.matrix_prep.outputs.build-sha1 }}
          fetch-depth: ${{ matrix.fdepth }}
          clean: false # true is default. it *will* delete the hosts /dev if mounted inside.

      # clone the userpatches repo (`armbian/os`)
      - name: "Checkout userpatches repo: ${{env.USERPATCHES_REPOSITORY}}#${{env.USERPATCHES_REF}}"
        uses: actions/checkout@v4
        if: ${{ ( env.USERPATCHES_REPOSITORY != '' ) && ( env.USERPATCHES_REF != '' ) }}
        with:
          repository: ${{ env.USERPATCHES_REPOSITORY }}
          ref: ${{ env.USERPATCHES_REF }}
          fetch-depth: ${{ matrix.fdepth }}
          clean: false # true is default.
          path: userpatches.repo

      - name: Checkout jethome-tools repository
        uses: actions/checkout@v4
        with:
          repository: jethome-ru/jethome-tools
          path: tools
          ref: convert_jhos

      - name: "Put userpatches in place, and remove userpatches repo"
        if: ${{ ( env.USERPATCHES_REPOSITORY != '' ) && ( env.USERPATCHES_REF != '' ) }}
        run: |
          mkdir -pv userpatches
          rsync -av userpatches.repo/${{env.USERPATCHES_DIR}}/. userpatches/
          rm -rf userpatches.repo
          echo ${{ needs.matrix_prep.outputs.version }} > userpatches/VERSION

      - name: "Cleanup leftover output"
        run: |
          sudo rm -f userpatches/VERSION

      - name: ${{matrix.desc}}
        id: build-one-image
        timeout-minutes: 300
        run: |
          # calculate loop from runner name
          if [ -z "${ImageOS}" ]; then
            USE_FIXED_LOOP_DEVICE=$(echo ${RUNNER_NAME} | rev | cut -d"-" -f1  | rev | sed 's/^0*//' | sed -e 's/^/\/dev\/loop/')
          fi
          bash ./compile.sh ${{ matrix.invocation }} REVISION="${{ needs.matrix_prep.outputs.version }}" USE_FIXED_LOOP_DEVICE="$USE_FIXED_LOOP_DEVICE" SHARE_LOG=yes MAKE_FOLDERS="archive" IMAGE_VERSION=${{ needs.matrix_prep.outputs.version }} ${{env.EXTRA_PARAMS_IMAGE}} ${{env.EXTRA_PARAMS_ALL_BUILDS}}

      - name: "Logs: ${{ steps.build-one-image.outputs.logs_url }}"
        if: always()
        run: |
          echo "Logs: ${{ steps.build-one-image.outputs.logs_url }}"

      - name: Install SSH key for storage
        env:
          KEY_ARMBIAN_UPLOAD: ${{ secrets.KEY_ARMBIAN_UPLOAD }}
        if: env.KEY_ARMBIAN_UPLOAD != null
        uses: shimataro/ssh-key-action@v2
        with:
          key: ${{ secrets.KEY_ARMBIAN_UPLOAD }}
          known_hosts: ${{ secrets.KNOWN_HOSTS_ARMBIAN_UPLOAD }}
          if_key_exists: replace

      - name: Check API rate limits
        run: |

          # install dependencies
          if ! command -v "gh" > /dev/null 2>&1; then
             sudo apt-get -y -qq install gh
          fi

          while true
            do
            API_CALLS_TOTAL=$(gh api -H "Accept: application/vnd.github+json" -H "X-GitHub-Api-Version: 2022-11-28" /rate_limit | jq -r '.rate.limit')
            API_CALLS_LEFT=$(gh api -H "Accept: application/vnd.github+json" -H "X-GitHub-Api-Version: 2022-11-28" /rate_limit | jq -r '.rate.remaining')
            PERCENT=$(( API_CALLS_LEFT * 100 / API_CALLS_TOTAL ))
            if (( $PERCENT > 20 )); then
                echo "API rate in good shape $PERCENT % free"
                exit 0
            fi
            echo "API rate lower then 20%, sleping 10m"
            sleep 10m
          done

          # show current api rate
          curl -s -H "Accept: application/vnd.github.v3+json" -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" https://api.github.com/rate_limit

      - name: Import GPG key
        env:
          GPG_KEY1: ${{ secrets.GPG_KEY1 }}
        if: env.GPG_KEY1 != null
        uses: crazy-max/ghaction-import-gpg@v6
        with:
          gpg_private_key: ${{ secrets.GPG_KEY1 }}
          passphrase: ${{ secrets.GPG_PASSPHRASE1 }}

      - name: Sign
        env:
          GPG_PASSPHRASE1: ${{ secrets.GPG_PASSPHRASE1 }}
        if: env.GPG_PASSPHRASE1 != null
        run: |

          echo ${{ secrets.GPG_PASSPHRASE1 }} | gpg --passphrase-fd 0 --armor --detach-sign --pinentry-mode loopback --batch --yes output/images/*/archive/*img*.xz

      #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!11
      - name: Check filelist
        run: |
          find output

      - name: "Convert image to burn"
        id: convertburn
        run: |
          if ! command -v "dtc" > /dev/null 2>&1; then
             sudo apt update \
             && sudo apt install device-tree-compiler -y
          fi
          if ! command -v "cc" > /dev/null 2>&1; then
             sudo apt update \
             && sudo apt install build-essential cpp -y
          fi
          if ! command -v "zip" > /dev/null 2>&1; then
             sudo apt update \
             && sudo apt install zip -y
          fi


          UBOOTDEB=$(find output | grep linux-u-boot | head -n 1)
          IMG=$(find output | grep  -e  ".*images.*Armbian.*img.xz$" | head -n 1)
          # Armbian_23.8.0-trunk.52.jh.3.5_Jethubj80_bookworm_current_6.1.32.burn.img

          cd tools

          DEB="../${UBOOTDEB}"
          dpkg -x "$DEB" output
          UBOOT=$(find output/usr/lib -name u-boot.nosd.bin | head -n 1)
          echo UBOOT: ${UBOOT}
          find ../output

          ### 'BETA=yes' 'BOARD=jethubj80' 'BRANCH=current' 'BUILD_DESKTOP=no' 'BUILD_MINIMAL=no' 'RELEASE=bookworm'
          EVALCMD=$(echo ${{ matrix.invocation }} | sed 's/jethome-images//')
          eval ${EVALCMD}
          echo ${EVALCMD}
          case ${BOARD} in
            jethubj100)
              ./convert.sh ../${IMG} d1 armbian compress output/usr/lib/linux*/u-boot.nosd.bin
              SUPPORTED="D1,D1P"
              ;;
            jethubj200)
              ./convert.sh ../${IMG} d2 armbian compress output/usr/lib/linux*/u-boot.nosd.bin
              SUPPORTED="D2"
              ;;
            jethubj80)
              ./convert.sh ../${IMG} h1 armbian compress output/usr/lib/linux*/u-boot.nosd.bin
              SUPPORTED="H1"
              ;;
            *)
              echo "Unsupported board" ${BOARD}
              echo "Error in convert: Unsupported board" ${BOARD} >> GITHUB_STEP_SUMMARY
              exit 200
              ;;
          esac
          rm -rf output/usr

          IMGBURN=$(find output | grep  -e  "Armbian.*burn.img.zip$" | head -n 1)
          echo IMGBURN: ${IMGBURN}
          [ -z "${IMGBURN}" ] && exit 50

          if [ "${BETA}" == "yes" ]; then
            case "${{ env.BUILD_REF }}" in
              main*)
                CHANNEL="nightly"
                ;;
              v2*)
                CHANNEL="rc"
                ;;
              *)
                CHANNEL="${BUILD_REF}"
                ;;
            esac

          else
            CHANNEL="release"
          fi

          echo "board=${BOARD}" >> $GITHUB_OUTPUT
          echo "brd=${BOARD:6}"  >> $GITHUB_OUTPUT
          echo "branch=${BRANCH}" >> $GITHUB_OUTPUT
          echo "channel=${CHANNEL}" >> $GITHUB_OUTPUT
          echo "release=${RELEASE}" >> $GITHUB_OUTPUT
          echo "supported=${SUPPORTED}" >> $GITHUB_OUTPUT
          echo "image=${IMG}" >> $GITHUB_OUTPUT
          echo "imageburn=tools/${IMGBURN}" >> $GITHUB_OUTPUT

      - name: Sign burn
        env:
          GPG_PASSPHRASE1: ${{ secrets.GPG_PASSPHRASE1 }}
        if: env.GPG_PASSPHRASE1 != null
        run: |
          echo ${{ secrets.GPG_PASSPHRASE1 }} | gpg --passphrase-fd 0 --armor --detach-sign --pinentry-mode loopback --batch --yes ${{ steps.convertburn.outputs.imageburn }}

      - name: "Upload artefacts"
        if: ${{ github.event.inputs.uploadtoserver == 'github' || github.event.inputs.uploadtoserver == 'both' }}
        uses: ncipollo/release-action@v1
        with:
          repo: "${{ env.RELEASE_REPOSITORY }}"
          artifacts: "output/images/*/*/Armbian_*.*"
          tag: "${{ needs.matrix_prep.outputs.version }}"
          omitBody: true
          replacesArtifacts: true
          omitName: true
          makeLatest: false
          omitPrereleaseDuringUpdate: true
          allowUpdates: true
          artifactErrorsFailBuild: false
          token: "${{ env.GH_TOKEN }}"

      - name: "Upload artefacts"
        if: ${{ github.event.inputs.uploadtoserver == 'github' || github.event.inputs.uploadtoserver == 'both' }}
        uses: ncipollo/release-action@v1
        with:
          repo: "${{ env.RELEASE_REPOSITORY }}"
          artifacts: "${{ steps.convertburn.outputs.imageburn }}*"
          tag: "${{ needs.matrix_prep.outputs.version }}"
          omitBody: true
          replacesArtifacts: true
          omitName: true
          makeLatest: false
          omitPrereleaseDuringUpdate: true
          allowUpdates: true
          artifactErrorsFailBuild: false
          token: "${{ env.GH_TOKEN }}"

      - name: Deploy to fw.jethome.ru (sdcard)
        if: ${{ github.event.inputs.uploadtoserver == 'both' || github.event.inputs.uploadtoserver == 'jethome' }}
        id: upload-sdcard
        uses: jethome-iot/actions/firmware-upload@master
        with:
          url: https://fw.jethome.ru
          fullslug: "JetHome.${{ steps.convertburn.outputs.brd }}.Armbian.${{ steps.convertburn.outputs.channel }}.${{ steps.convertburn.outputs.release }}.${{ steps.convertburn.outputs.branch }}"
          image_type: "sdcard"
          firmware_file: "${{ steps.convertburn.outputs.image }}"
          hashpgp_file: "${{ steps.convertburn.outputs.image }}.asc"
          version: "${{ needs.matrix_prep.outputs.version }}"
          force_overwrite: "true"
          generatefirmwareslot: "true"
          update_latest: "true"
          supported_devices: "${{ steps.convertburn.outputs.supported }}"
          FWUPLOAD: ${{ secrets.FWUPLOAD }}

      - name: Deploy to fw.jethome.ru (burn)
        if: ${{ github.event.inputs.uploadtoserver == 'both' || github.event.inputs.uploadtoserver == 'jethome' }}
        id: upload-burn
        uses: jethome-iot/actions/firmware-upload@master
        with:
          url: https://fw.jethome.ru
          fullslug: "JetHome.${{ steps.convertburn.outputs.brd }}.Armbian.${{ steps.convertburn.outputs.channel }}.${{ steps.convertburn.outputs.release }}.${{ steps.convertburn.outputs.branch }}"
          image_type: "burn"
          firmware_file: "${{ steps.convertburn.outputs.imageburn }}"
          hashpgp_file: "${{ steps.convertburn.outputs.imageburn }}.asc"
          version: "${{ needs.matrix_prep.outputs.version }}"
          generatefirmwareslot: "false"
          force_overwrite: "true"
          update_latest: "true"
          supported_devices: "${{ steps.convertburn.outputs.supported }}"
          FWUPLOAD: ${{ secrets.FWUPLOAD }}

      - name: "Runner clean ${{ needs.matrix_prep.outputs.version }}"
        if: always()
        run: sudo rm -rfv output/images userpatches/VERSION
  "build-images-chunk-15": # templated "build-images-chunk-15"
    needs: [ "matrix_prep", "all-artifacts-ready" ]
    timeout-minutes: 240
    if: ${{ !failure() && !cancelled() && ( github.repository_owner == 'jethome-iot' ) && ( needs.matrix_prep.outputs.images-chunk-not-empty-15 == 'yes' ) }} # <-- HERE: Chunk number.
    strategy:
      fail-fast: false # let other jobs try to complete if one fails
      matrix: ${{ fromJSON(needs.matrix_prep.outputs.images-chunk-json-15) }} # <-- HERE: Chunk number.
    name: ${{ matrix.desc || 'Empty I15' }} # <-- HERE: Chunk number.
    runs-on: ${{ matrix.runs_on }}
    steps:

      # cleaning self hosted runners
      #- name: "Runner clean ${{ needs.matrix_prep.outputs.version }}"
      #  uses: armbian/actions/runner-clean@main

      # cleanup the place where we will clone the userpatches repo, to avoid git going insane and cleaning everything later
      - name: Cleanup userpatches repo
        if: ${{ ( env.USERPATCHES_REPOSITORY != '' ) && ( env.USERPATCHES_REF != '' ) }}
        run: sudo rm -rf userpatches.repo

      - name: Checkout build repo
        uses: actions/checkout@v4
        with:
          repository: ${{ env.BUILD_REPOSITORY }}
          ref: ${{ needs.matrix_prep.outputs.build-sha1 }}
          fetch-depth: ${{ matrix.fdepth }}
          clean: false # true is default. it *will* delete the hosts /dev if mounted inside.

      # clone the userpatches repo (`armbian/os`)
      - name: "Checkout userpatches repo: ${{env.USERPATCHES_REPOSITORY}}#${{env.USERPATCHES_REF}}"
        uses: actions/checkout@v4
        if: ${{ ( env.USERPATCHES_REPOSITORY != '' ) && ( env.USERPATCHES_REF != '' ) }}
        with:
          repository: ${{ env.USERPATCHES_REPOSITORY }}
          ref: ${{ env.USERPATCHES_REF }}
          fetch-depth: ${{ matrix.fdepth }}
          clean: false # true is default.
          path: userpatches.repo

      - name: Checkout jethome-tools repository
        uses: actions/checkout@v4
        with:
          repository: jethome-ru/jethome-tools
          path: tools
          ref: convert_jhos

      - name: "Put userpatches in place, and remove userpatches repo"
        if: ${{ ( env.USERPATCHES_REPOSITORY != '' ) && ( env.USERPATCHES_REF != '' ) }}
        run: |
          mkdir -pv userpatches
          rsync -av userpatches.repo/${{env.USERPATCHES_DIR}}/. userpatches/
          rm -rf userpatches.repo
          echo ${{ needs.matrix_prep.outputs.version }} > userpatches/VERSION

      - name: "Cleanup leftover output"
        run: |
          sudo rm -f userpatches/VERSION

      - name: ${{matrix.desc}}
        id: build-one-image
        timeout-minutes: 300
        run: |
          # calculate loop from runner name
          if [ -z "${ImageOS}" ]; then
            USE_FIXED_LOOP_DEVICE=$(echo ${RUNNER_NAME} | rev | cut -d"-" -f1  | rev | sed 's/^0*//' | sed -e 's/^/\/dev\/loop/')
          fi
          bash ./compile.sh ${{ matrix.invocation }} REVISION="${{ needs.matrix_prep.outputs.version }}" USE_FIXED_LOOP_DEVICE="$USE_FIXED_LOOP_DEVICE" SHARE_LOG=yes MAKE_FOLDERS="archive" IMAGE_VERSION=${{ needs.matrix_prep.outputs.version }} ${{env.EXTRA_PARAMS_IMAGE}} ${{env.EXTRA_PARAMS_ALL_BUILDS}}

      - name: "Logs: ${{ steps.build-one-image.outputs.logs_url }}"
        if: always()
        run: |
          echo "Logs: ${{ steps.build-one-image.outputs.logs_url }}"

      - name: Install SSH key for storage
        env:
          KEY_ARMBIAN_UPLOAD: ${{ secrets.KEY_ARMBIAN_UPLOAD }}
        if: env.KEY_ARMBIAN_UPLOAD != null
        uses: shimataro/ssh-key-action@v2
        with:
          key: ${{ secrets.KEY_ARMBIAN_UPLOAD }}
          known_hosts: ${{ secrets.KNOWN_HOSTS_ARMBIAN_UPLOAD }}
          if_key_exists: replace

      - name: Check API rate limits
        run: |

          # install dependencies
          if ! command -v "gh" > /dev/null 2>&1; then
             sudo apt-get -y -qq install gh
          fi

          while true
            do
            API_CALLS_TOTAL=$(gh api -H "Accept: application/vnd.github+json" -H "X-GitHub-Api-Version: 2022-11-28" /rate_limit | jq -r '.rate.limit')
            API_CALLS_LEFT=$(gh api -H "Accept: application/vnd.github+json" -H "X-GitHub-Api-Version: 2022-11-28" /rate_limit | jq -r '.rate.remaining')
            PERCENT=$(( API_CALLS_LEFT * 100 / API_CALLS_TOTAL ))
            if (( $PERCENT > 20 )); then
                echo "API rate in good shape $PERCENT % free"
                exit 0
            fi
            echo "API rate lower then 20%, sleping 10m"
            sleep 10m
          done

          # show current api rate
          curl -s -H "Accept: application/vnd.github.v3+json" -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" https://api.github.com/rate_limit

      - name: Import GPG key
        env:
          GPG_KEY1: ${{ secrets.GPG_KEY1 }}
        if: env.GPG_KEY1 != null
        uses: crazy-max/ghaction-import-gpg@v6
        with:
          gpg_private_key: ${{ secrets.GPG_KEY1 }}
          passphrase: ${{ secrets.GPG_PASSPHRASE1 }}

      - name: Sign
        env:
          GPG_PASSPHRASE1: ${{ secrets.GPG_PASSPHRASE1 }}
        if: env.GPG_PASSPHRASE1 != null
        run: |

          echo ${{ secrets.GPG_PASSPHRASE1 }} | gpg --passphrase-fd 0 --armor --detach-sign --pinentry-mode loopback --batch --yes output/images/*/archive/*img*.xz

      #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!11
      - name: Check filelist
        run: |
          find output

      - name: "Convert image to burn"
        id: convertburn
        run: |
          if ! command -v "dtc" > /dev/null 2>&1; then
             sudo apt update \
             && sudo apt install device-tree-compiler -y
          fi
          if ! command -v "cc" > /dev/null 2>&1; then
             sudo apt update \
             && sudo apt install build-essential cpp -y
          fi
          if ! command -v "zip" > /dev/null 2>&1; then
             sudo apt update \
             && sudo apt install zip -y
          fi


          UBOOTDEB=$(find output | grep linux-u-boot | head -n 1)
          IMG=$(find output | grep  -e  ".*images.*Armbian.*img.xz$" | head -n 1)
          # Armbian_23.8.0-trunk.52.jh.3.5_Jethubj80_bookworm_current_6.1.32.burn.img

          cd tools

          DEB="../${UBOOTDEB}"
          dpkg -x "$DEB" output
          UBOOT=$(find output/usr/lib -name u-boot.nosd.bin | head -n 1)
          echo UBOOT: ${UBOOT}
          find ../output

          ### 'BETA=yes' 'BOARD=jethubj80' 'BRANCH=current' 'BUILD_DESKTOP=no' 'BUILD_MINIMAL=no' 'RELEASE=bookworm'
          EVALCMD=$(echo ${{ matrix.invocation }} | sed 's/jethome-images//')
          eval ${EVALCMD}
          echo ${EVALCMD}
          case ${BOARD} in
            jethubj100)
              ./convert.sh ../${IMG} d1 armbian compress output/usr/lib/linux*/u-boot.nosd.bin
              SUPPORTED="D1,D1P"
              ;;
            jethubj200)
              ./convert.sh ../${IMG} d2 armbian compress output/usr/lib/linux*/u-boot.nosd.bin
              SUPPORTED="D2"
              ;;
            jethubj80)
              ./convert.sh ../${IMG} h1 armbian compress output/usr/lib/linux*/u-boot.nosd.bin
              SUPPORTED="H1"
              ;;
            *)
              echo "Unsupported board" ${BOARD}
              echo "Error in convert: Unsupported board" ${BOARD} >> GITHUB_STEP_SUMMARY
              exit 200
              ;;
          esac
          rm -rf output/usr

          IMGBURN=$(find output | grep  -e  "Armbian.*burn.img.zip$" | head -n 1)
          echo IMGBURN: ${IMGBURN}
          [ -z "${IMGBURN}" ] && exit 50

          if [ "${BETA}" == "yes" ]; then
            case "${{ env.BUILD_REF }}" in
              main*)
                CHANNEL="nightly"
                ;;
              v2*)
                CHANNEL="rc"
                ;;
              *)
                CHANNEL="${BUILD_REF}"
                ;;
            esac

          else
            CHANNEL="release"
          fi

          echo "board=${BOARD}" >> $GITHUB_OUTPUT
          echo "brd=${BOARD:6}"  >> $GITHUB_OUTPUT
          echo "branch=${BRANCH}" >> $GITHUB_OUTPUT
          echo "channel=${CHANNEL}" >> $GITHUB_OUTPUT
          echo "release=${RELEASE}" >> $GITHUB_OUTPUT
          echo "supported=${SUPPORTED}" >> $GITHUB_OUTPUT
          echo "image=${IMG}" >> $GITHUB_OUTPUT
          echo "imageburn=tools/${IMGBURN}" >> $GITHUB_OUTPUT

      - name: Sign burn
        env:
          GPG_PASSPHRASE1: ${{ secrets.GPG_PASSPHRASE1 }}
        if: env.GPG_PASSPHRASE1 != null
        run: |
          echo ${{ secrets.GPG_PASSPHRASE1 }} | gpg --passphrase-fd 0 --armor --detach-sign --pinentry-mode loopback --batch --yes ${{ steps.convertburn.outputs.imageburn }}

      - name: "Upload artefacts"
        if: ${{ github.event.inputs.uploadtoserver == 'github' || github.event.inputs.uploadtoserver == 'both' }}
        uses: ncipollo/release-action@v1
        with:
          repo: "${{ env.RELEASE_REPOSITORY }}"
          artifacts: "output/images/*/*/Armbian_*.*"
          tag: "${{ needs.matrix_prep.outputs.version }}"
          omitBody: true
          replacesArtifacts: true
          omitName: true
          makeLatest: false
          omitPrereleaseDuringUpdate: true
          allowUpdates: true
          artifactErrorsFailBuild: false
          token: "${{ env.GH_TOKEN }}"

      - name: "Upload artefacts"
        if: ${{ github.event.inputs.uploadtoserver == 'github' || github.event.inputs.uploadtoserver == 'both' }}
        uses: ncipollo/release-action@v1
        with:
          repo: "${{ env.RELEASE_REPOSITORY }}"
          artifacts: "${{ steps.convertburn.outputs.imageburn }}*"
          tag: "${{ needs.matrix_prep.outputs.version }}"
          omitBody: true
          replacesArtifacts: true
          omitName: true
          makeLatest: false
          omitPrereleaseDuringUpdate: true
          allowUpdates: true
          artifactErrorsFailBuild: false
          token: "${{ env.GH_TOKEN }}"

      - name: Deploy to fw.jethome.ru (sdcard)
        if: ${{ github.event.inputs.uploadtoserver == 'both' || github.event.inputs.uploadtoserver == 'jethome' }}
        id: upload-sdcard
        uses: jethome-iot/actions/firmware-upload@master
        with:
          url: https://fw.jethome.ru
          fullslug: "JetHome.${{ steps.convertburn.outputs.brd }}.Armbian.${{ steps.convertburn.outputs.channel }}.${{ steps.convertburn.outputs.release }}.${{ steps.convertburn.outputs.branch }}"
          image_type: "sdcard"
          firmware_file: "${{ steps.convertburn.outputs.image }}"
          hashpgp_file: "${{ steps.convertburn.outputs.image }}.asc"
          version: "${{ needs.matrix_prep.outputs.version }}"
          force_overwrite: "true"
          generatefirmwareslot: "true"
          update_latest: "true"
          supported_devices: "${{ steps.convertburn.outputs.supported }}"
          FWUPLOAD: ${{ secrets.FWUPLOAD }}

      - name: Deploy to fw.jethome.ru (burn)
        if: ${{ github.event.inputs.uploadtoserver == 'both' || github.event.inputs.uploadtoserver == 'jethome' }}
        id: upload-burn
        uses: jethome-iot/actions/firmware-upload@master
        with:
          url: https://fw.jethome.ru
          fullslug: "JetHome.${{ steps.convertburn.outputs.brd }}.Armbian.${{ steps.convertburn.outputs.channel }}.${{ steps.convertburn.outputs.release }}.${{ steps.convertburn.outputs.branch }}"
          image_type: "burn"
          firmware_file: "${{ steps.convertburn.outputs.imageburn }}"
          hashpgp_file: "${{ steps.convertburn.outputs.imageburn }}.asc"
          version: "${{ needs.matrix_prep.outputs.version }}"
          generatefirmwareslot: "false"
          force_overwrite: "true"
          update_latest: "true"
          supported_devices: "${{ steps.convertburn.outputs.supported }}"
          FWUPLOAD: ${{ secrets.FWUPLOAD }}

      - name: "Runner clean ${{ needs.matrix_prep.outputs.version }}"
        if: always()
        run: sudo rm -rfv output/images userpatches/VERSION
  "build-images-chunk-16": # templated "build-images-chunk-16"
    needs: [ "matrix_prep", "all-artifacts-ready" ]
    timeout-minutes: 240
    if: ${{ !failure() && !cancelled() && ( github.repository_owner == 'jethome-iot' ) && ( needs.matrix_prep.outputs.images-chunk-not-empty-16 == 'yes' ) }} # <-- HERE: Chunk number.
    strategy:
      fail-fast: false # let other jobs try to complete if one fails
      matrix: ${{ fromJSON(needs.matrix_prep.outputs.images-chunk-json-16) }} # <-- HERE: Chunk number.
    name: ${{ matrix.desc || 'Empty I16' }} # <-- HERE: Chunk number.
    runs-on: ${{ matrix.runs_on }}
    steps:

      # cleaning self hosted runners
      #- name: "Runner clean ${{ needs.matrix_prep.outputs.version }}"
      #  uses: armbian/actions/runner-clean@main

      # cleanup the place where we will clone the userpatches repo, to avoid git going insane and cleaning everything later
      - name: Cleanup userpatches repo
        if: ${{ ( env.USERPATCHES_REPOSITORY != '' ) && ( env.USERPATCHES_REF != '' ) }}
        run: sudo rm -rf userpatches.repo

      - name: Checkout build repo
        uses: actions/checkout@v4
        with:
          repository: ${{ env.BUILD_REPOSITORY }}
          ref: ${{ needs.matrix_prep.outputs.build-sha1 }}
          fetch-depth: ${{ matrix.fdepth }}
          clean: false # true is default. it *will* delete the hosts /dev if mounted inside.

      # clone the userpatches repo (`armbian/os`)
      - name: "Checkout userpatches repo: ${{env.USERPATCHES_REPOSITORY}}#${{env.USERPATCHES_REF}}"
        uses: actions/checkout@v4
        if: ${{ ( env.USERPATCHES_REPOSITORY != '' ) && ( env.USERPATCHES_REF != '' ) }}
        with:
          repository: ${{ env.USERPATCHES_REPOSITORY }}
          ref: ${{ env.USERPATCHES_REF }}
          fetch-depth: ${{ matrix.fdepth }}
          clean: false # true is default.
          path: userpatches.repo

      - name: Checkout jethome-tools repository
        uses: actions/checkout@v4
        with:
          repository: jethome-ru/jethome-tools
          path: tools
          ref: convert_jhos

      - name: "Put userpatches in place, and remove userpatches repo"
        if: ${{ ( env.USERPATCHES_REPOSITORY != '' ) && ( env.USERPATCHES_REF != '' ) }}
        run: |
          mkdir -pv userpatches
          rsync -av userpatches.repo/${{env.USERPATCHES_DIR}}/. userpatches/
          rm -rf userpatches.repo
          echo ${{ needs.matrix_prep.outputs.version }} > userpatches/VERSION

      - name: "Cleanup leftover output"
        run: |
          sudo rm -f userpatches/VERSION

      - name: ${{matrix.desc}}
        id: build-one-image
        timeout-minutes: 300
        run: |
          # calculate loop from runner name
          if [ -z "${ImageOS}" ]; then
            USE_FIXED_LOOP_DEVICE=$(echo ${RUNNER_NAME} | rev | cut -d"-" -f1  | rev | sed 's/^0*//' | sed -e 's/^/\/dev\/loop/')
          fi
          bash ./compile.sh ${{ matrix.invocation }} REVISION="${{ needs.matrix_prep.outputs.version }}" USE_FIXED_LOOP_DEVICE="$USE_FIXED_LOOP_DEVICE" SHARE_LOG=yes MAKE_FOLDERS="archive" IMAGE_VERSION=${{ needs.matrix_prep.outputs.version }} ${{env.EXTRA_PARAMS_IMAGE}} ${{env.EXTRA_PARAMS_ALL_BUILDS}}

      - name: "Logs: ${{ steps.build-one-image.outputs.logs_url }}"
        if: always()
        run: |
          echo "Logs: ${{ steps.build-one-image.outputs.logs_url }}"

      - name: Install SSH key for storage
        env:
          KEY_ARMBIAN_UPLOAD: ${{ secrets.KEY_ARMBIAN_UPLOAD }}
        if: env.KEY_ARMBIAN_UPLOAD != null
        uses: shimataro/ssh-key-action@v2
        with:
          key: ${{ secrets.KEY_ARMBIAN_UPLOAD }}
          known_hosts: ${{ secrets.KNOWN_HOSTS_ARMBIAN_UPLOAD }}
          if_key_exists: replace

      - name: Check API rate limits
        run: |

          # install dependencies
          if ! command -v "gh" > /dev/null 2>&1; then
             sudo apt-get -y -qq install gh
          fi

          while true
            do
            API_CALLS_TOTAL=$(gh api -H "Accept: application/vnd.github+json" -H "X-GitHub-Api-Version: 2022-11-28" /rate_limit | jq -r '.rate.limit')
            API_CALLS_LEFT=$(gh api -H "Accept: application/vnd.github+json" -H "X-GitHub-Api-Version: 2022-11-28" /rate_limit | jq -r '.rate.remaining')
            PERCENT=$(( API_CALLS_LEFT * 100 / API_CALLS_TOTAL ))
            if (( $PERCENT > 20 )); then
                echo "API rate in good shape $PERCENT % free"
                exit 0
            fi
            echo "API rate lower then 20%, sleping 10m"
            sleep 10m
          done

          # show current api rate
          curl -s -H "Accept: application/vnd.github.v3+json" -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" https://api.github.com/rate_limit

      - name: Import GPG key
        env:
          GPG_KEY1: ${{ secrets.GPG_KEY1 }}
        if: env.GPG_KEY1 != null
        uses: crazy-max/ghaction-import-gpg@v6
        with:
          gpg_private_key: ${{ secrets.GPG_KEY1 }}
          passphrase: ${{ secrets.GPG_PASSPHRASE1 }}

      - name: Sign
        env:
          GPG_PASSPHRASE1: ${{ secrets.GPG_PASSPHRASE1 }}
        if: env.GPG_PASSPHRASE1 != null
        run: |

          echo ${{ secrets.GPG_PASSPHRASE1 }} | gpg --passphrase-fd 0 --armor --detach-sign --pinentry-mode loopback --batch --yes output/images/*/archive/*img*.xz

      #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!11
      - name: Check filelist
        run: |
          find output

      - name: "Convert image to burn"
        id: convertburn
        run: |
          if ! command -v "dtc" > /dev/null 2>&1; then
             sudo apt update \
             && sudo apt install device-tree-compiler -y
          fi
          if ! command -v "cc" > /dev/null 2>&1; then
             sudo apt update \
             && sudo apt install build-essential cpp -y
          fi
          if ! command -v "zip" > /dev/null 2>&1; then
             sudo apt update \
             && sudo apt install zip -y
          fi


          UBOOTDEB=$(find output | grep linux-u-boot | head -n 1)
          IMG=$(find output | grep  -e  ".*images.*Armbian.*img.xz$" | head -n 1)
          # Armbian_23.8.0-trunk.52.jh.3.5_Jethubj80_bookworm_current_6.1.32.burn.img

          cd tools

          DEB="../${UBOOTDEB}"
          dpkg -x "$DEB" output
          UBOOT=$(find output/usr/lib -name u-boot.nosd.bin | head -n 1)
          echo UBOOT: ${UBOOT}
          find ../output

          ### 'BETA=yes' 'BOARD=jethubj80' 'BRANCH=current' 'BUILD_DESKTOP=no' 'BUILD_MINIMAL=no' 'RELEASE=bookworm'
          EVALCMD=$(echo ${{ matrix.invocation }} | sed 's/jethome-images//')
          eval ${EVALCMD}
          echo ${EVALCMD}
          case ${BOARD} in
            jethubj100)
              ./convert.sh ../${IMG} d1 armbian compress output/usr/lib/linux*/u-boot.nosd.bin
              SUPPORTED="D1,D1P"
              ;;
            jethubj200)
              ./convert.sh ../${IMG} d2 armbian compress output/usr/lib/linux*/u-boot.nosd.bin
              SUPPORTED="D2"
              ;;
            jethubj80)
              ./convert.sh ../${IMG} h1 armbian compress output/usr/lib/linux*/u-boot.nosd.bin
              SUPPORTED="H1"
              ;;
            *)
              echo "Unsupported board" ${BOARD}
              echo "Error in convert: Unsupported board" ${BOARD} >> GITHUB_STEP_SUMMARY
              exit 200
              ;;
          esac
          rm -rf output/usr

          IMGBURN=$(find output | grep  -e  "Armbian.*burn.img.zip$" | head -n 1)
          echo IMGBURN: ${IMGBURN}
          [ -z "${IMGBURN}" ] && exit 50

          if [ "${BETA}" == "yes" ]; then
            case "${{ env.BUILD_REF }}" in
              main*)
                CHANNEL="nightly"
                ;;
              v2*)
                CHANNEL="rc"
                ;;
              *)
                CHANNEL="${BUILD_REF}"
                ;;
            esac

          else
            CHANNEL="release"
          fi

          echo "board=${BOARD}" >> $GITHUB_OUTPUT
          echo "brd=${BOARD:6}"  >> $GITHUB_OUTPUT
          echo "branch=${BRANCH}" >> $GITHUB_OUTPUT
          echo "channel=${CHANNEL}" >> $GITHUB_OUTPUT
          echo "release=${RELEASE}" >> $GITHUB_OUTPUT
          echo "supported=${SUPPORTED}" >> $GITHUB_OUTPUT
          echo "image=${IMG}" >> $GITHUB_OUTPUT
          echo "imageburn=tools/${IMGBURN}" >> $GITHUB_OUTPUT

      - name: Sign burn
        env:
          GPG_PASSPHRASE1: ${{ secrets.GPG_PASSPHRASE1 }}
        if: env.GPG_PASSPHRASE1 != null
        run: |
          echo ${{ secrets.GPG_PASSPHRASE1 }} | gpg --passphrase-fd 0 --armor --detach-sign --pinentry-mode loopback --batch --yes ${{ steps.convertburn.outputs.imageburn }}

      - name: "Upload artefacts"
        if: ${{ github.event.inputs.uploadtoserver == 'github' || github.event.inputs.uploadtoserver == 'both' }}
        uses: ncipollo/release-action@v1
        with:
          repo: "${{ env.RELEASE_REPOSITORY }}"
          artifacts: "output/images/*/*/Armbian_*.*"
          tag: "${{ needs.matrix_prep.outputs.version }}"
          omitBody: true
          replacesArtifacts: true
          omitName: true
          makeLatest: false
          omitPrereleaseDuringUpdate: true
          allowUpdates: true
          artifactErrorsFailBuild: false
          token: "${{ env.GH_TOKEN }}"

      - name: "Upload artefacts"
        if: ${{ github.event.inputs.uploadtoserver == 'github' || github.event.inputs.uploadtoserver == 'both' }}
        uses: ncipollo/release-action@v1
        with:
          repo: "${{ env.RELEASE_REPOSITORY }}"
          artifacts: "${{ steps.convertburn.outputs.imageburn }}*"
          tag: "${{ needs.matrix_prep.outputs.version }}"
          omitBody: true
          replacesArtifacts: true
          omitName: true
          makeLatest: false
          omitPrereleaseDuringUpdate: true
          allowUpdates: true
          artifactErrorsFailBuild: false
          token: "${{ env.GH_TOKEN }}"

      - name: Deploy to fw.jethome.ru (sdcard)
        if: ${{ github.event.inputs.uploadtoserver == 'both' || github.event.inputs.uploadtoserver == 'jethome' }}
        id: upload-sdcard
        uses: jethome-iot/actions/firmware-upload@master
        with:
          url: https://fw.jethome.ru
          fullslug: "JetHome.${{ steps.convertburn.outputs.brd }}.Armbian.${{ steps.convertburn.outputs.channel }}.${{ steps.convertburn.outputs.release }}.${{ steps.convertburn.outputs.branch }}"
          image_type: "sdcard"
          firmware_file: "${{ steps.convertburn.outputs.image }}"
          hashpgp_file: "${{ steps.convertburn.outputs.image }}.asc"
          version: "${{ needs.matrix_prep.outputs.version }}"
          force_overwrite: "true"
          generatefirmwareslot: "true"
          update_latest: "true"
          supported_devices: "${{ steps.convertburn.outputs.supported }}"
          FWUPLOAD: ${{ secrets.FWUPLOAD }}

      - name: Deploy to fw.jethome.ru (burn)
        if: ${{ github.event.inputs.uploadtoserver == 'both' || github.event.inputs.uploadtoserver == 'jethome' }}
        id: upload-burn
        uses: jethome-iot/actions/firmware-upload@master
        with:
          url: https://fw.jethome.ru
          fullslug: "JetHome.${{ steps.convertburn.outputs.brd }}.Armbian.${{ steps.convertburn.outputs.channel }}.${{ steps.convertburn.outputs.release }}.${{ steps.convertburn.outputs.branch }}"
          image_type: "burn"
          firmware_file: "${{ steps.convertburn.outputs.imageburn }}"
          hashpgp_file: "${{ steps.convertburn.outputs.imageburn }}.asc"
          version: "${{ needs.matrix_prep.outputs.version }}"
          generatefirmwareslot: "false"
          force_overwrite: "true"
          update_latest: "true"
          supported_devices: "${{ steps.convertburn.outputs.supported }}"
          FWUPLOAD: ${{ secrets.FWUPLOAD }}

      - name: "Runner clean ${{ needs.matrix_prep.outputs.version }}"
        if: always()
        run: sudo rm -rfv output/images userpatches/VERSION

# template file: 750.single_repo.yaml

  # ------ publish packages to repository -------

  publish-debs-to-repo:
    name: "publish debs to repo"
    runs-on: [ "self-hosted", "Linux", "vm" ]
    if: ${{ !failure() && !cancelled() && (github.event.inputs.targetsFilterInclude == '') }} # eg: run if dependencies worked. See https://github.com/orgs/community/discussions/45058#discussioncomment-4817378
    needs: [ "version_prep", "matrix_prep", "all-artifacts-ready" ]
    steps:

      #- name: "Runner clean ${{ needs.matrix_prep.outputs.version }}"
      #  uses: armbian/actions/runner-clean@main

      # Prepare dependencies.
      # If no /usr/bin/gpg, install gnupg2
      # If no /usr/bin/reprepro, install reprepro
      - name: Install dependencies
        run: |
          if [ ! -e /usr/bin/gpg ]; then
            sudo apt-get update
            sudo apt-get install -y gnupg2
          fi

      # Login to ghcr.io, for later uploading rootfs to ghcr.io
      - name: Docker Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: "${{ github.repository_owner }}" # GitHub username or org
          password: "${{ secrets.GITHUB_TOKEN }}"    # GitHub actions builtin token. repo has to have pkg access.

      # cleanup the place where we will clone the userpatches repo, to avoid git going insane and cleaning everything later
      - name: Cleanup userpatches repo
        if: ${{ ( env.USERPATCHES_REPOSITORY != '' ) && ( env.USERPATCHES_REF != '' ) }}
        run: sudo rm -rf userpatches.repo

      - name: Checkout build repo
        uses: actions/checkout@v4 # We don't need to clone git, really. A wget would suffice for GH-hosted runners. But using clone is better for Igor-hosted runners.
        with:
          repository: ${{ env.BUILD_REPOSITORY }}
          ref: ${{ needs.matrix_prep.outputs.build-sha1 }}
          fetch-depth: 1
          clean: false # true is default. it *will* delete the hosts /dev if mounted inside.

      # clone the userpatches repo (`armbian/os`)
      - name: "Checkout userpatches repo: ${{env.USERPATCHES_REPOSITORY}}#${{env.USERPATCHES_REF}}"
        uses: actions/checkout@v4
        if: ${{ ( env.USERPATCHES_REPOSITORY != '' ) && ( env.USERPATCHES_REF != '' ) }}
        with:
          repository: ${{ env.USERPATCHES_REPOSITORY }}
          ref: ${{ env.USERPATCHES_REF }}
          fetch-depth: 1
          clean: false # true is default.
          path: userpatches.repo

      - name: "Put userpatches in place, and remove userpatches repo"
        if: ${{ ( env.USERPATCHES_REPOSITORY != '' ) && ( env.USERPATCHES_REF != '' ) }}
        run: |
          mkdir -pv userpatches
          rsync -av userpatches.repo/${{env.USERPATCHES_DIR}}/. userpatches/
          #rm -rf userpatches.repo
          echo ${{ needs.matrix_prep.outputs.version }} > userpatches/VERSION

      # Clean off output/info, if any
      - name: Cleanup output/info
        run: |
          sudo rm -rfv output/info output/debs output/debs-beta
          mkdir -pv output

      # Download the artifacts (output/info) produced by the prepare-matrix job.
      - name: Download artifacts
        uses: actions/download-artifact@v4
        with:
          name: build-info-json
          path: output/info

      # List the artifacts we downloaded
      - name: List artifacts
        run: |
          ls -laht output/info

      - name: Download the debs
        id: download-debs
        run: |
          bash ./compile.sh debs-to-repo-download REVISION="${{ needs.matrix_prep.outputs.version }}" BETA=${{ github.event.inputs.nightlybuild || 'no' }} SHARE_LOG=yes ${{env.EXTRA_PARAMS_ALL_BUILDS}}

      - name: Import GPG key
        uses: crazy-max/ghaction-import-gpg@v6
        with:
          gpg_private_key: ${{ secrets.GPG_KEY1 }}
          passphrase: ${{ secrets.GPG_PASSPHRASE1 }}

      - name: "Logs debs-to-repo-download: ${{ steps.download-debs.outputs.logs_url }}"
        run: |
          echo "Logs debs-to-repo-download: ${{ steps.download-debs.outputs.logs_url }}"


      - name: Show GPG user IDs
        run: |
          echo "fingerprint: ${{ steps.import_gpg.outputs.fingerprint }}"
          echo "keyid:       ${{ steps.import_gpg.outputs.keyid }}"
          echo "name:        ${{ steps.import_gpg.outputs.name }}"
          echo "email:       ${{ steps.import_gpg.outputs.email }}"

      - name: List loaded keys keys
        run: gpg -K || true

      - name: Prepare the reprepro scripts
        id: prepare-scripts-reprepro
        run: |
          bash ./compile.sh debs-to-repo-reprepro BETA=${{ github.event.inputs.nightlybuild || 'yes' }} REPO_GPG_KEYID="${{ steps.import_gpg.outputs.keyid }}" SHARE_LOG=yes ${{env.EXTRA_PARAMS_ALL_BUILDS}}

      - name: "Logs debs-to-repo-reprepro: ${{ steps.prepare-scripts-reprepro.outputs.logs_url }}"
        run: |
          echo "Logs debs-to-repo-reprepro: ${{ steps.prepare-scripts-reprepro.outputs.logs_url }}"
          find output

      - name: Push debs to repository
        id: push-debs
        uses: jethome-iot/actions/repo-upload-json@master
        with:
          target: ${{ needs.version_prep.outputs.repoupload }}
          nightly: ${{ github.event.inputs.nightlybuild || 'yes' }}
          json: output/info/debs-to-repo-info.json
          SSH_KEY: ${{ secrets.SSH_KEY }}
          SSH_KNOWNHOSTS_UPLOAD: ${{ secrets.SSH_KNOWNHOSTS_UPLOAD }}

# template file: 950.single_footer.yaml

  # ------ aggregate all artifact chunks into a single dependency -------

  closing:
    name: "Footer"
    runs-on: ubuntu-latest
    if: ${{ !failure() && !cancelled() }}
    needs: [ "matrix_prep", "all-artifacts-ready", "all-images-ready" ]
    steps:
      - name: "Download all workflow run artifacts"
        if: ${{ (github.event.inputs.skipImages || 'no') != 'yes' }}
        uses: actions/download-artifact@v4
        with:
          name: assets-for-download-v24.11
          path: downloads

      - name: "Read version"
        run: |

          echo "version=$(cat downloads/version 2>/dev/null || true)" >> $GITHUB_ENV

      # Delete artifact
      - uses: geekyeggo/delete-artifact@v5
        with:
          name: assets-for-download-v24.11
          failOnError: false

      # Cleaning releases
      - uses: dev-drprasad/delete-older-releases@v0.3.4
        with:
          repo: jethome-iot/armbian-os
          keep_latest: 16
        env:
          GITHUB_TOKEN: ${{ env.GH_TOKEN }}

      # Cleaning logs
      - name: "Keep only 14 days of workflow logs"
        uses: igorjs/gh-actions-clean-workflow@v6
        with:
          token: "${{ env.GH_TOKEN }}"
          runs_older_than: 14 # optional
          runs_to_keep: 0 # optional

      # Switch pre-release to release
      - uses: ncipollo/release-action@v1
        if: ${{ (github.event.inputs.skipImages || 'no') != 'yes' && (github.event.inputs.nightlybuild || 'no') == 'yes' }}
        with:
          repo: "${{ env.RELEASE_REPOSITORY }}"
          tag: "${{ needs.matrix_prep.outputs.version }}"
          omitBody: true
          omitName: true
          allowUpdates: true
          makeLatest: true
          token: "${{ env.GH_TOKEN }}"
